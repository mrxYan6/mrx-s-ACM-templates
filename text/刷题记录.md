# æ€ç»´

## 1.cfgym103931CCoffee Overdose

**é¢˜ç›®æè¿°**

æˆ‘ä»¬ç”¨ä½“åŠ› S æ¥è¡¨ç¤ºä½ çš„ç²¾ç¥çŠ¶æ€ã€‚åœ¨æ¯ä¸€ç§’é’Ÿï¼Œä½ ä¸ºä½ çš„é¡¹ç›®è´¡çŒ® S çš„å®Œæˆåº¦ï¼Œä¹‹åä½ çš„ä½“åŠ›ä¼šå‡ å°‘ 1ã€‚å½“ä½ çš„ä½“åŠ›å‡å°‘åˆ° 0 æˆ–æ›´å°‘æ—¶ï¼Œä½ ä¼šå½»åº•å¤±æ§å¹¶è¿›å…¥æ¢¦ä¹¡ã€‚ ä½ å¯ä»¥åœ¨æ¯ç§’é’Ÿåˆšå¥½å¼€å§‹æ—¶å–ä¸‹ä¸€æ¯å’–å•¡ï¼Œæ•ˆæœå°†ä¼šæŒç»­ C ç§’ã€‚åœ¨å’–å•¡çš„æŒç»­æ—¶é—´é‡Œï¼Œä½ ä¸èƒ½å†å– å¦ä¸€æ¯å’–å•¡ï¼ŒåŒæ—¶ä½ çš„ä½“åŠ›ä¹Ÿå°†è¢«å›ºå®šåœ¨å¼€å§‹å–å’–å•¡æ—¶çš„çŠ¶æ€ã€‚åœ¨æ•ˆæœç»“æŸåï¼Œä½ çš„ä½“åŠ›å°†ç«‹åˆ»å‡å°‘ C + 1ï¼Œä¹Ÿå³å’–å•¡ä¼šè®©ä½ é¢å¤–æ„Ÿåˆ° 1 ç‚¹ä½“åŠ›çš„ç–²åŠ³ã€‚ ä½ çš„ç›®æ ‡æ˜¯åœ¨ä½ ç¡ç€å‰çˆ†å‘å‡ºç”Ÿäº§åŠ›ã€‚å¯¹äºç»™å®šçš„ S å’Œ Cï¼Œä½ éœ€è¦ç»™å‡ºä¸€ä¸ªæœ€ä¼˜çš„å®‰æ’ï¼Œä½¿æ€»çš„å®Œæˆåº¦ æœ€å¤§åŒ–ã€‚

**é¢˜ç›®åˆ†æ**

å‡è®¾åœ¨ç²¾åŠ›ä¸ºuçš„æ—¶å€™å–å’–å•¡ï¼Œé‚£ä¹ˆå…¶åœ¨$t$åˆ°$t+c$çš„æ—¶é—´ç²¾åŠ›éƒ½ä¿æŒuï¼Œ$t+1+c$çš„æ—¶é—´åé›†ä½“ä¸‹é™1ï¼Œé‚£ä¹ˆè¿™ä¸ªå’–å•¡å¯¹æ•´ä½“çš„è´¡çŒ®å€¼ä¸º$\frac{c(c-1)}{2}-(u-c)$æ‰€ä»¥å½“$u-v\ge \frac{c(c-1)}{2}$æ—¶å–å’–å•¡å¯ä»¥äº§ç”Ÿè´¡çŒ®ã€‚è´ªå¿ƒå¯å¾—ï¼Œå‡è®¾å…¶åœ¨$t$å–å®Œå’–å•¡ä¹‹åè‚¯å®šæ˜¯æ¥ç€ä¸€ç›´å–å’–å•¡ã€‚é‚£ä¹ˆå…¶å¯ä»¥è¢«åˆ’åˆ†ä¸ºè‹¥å¹²æ®µï¼Œä¸”æœ€åä¸€æ¬¡å–å’–å•¡æ—¶çš„ä½“åŠ›å¤„äº$x\in[0-c]$ã€‚è¿™äº›å€¼å¯ä»¥å¯¹åº”å‡ºæ¥ä¸€ä¸ªæœ€å¤§çš„$u$ä½¿å¾—$u = k(c+1)+x$ï¼Œè€Œä¸”è¿™ä¸ªuæ»¡è¶³ä¸Šé¢çš„æŸ¿å­ã€‚ç„¶åå¯ä»¥å‘ç°kæ˜¯å…³äºxçš„ä¸€ä¸ªåˆ†æ®µå‡½æ•°ï¼Œå½“å…¶ä¸ºxæ—¶å¯¹ç­”æ¡ˆçš„è´¡çŒ®æ˜¯$\frac{(x+k(c+1)+x)*(k+1)}{2}-\frac{(x+k(c+1)+1)*(x+k(c+1))}{2}$.ç„¶åé€šè¿‡åˆ¤æ–­é¸¡æ±ç‚¹è¿›è¡Œ$O(1)$è®¡ç®—æˆ–è€…è¿›è¡Œä¸‰åˆ†ã€‚

**ä»£ç **

```c++
#include <vector>
#include <algorithm>
#include <iostream>
#include <array>

using ll = long long;

void sol() {
	ll s, c;
	std::cin >> s >> c;
	auto cacal = [&](ll x) {
		if (x > s)return 0ll;
		ll rem = x % (c + 1);
		ll len = x / (c + 1) + 1;
		return (x + rem) * len / 2 * c - x * (x + 1) / 2;
	};
	std::cout << 1ll * s * (s + 1) / 2 + std::max({cacal(s), cacal(c / 2 * c), cacal(s / c * c)}) << '\n';
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int t;
	std::cin >> t;
	while (t--) {
		sol();
	}

	return 0;
}
```



## 2.[HAOI2008]ç³–æœä¼ é€’

**é¢˜ç›®æè¿°**

æœ‰ $n$ ä¸ªå°æœ‹å‹åæˆä¸€åœˆï¼Œæ¯äººæœ‰ $a_i$ ä¸ªç³–æœã€‚æ¯äººåªèƒ½ç»™å·¦å³ä¸¤äººä¼ é€’ç³–æœã€‚æ¯äººæ¯æ¬¡ä¼ é€’ä¸€ä¸ªç³–æœä»£ä»·ä¸º $1$ã€‚

**è¾“å…¥æ ¼å¼**

å°æœ‹å‹ä¸ªæ•° $n$ï¼Œä¸‹é¢ $n$ è¡Œ $a_i$ã€‚

å¯¹äº $100\%$ çš„æ•°æ® $n\le 10^6$ã€‚

**è¾“å‡ºæ ¼å¼**

æ±‚ä½¿æ‰€æœ‰äººè·å¾—å‡ç­‰ç³–æœçš„æœ€å°ä»£ä»·ã€‚

**é¢˜ç›®åˆ†æ**

æœ€ç»ˆæ‰€æœ‰å°æœ‹å‹çš„ç³–æœæ•°é‡éƒ½æ˜¯å¹³å‡æ•°ï¼Œé‚£ä¹ˆå‡è®¾$x_i$ä¸º$i$å·å°æœ‹å‹ç»™$i-1$å·å°æœ‹å‹ç³–æœçš„ä¸ªæ•°ï¼Œæ­£è¡¨ç¤ºç»™å‡ºï¼Œè´Ÿä»£è¡¨è¢«ç»™ã€‚é‚£ä¹ˆå¯¹äºæ¯ä¸€ä¸ªå°æœ‹å‹ï¼Œå¯ä»¥åˆ—å‡ºæ–¹ç¨‹ï¼š
$$
a_i-x_i+x_{i+1}=ave\\
x_{i+1} = x_i+ave-a_i
$$
å¸¦å…¥æ¯ä¸€ä¸ªiå¯ä»¥å¾—åˆ°ï¼š
$$
\left\{\begin{array}{c}


â€ƒâ€ƒâ€ƒ x_2 = x_1+ave-a_1 \\

â€ƒâ€ƒâ€ƒ x_3 = x_2+ave-a_2 \\
		 	...\\
â€ƒâ€ƒâ€ƒ x_n = x_{n-1}+ave-a_n


\end{array}\right.
$$

æ¶ˆå…ƒå¯å¾—ï¼š
$$
\left\{\begin{array}{c}


â€ƒâ€ƒâ€ƒ x_2 = x_1+ave-a_1 \\

â€ƒâ€ƒâ€ƒ x_3 = x_1+2*ave-a_1-a_2 \\
		 	...\\
â€ƒâ€ƒâ€ƒ x_n = x_1+(n-1)*ave-\sum\limits_{i=1}^{n-1}a_i


\end{array}\right.
$$
é¢˜ç›®è¦æ±‚çš„ç­”æ¡ˆä¸º$\sum\limits_{i=1}^{n}\abs{x_i}$é‚£ä¹ˆå°±è½¬åŒ–ä¸ºäº†$\sum\limits_{i=1}^n\abs{x_1+(i-1)*ave-\sum\limits_{j=1}^ia_j}$é‚£ä¹ˆé—®é¢˜å°±è½¬åŒ–ä¸ºäº†åœ¨æ•°è½´$x_1$åˆ°$i*ave-\sum\limits_{j=1}^ia_j$è¿™äº›ç‚¹çš„è·ç¦»ä¹‹å’Œï¼Œæ ¹æ®åˆä¸­æ•°å­¦å°±èƒ½å¾—çŸ¥$x_1$ä¸º$i*ave-\sum\limits_{j=1}^ia_j$çš„ä¸­ä½æ•°æ—¶ç­”æ¡ˆæœ€å°ï¼Œç„¶åå°±åšå®Œå•¦ã€‚

### ä»£ç 

```c++
//
// Created by mrx on 2022/9/14.
//
#include <bits/stdc++.h>

using ll = long long;

int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int n;
    while (std::cin >> n) {
        std::vector<ll> c(n);
        for (int i = 0; i < n; ++i) {
            std::cin >> c[i];
            if (i) c[i] += c[i - 1];
        }
        ll ave = c[n - 1] / n;
        for (int i = 0; i < n; ++i) {
            c[i] = (i + 1) * ave - c[i];
        }

        std::nth_element(c.begin(), c.begin() + n / 2, c.end());
        ll x1 = c[n / 2];
        ll ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += std::abs(c[i] - x1);
        }
        std::cout << ans << '\n';
    }
    return 0;
}
```



## 3.CCPC 2021 guangzhou F

An undirected connected graph is called a cactus, if and only if each edge of it belongs to at most one simple cycle. A simple cycle is a cycle that has no repeated vertices.

Now suppose there are ğ‘“ğ‘›fn cactuses of ğ‘›n distinct vertices, and the cactuses may have parallel edges and must not have self-loops, you need to calculate$\sum\limits_{i=1}^{n}\prod_{i != j }\frac{1 + f_i -f_i*f_j}{f_i - f_j}$.

The sum of a zero-length sequence is 00, and the product of a zero-length sequence is $1$.

**é¢˜æ„**

è®¾ä¸€é¢—æœ‰$n$ä¸ªç‚¹çš„ä»™äººæŒæœ‰$f_n$ç§ï¼Œæ±‚ä¸Šé¢çš„æŸ¿å­ã€‚

**é¢˜è§£**

è§‚å¯Ÿæ‹‰æ ¼æœ—æ—¥æ’å€¼çš„å…¬å¼ï¼š$f_n(x) = \sum\limits_{i=1}^{n} y_i(\prod _{i!=j}\frac{x - x_j}{x_i-x_j})$

å‘ç°ä¸Šé¢çš„æŸ¿å­å’Œæ‹‰æ ¼æœ—æ—¥æ’å€¼è´¼åƒã€‚

é˜¿å·´é˜¿å·´ä¸ä¼šã€‚

ä½†æ˜¯å‘ç°åªè¦åºåˆ—é•¿åº¦ç›¸åŒå¸¦è¿›å»ç®—å‡ºæ¥æ— è®ºå–ä»€ä¹ˆå€¼ç®—å‡ºæ¥éƒ½ä¸€æ ·çš„ã€‚

ç„¶åçœ‹ä¸Šå»å°±åƒæ–æ³¢é‚£å¥‘æ•°å’§ã€‚

## 4.[Tree Constructer](https://ac.nowcoder.com/acm/contest/52185/J)

**é¢˜æ„**

nä¸ªç‚¹çš„æ ‘ï¼Œæ¯ä¸ªç‚¹åˆ†é…$[0,1<<60)$çš„ç‚¹æƒï¼Œå¦‚æœuä¸vçš„ç‚¹æƒè¿›è¡ŒæŒ‰ä½æˆ–ä¹‹åç­‰äº$2^{60}-1$é‚£ä¹ˆæœ‰è¾¹ï¼Œå¦åˆ™æ²¡è¾¹ã€‚æ±‚åˆæ³•çš„ç‚¹æƒåºåˆ—æ„é€ å‡ºç»™å®šçš„æ ‘ã€‚

**åˆ†æ**

é»‘ç™½æŸ“è‰²ä¹‹åæ„é€ åˆ†ç±»æ–¹å¼

è¯»é¢˜ä¹‹åå‘ç°ï¼Œå¦‚æœæœ‰æŸä¸€ä½ä¸¤ä¸ªç‚¹éƒ½æ˜¯0é‚£ä¹ˆè¿™ä¸¤ä¸ªç‚¹å¿…å®šæ²¡æœ‰è¾¹ï¼Œé€šè¿‡è¿™ä¸ªæ€§è´¨ï¼Œå¯¹è¿™ä¸ªæ ‘è¿›è¡Œé»‘ç™½æŸ“è‰²ã€‚
é»‘ç™½æŸ“è‰²ä¹‹åï¼ŒåŒè‰²ç‚¹ä¹‹é—´å¿…å®šæ²¡æœ‰è¾¹ï¼Œé‚£ä¹ˆä½¿ç”¨ä¸¤ä½äºŒè¿›åˆ¶å°±å¯ä»¥æŠŠåŒè‰²ç‚¹å…¨éƒ¨åˆ†å¼€ã€‚ç„¶åè¿˜å‰©ä¸‹ä¸€äº›è¾¹ä¸ºä¸ç›¸é‚»çš„é»‘ç™½ç‚¹ä¹‹é—´çš„è¾¹ï¼Œå› ä¸ºé»‘è‰²ç‚¹å’Œç™½è‰²ç‚¹æ€»å’Œä¸ºnï¼Œé‚£ä¹ˆå¿…å®šæœ‰ä¸€ç§é¢œè‰²çš„ç‚¹çš„ä¸ªæ•°$\le \frac{1}{2}$å¯¹äºç‚¹æ•°è¾ƒå°çš„é›†åˆï¼ŒæŒ‰ç…§æ ‡å·ä¾æ¬¡åˆ†é…äºŒè¿›åˆ¶ä½ä¸º0ã€‚å¯¹äºå¦ä¸€ä¸ªé¢œè‰²çš„é›†åˆï¼Œå…¶åœ¨åˆ†é…çš„äºŒè¿›åˆ¶ä½ä¸­åªæœ‰ä¸å…¶ç›¸é‚»çš„å¼‚è‰²ç‚¹å¯¹åº”ç¼–å·çš„äºŒè¿›åˆ¶ä½ä½1ï¼Œå…¶ä»–å‡ä¸º0ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2023/2/27.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

using i64 = long long;

void solve() {
    int n;

    std::cin >> n;
    std::vector adj(n, std::vector<int>());
    for (int i = 1; i < n; ++i) {
        int u, v;
        std::cin >> u >> v;
        u--, v--;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }

    std::vector<std::vector<int>> cl(2);
    std::vector<int> color(n);
    std::function<void(int, int, int)> dfs = [&](int u, int p, int c) {
        cl[c].emplace_back(u);
        color[u] = c;
        for (auto x: adj[u]) {
            if (x == p)continue;
            dfs(x, u, c ^ 1);
        }
    };
    dfs(0, 0, 0);
    if (cl[0].size() > cl[1].size())std::swap(cl[0], cl[1]);
    std::vector<i64> ans(n, (1ll << 60) - (1ll << cl[0].size()));
    std::vector<int> pos(n, -1);
    for (int i = 0; i < cl[0].size(); ++i)pos[cl[0][i]] = i;
    for (auto x: cl[0])ans[x] ^= 1ll << 59, ans[x] ^= ((1ll << cl[0].size()) - 1) ^ 1ll << pos[x];
    for (auto x: cl[1])ans[x] ^= 1ll << 58;
    for (auto x: cl[1])for (auto v: adj[x])ans[x] ^= 1ll << pos[v];

//    for (int i = 0; i < n; ++i) {
//        for (int j = i + 1; j < n; ++j) {
//            if ((ans[i] | ans[j]) == (1ll << 60) - 1)std::cout << i + 1 << ' ' << j + 1 << '\n';
//        }
//    }
    for (auto x: ans)std::cout << x << ' ';
}


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    solve();
    return 0;
}
```

## 5.CFGYM104017B Drone Photo

**é¢˜æ„**

ç»™ä¸€ä¸ªn*nçŸ©é˜µï¼Œç”±ä¸€ä¸ªæ’åˆ—æ„æˆï¼Œå–å››ä¸ªç‚¹æ„æˆä¸€ä¸ªé•¿æ–¹å½¢ï¼Œä½¿å¾—æœ€å°çš„ä¸¤ä¸ªç‚¹ä¸åœ¨å¯¹è§’çº¿ä¸Šã€‚

**é¢˜è§£**

è§‚å¯Ÿå‡ºæ¥å¯å¾—ä¸€ä¸ªåˆæ³•çš„çŸ©å½¢è‚¯å®šæœ‰ä¸¤ä¸ªé¡ºæ—¶é’ˆ/é€†æ—¶é’ˆé€’å¢çš„Lå½¢çŠ¶åºåˆ—ï¼Œé‚£ä¹ˆç»Ÿè®¡è¿™ç§åºåˆ—çš„ä¸ªæ•°ç„¶åé™¤2æ—¢æ˜¯ç­”æ¡ˆã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2023/4/9.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

using i64 = long long;

void solve() {
    int n;
    std::cin >> n;
    std::vector mat(n, std::vector<int>(n));
    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j)std::cin >> mat[i][j];
    std::vector order_x(n, std::vector<int>(n)), order_y(n, std::vector<int>(n));
    for (int i = 0; i < n; ++i) {
        std::vector<int> tmp(n);
        std::iota(tmp.begin(), tmp.end(), 0);
        std::sort(tmp.begin(), tmp.end(), [&](int a, int b) { return mat[i][a] < mat[i][b]; });
        for (int j = 0; j < n; ++j) order_x[i][tmp[j]] = n - 1 - j;
        std::sort(tmp.begin(), tmp.end(), [&](int a, int b) { return mat[a][i] < mat[b][i]; });
        for (int j = 0; j < n; ++j) order_y[tmp[j]][i] = n - 1 - j;
    }
    
    i64 ans = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            ans += order_x[i][j] * (n - 1 - order_y[i][j]) + order_y[i][j] * (n - 1 - order_x[i][j]);
        }
    }
    std::cout << ans / 2 << '\n';
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
    solve();
    
    return 0;
}
```





# dp

## æ•°ä½dp

### 1.[2020 ICPC Shanghai Site](https://codeforces.com/gym/102900)

Given two non-negative integers $X$ and $Y$, determine the value of 
$$ \sum_{i=0}^{X}\sum_{j=[i=0]}^{Y}[i\&j=0]\lfloor\log_2(i+j)+1\rfloor $$
modulo $10^9+7$ where
$\&$ denotes bitwise AND;
$[A]$ equals 1 if $A$ is true, otherwise $0$;
$\lfloor x\rfloor$ equals the maximum integer whose value is no more than $x$.
The first line contains one integer $T\,(1\le T \le 10^5)$ denoting the number of test cases.

Each of the following $T$ lines contains two integers $X, Y\,(0\le X,Y \le 10^9)$ indicating a test case.

é¢˜æ„åŒ–ç®€ä¹‹åä¼šå‘ç°è¿™æ˜¯ä¸€ä¸ªiå’Œjå‡æœ‰é™åˆ¶çš„æ•°ä½dpï¼Œå…ˆé’¦å®ši>jç„¶åè¿›è¡Œæ•°ä½dpï¼Œå†é’¦å®šj>iå†æ•°ä½dpç„¶åæŠŠå®ƒä»¬åŠ èµ·æ¥å°±è¡Œ

trick:å¦‚æœæœ‰ä¸¤ä¸ªæ•°å­—æœ‰é™åˆ¶ï¼Œè¦åŠ å…¥æ›´å¤šçš„çŠ¶æ€ã€‚

```c++
//
// Created by mrx on 2022/11/18.
//
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <array>
#include <functional>
#include <numeric>
#include <cmath>
#include <iomanip>

using i64 = long long;

const long long mod = 1e9 + 7;

void sol() {
	int n, m;
	std::cin >> n >> m;

	std::vector<int> X(33), Y(33);
	int lena = 0;
	int lenb = 0;
	while (n) {
		lena++;
		X[lena] = n % 2;
		n = n >> 1;
	}
	while (m) {
		lenb++;
		Y[lenb] = m % 2;
		m = m >> 1;
	}
	std::vector<std::vector<std::vector<int>>> dp(X.size() + 1, std::vector<std::vector<int>>(2, std::vector<int>(2, -1)));
	std::vector<std::array<std::array<int, 2>, 2>> vis(X.size() + 1);
	std::function<int(int, int, int)> dfs = [&](int pos, int la, int lb) {
		if (vis[pos][la][lb])return dp[pos][la][lb];
		if (pos == 0)return 1;
		int xa = 0, xb = 0;
		xa = la ? X[pos] : 1;
		xb = lb ? Y[pos] : 1;
		int ret = 0;
		for (int i = 0; i <= xa; ++i) {
			for (int j = 0; j <= xb; ++j) {
				if (i & j)continue;
				ret += dfs(pos - 1, la && (i == xa), lb && (j == xb));
				ret %= mod;
			}
		}
		vis[pos][la][lb] = 1;
		dp[pos][la][lb] = ret % mod;
		return dp[pos][la][lb];
	};
	i64 ans = 0;
	for (int i = 1; i <= lena; i++) {
		ans = (ans + 1ll * dfs(i - 1, i == lena, i > lenb) * i % mod) % mod;
	}
	for (int i = 1; i <= lenb; i++) {
		ans = (ans + 1ll * dfs(i - 1, i > lena, i == lenb) * i % mod) % mod;
	}
	std::cout << ans << '\n';
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	int t;
	std::cin >> t;
	while (t--) {
		sol();
	}

	return 0;
}

```

### 2.[The 2022 ICPC Asia Xian Regional Contest](https://codeforces.com/gym/104077)E

é¢˜é¢æš‚æ—¶ç•¥ï¼Œå¤§æ„æ˜¯æ±‚lå’Œrä¹‹é—´ä¸‰è¿›åˆ¶ä¸‹popcountçš„å¤§å°

ä»£ç 

ä¹Ÿç”¨åˆ°äº†ä¸¤ä¸ªæ•°å­—ä¹‹é—´é™åˆ¶çš„tirck

```c++
#include <bits/stdc++.h>

using i64 = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);


	int t;
	std::cin >> t;
	while (t--) {
		i64 l, r;
		std::cin >> l >> r;
		auto getstr = [&](i64 x) {
			std::vector<int> ret;
			do {
				ret.emplace_back(x % 3);
				x /= 3;
			} while (x);
//			std::reverse(ret.begin(), ret.end());
			return ret;
		};
		auto a = getstr(l), b = getstr(r);
		int n = b.size();
		if (a.size() != b.size())a.resize(b.size());
		std::reverse(a.begin(), a.end());
		std::reverse(b.begin(), b.end());
		std::vector dp(n, std::array<int, 8>{-1, -1, -1, -1, -1, -1, -1, -1});
		std::function<int(int, int)> dfs = [&](int pos, int stat) {
			int qd0 = stat >> 2 & 1;
			int limita = stat >> 1 & 1;
			int limitb = stat & 1;
			if (pos == n) {
				return qd0;
			}
			if (dp[pos][stat] != -1)return dp[pos][stat];
			int l = limita ? a[pos] : 0;
			int r = limitb ? b[pos] : 2;
			int ans = 0;
			for (int i = l; i <= r; ++i) {
				int nxt = 0;
				nxt |= (qd0 && i == 0) << 2;
				nxt |= (limita && i == l) << 1;
				nxt |= (limitb && i == r);
				ans = std::max(ans, (!(qd0 && i == 0)) + i + dfs(pos + 1, nxt));
			}
			return dp[pos][stat] = ans;
		};
		std::cout << dfs(0, 7) << '\n';
	}

	return 0;
}
```

### 3.[ Bit Sequence](https://ac.nowcoder.com/acm/contest/52185/L)

**é¢˜ç›®å¤§æ„**

ä»¤f(x)= __builtin_parity(x)æ±‚åœ¨$[0,L]$çš„èŒƒå›´ä¸­æ»¡è¶³$f(x),f(x+1),â€¦,f(x+n-1)$ä¸ç»™å®šæ•°ç»„aç›¸åŒçš„xçš„ä¸ªæ•°

**åˆ†æ**

ä¸€å¼€å§‹å¾ˆå®¹æ˜“æƒ³åˆ°è¿™ä¸ªåºåˆ—çš„æ€§è´¨å»ï¼Œç„¶åå‘ç°nåªæœ‰100ï¼Œé‚£ä¹ˆ$x+n$å¦‚æœä¸åœ¨ç¬¬7ä½äºŒè¿›åˆ¶ä½äº§ç”Ÿé«˜ä½è¿›ä½åˆ™ä¸ä¼šå¯¹æ›´é«˜ä½äº§ç”Ÿå½±å“ï¼Œç›´æ¥æš´åŠ›è®¡ç®—å³å¯ï¼Œå¦‚æœäº§ç”Ÿè¿›ä½çš„è¯ï¼Œé‚£åœ¨ç¬¬7ä½å‰é¢è¿ç»­çš„1çš„ä¸ªæ•°ä¹Ÿä¼šå¯¹ç­”æ¡ˆäº§ç”Ÿå½±å“ï¼ŒæŒ‰ç…§è¿™ä¸ªè¿›è¡Œæ•°ä½dpå³å¯ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2023/2/27.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

using i64 = long long;
std::array<int, 277> f;

void solve() {
    int m;
    i64 L;
    std::cin >> m >> L;
    std::vector<int> a(m);
    for (int i = 0; i < m; ++i)std::cin >> a[i];
    std::vector<int> bits;
    i64 x = L;
    do {
        bits.push_back(x & 1);
        x >>= 1;
    } while (x);
    std::vector dp(bits.size(), std::vector<i64>(8, -1));//pos,status

    auto cacal = [&](int status) -> i64 {
        int lmt = status & 1;
        int cnt1 = (status >> 2) & 1;
        int cnt2 = (status >> 1) & 1;
        i64 hi = lmt ? L % 128 : 127;
        i64 res = 0;
        for (int i = 0; i <= hi; ++i) {
            int ok = 1;
            for (int j = 0; j < m && ok; ++j) {
                if (i + j < 128) ok &= (f[i + j] ^ cnt1) == a[j];
                else ok &= (f[i + j] ^ cnt1 ^ cnt2) == a[j];
            }
            res += ok;
        }
        return res;
    };
    std::function<i64(int, int)> dfs = [&](int pos, int status) -> i64 {
        auto& res = dp[pos][status];
        if (res != -1)return res;
        else if (pos <= 6)return res = cacal(status);
        res = 0;
        int cnt1 = (status >> 2) & 1, cnt2 = (status >> 1) & 1, lmt = status & 1;
        int up = lmt ? bits[pos] : 1;
        for (int i = 0; i <= up; ++i) {
            int nxl = lmt & (i == up), nxc1 = cnt1 ^ i, nxc2 = (!cnt2) & i;
            res += dfs(pos - 1, (nxl) | (nxc1 << 2) | (nxc2 << 1));
        }
        return res;
    };
    std::cout << dfs((int(bits.size())) - 1, 1) << '\n';
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int t;
    std::cin >> t;
    for (int i = 0; i < 277; ++i)f[i] = __builtin_parity(i);
    while (t--) {
        solve();
    }
    return 0;
}
```



## æ™®é€šdp






### 1.ç‰›ç‰›å¤šæ ¡7-J

Grammy has a favorite number kkk. She thinks that all the numbers divisible by kkk are good. 

 For each array containing only numbers from 000 to kâˆ’1k-1kâˆ’1, Grammy define its goodness as the number of non-empty consecutive subarrays that sums to a good number. 

 Please count the number of arrays of length nnn such that its goodness is ttt. Since the answer can be enormous, output the answer modulo 998244353
A single line contains three integers n,k,tn,k,tn,k,t (1â‰¤n,kâ‰¤64,0â‰¤tâ‰¤n(n+1)

Output a single number, denoting the answer modulo 998244353.

**é¢˜ç›®åˆ†æ**

å¼€å§‹çš„æ—¶å€™è‹¦æ€å†¥æƒ³æƒ³ä¸å‡ºæ¥ï¼Œç„¶åçŠ¶æ€è®¾è®¡è½¬å˜ï¼ŒæŠŠåŸæ•°ç»„æ”¹ä¸ºå‰ç¼€å’Œæ•°ç»„ï¼Œå¯ä»¥å¾—çŸ¥å…¶ä¸ºä¸€ä¸€å¯¹åº”çš„ï¼Œç„¶åè®¾è®¡çŠ¶æ€iä¸ºå¡«å‰iä¸ªæ•°å­—ï¼Œjä¸ºå¡«äº†jä¸ªä½ç½®ï¼Œkä¸ºgoodnessã€‚è€ƒè™‘çŠ¶æ€è½¬ç§»ï¼Œå¯¹äºç¬¬iä¸ªæ•°å­—ï¼Œå·²ç»å¡«äº†jä¸ªä½ç½®ï¼Œå°†è¦å¡«lenä¸ªï¼Œé‚£ä¹ˆ$dp[i][j+len][k+(len)*(len-1)/2]+=dp[i-1][j][k]*C_{len+j}^{len}$,ç„¶åç ä»£ç å³å¯ã€‚

```c++
//
// Created by mrx on 2022/8/8.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, int b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    int val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

constexpr int mod = 998244353;
using Z = Modular<mod>;

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int n, k, t;
    std::cin >> n >> k >> t;
    std::vector<std::vector<std::vector<Z>>> dp(k + 1, std::vector<std::vector<Z>>(n + 1, std::vector<Z>(t + 1)));
    std::vector<Z> fact(n + 1, 1), inv(n + 1, 1);
    for (int i = 1; i <= n; ++i) {
        fact[i] = fact[i - 1] * i;
        inv[i] = fact[i].inv();
    }

    auto C = [&](int y, int x) {
        return x < y ? 0 : fact[x] * inv[y] * inv[x - y];
    };

    for (int i = 0; i <= n; ++i) if (i * (i + 1) / 2 <= t)dp[0][i][i * (i + 1) / 2] = 1;

    for (int val = 1; val < k; ++val) {
        for (int len = 0; len <= n; ++len) {
            for (int cnt = 0; cnt <= t; ++cnt) {
                if (!dp[val - 1][len][cnt]) continue;
                for (int choose = 0; choose + len <= n && cnt + choose * (choose - 1) / 2 <= t; ++choose) {
                    dp[val][len + choose][cnt + choose * (choose - 1) / 2] += dp[val - 1][len][cnt] * C(choose, choose + len);
                }
            }
        }
    }

    std::cout << dp[k - 1][n][t] << '\n';
    return 0;
}
```

## åŒºé—´dp

### 1.UVA12991 Game Rooms

é¢˜æ„

ä¸€ä¸ª  $N$ å±‚çš„å¤§æ¥¼ï¼Œæ¯å±‚åªæœ‰ä¸€ä¸ªæ¸¸æˆå®¤ï¼Œå¯ä»¥è®¾ç½®ä¸€ä¸ªä¹’ä¹“çƒæ¡Œæˆ–æ¸¸æ³³æ± ã€‚ç¬¬  $i$ å±‚æœ‰  $T_i$ ä¸ªäººå–œæ¬¢ä¹’ä¹“çƒå’Œ  $P_i$ ä¸ªäººå–œæ¬¢æ¸¸æ³³ã€‚

ç°åœ¨è¦æ±‚ä½¿æ¯ä¸ªäººåˆ°æœ€è¿‘çš„å–œæ¬¢çš„ç±»å‹çš„æ´»åŠ¨å®¤çš„è·ç¦»çš„**å’Œ**æœ€å°ï¼Œä¸”è¿™æ ‹å¤§æ¥¼è¦æœ‰è‡³å°‘ä¸€ä¸ªä¹’ä¹“çƒæ¡Œå’Œè‡³å°‘ä¸€ä¸ªæ¸¸æ³³æ± ã€‚

è¿™é‡Œçš„è·ç¦»æŒ‡æ¥¼å±‚å·®çš„ç»å¯¹å€¼ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªäººåˆ°ä»–å–œæ¬¢çš„ç±»å‹çš„æ¸¸æˆå®¤ä½äºåŒä¸€æ¥¼å±‚ï¼Œåˆ™ä¸º  $0$ï¼›å¦‚æœæ‰€éœ€ç±»å‹çš„æœ€æ¥è¿‘çš„æ¸¸æˆå®¤æ­£å¥½åœ¨è¯¥å‘˜å·¥çš„ä¸Šæ–¹æˆ–ä¸‹æ–¹ä¸€å±‚ï¼Œåˆ™ä¸º  $1$ï¼Œä»¥æ­¤ç±»æ¨ã€‚

è¾“å…¥æ ¼å¼

ç¬¬ä¸€è¡Œç»™å‡ºæ•°æ®ç»„æ•°  $T$ï¼ˆ $1\leq T\leq 100$ï¼‰ã€‚æ¥ä¸‹æ¥å¯¹äºæ¯ç»„æ•°æ®ï¼Œé¦–å…ˆä¸€è¡Œç»™å‡º  $N$ï¼ˆ $2\leq N\leq 4000$ï¼‰ï¼Œä»£è¡¨è¯¥å¤§æ¥¼ä¸€å…±æœ‰å¤šå°‘å±‚ï¼›æ¥ä¸‹æ¥  $N$ è¡Œç¬¬  $i$ è¡Œç»™å‡ºä¸¤ä¸ªæ•´æ•°  $T_i, P_i$ï¼ˆ $1\leq T_i, P_i\leq 10^9$ï¼‰ï¼Œä»£è¡¨ç¬¬  $i$ å±‚çš„äººæ•°ï¼Œæ„ä¹‰åŒé¢˜æ„

é¢˜ç›®åˆ†æï¼šè€ƒè™‘ä¸€å±‚æ¥¼ï¼Œå¦‚æœå…¶å»ºé€ äº†æ¸¸æ³³æ± ï¼Œé‚£ä¹ˆè¯¥å±‚å±…æ°‘ä¸ç”¨åŠ¨ï¼Œä¸ç„¶è¦å¾€ä¸Šæ‰¾æ¸¸æ³³æ± æˆ–è€…å¾€ä¸‹æ‰¾æ¸¸æ³³æ± ï¼Œå‡å¦‚æœ‰è¿ç»­nå±‚éƒ½å»ºé€ çš„æ˜¯æ¸¸æ³³æ± ï¼Œé‚£ä¹ˆè¿™nå±‚æƒ³è¦æ‰“ä¹’ä¹“çƒçš„å±…æ°‘å°±è¦å¾€ä¸‹æˆ–è€…å¾€ä¸Šæ‰¾ä¹’ä¹“çƒæ¡Œå­ï¼Œè€ƒè™‘æ¯ä¸€ä¸ªå±…æ°‘ï¼Œä»–ä»¬æ‰¾çš„è‚¯å®šæ˜¯ç¦»ä»–ä»¬æœ€è¿‘çš„ï¼Œé‚£ä¹ˆè¿™nå±‚çš„å±…æ°‘å°±è¢«åˆ†ä¸ºäº†ä¸¤åŠï¼Œä¸€åŠä¸‹æ¥¼ä¸€åŠä¸Šæ¥¼ã€‚å®¹æ˜“æƒ³å‡ºæ¥ä¸€ç§çŠ¶æ€ï¼š$dp[i][0/1]$è¡¨ç¤ºç¬¬iå±‚å»ºé€ çš„æ˜¯æ¸¸æ³³æ± /ä¹’ä¹“çƒæ¡Œå­ï¼Œé‚£ä¹ˆæšä¸¾æœ‰è¿ç»­å‡ å±‚æ¸¸æ³³æ± /ä¹’ä¹“çƒæ¡Œå­ï¼Œå°±å¯ä»¥è¡¨ç¤ºæ‰€æœ‰çŠ¶æ€ã€‚å¯ä»¥å¾—åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š$dp[i][0]=dp[j][1]+cost(j+1,i,0),dp[i][1]=dp[j][0]+cost(j+1,i,1)(0\le j <i)$ç„¶åé€šè¿‡äºŒç»´å‰åç¼€å’Œä»¥åŠä¸€ç»´å‰åç¼€å’Œç®—å‡ºæ¥costã€‚

ä»£ç ï¼š

```c++
//
// Created by mrx on 2022/8/10.
//
#include <bits/stdc++.h>

using ll = long long;

void sol() {
    int n;
    std::cin >> n;
    std::vector<std::array<ll, 2>> building(n);
    for (int i = 0; i < n; ++i)std::cin >> building[i][0] >> building[i][1];
    std::vector<std::array<ll, 2>> prefix_sum2(n + 2), suffix_sum2(n + 2);
    std::vector<std::array<ll, 2>> prefix_sum1(n + 2), suffix_sum1(n + 2);

    for (int i = 1; i <= n; ++i) {
        prefix_sum1[i][0] = prefix_sum1[i - 1][0] + building[i - 1][0];
        prefix_sum1[i][1] = prefix_sum1[i - 1][1] + building[i - 1][1];
    }
    for (int i = 1; i <= n; ++i) {
        prefix_sum2[i][0] = prefix_sum2[i - 1][0] + prefix_sum1[i][0];
        prefix_sum2[i][1] = prefix_sum2[i - 1][1] + prefix_sum1[i][1];
    }

    for (int i = n; i > 0; --i) {
        suffix_sum1[i][0] = suffix_sum1[i + 1][0] + building[i - 1][0];
        suffix_sum1[i][1] = suffix_sum1[i + 1][1] + building[i - 1][1];
    }
    for (int i = n; i > 0; --i) {
        suffix_sum2[i][0] = suffix_sum1[i][0] + suffix_sum2[i + 1][0];
        suffix_sum2[i][1] = suffix_sum1[i][1] + suffix_sum2[i + 1][1];
    }

    std::vector<std::vector<ll>> dp(n + 1, std::vector<ll>(2, 0x3f3f3f3f3f3f3f3f));
    auto cacal = [&](int l, int r, int type) {
        return prefix_sum2[r][type] - prefix_sum2[l - 1][type] - (r - l + 1) * prefix_sum1[l - 1][type];
    };
    auto cacal2 = [&](int l, int r, int type) {
        return suffix_sum2[l][type] - suffix_sum2[r + 1][type] - (r - l + 1) * suffix_sum1[r + 1][type];
    };
    auto cost = [&](int l, int r, int type) -> ll {
        if (l == 1 && r == n) {
            return 0x3f3f3f3f3f3f3f3f;
        } else if (l == 1) {
            return cacal(l, r, type);
        } else if (r == n) {
            return cacal2(l, r, type);
        } else {
            int mid = (l + r) >> 1;
            ll ret = 0;
            ret += cacal(mid + 1, r, type);
            ret += cacal2(l, mid, type);
            return ret;
        }
    };

    dp[0][0] = dp[0][1] = 0;
    for (int i = 1; i <= n; ++i) {
        dp[i][0] = dp[i][1] = 0x3f3f3f3f3f3f3f3f;
        for (int j = 0; j < i; ++j) {
            dp[i][0] = std::min(dp[i][0], dp[j][1] + cost(j + 1, i, 0));
            dp[i][1] = std::min(dp[i][1], dp[j][0] + cost(j + 1, i, 1));
        }
    }

    std::cout << std::min(dp[n][0], dp[n][1]) << '\n';
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int t;
    std::cin >> t;
    for (int i = 1; i <= t; ++i) {
        std::cout << "Case #" << i << ": ";
        sol();
    }
    return 0;
}
```

### 2.UVA10891 Game of Sum

**é¢˜ç›®æè¿°**

æœ‰ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•´æ•°åºåˆ—ï¼Œä¸¤ä¸ªæ¸¸æˆè€… $A$ å’Œ $B$ è½®æµå–æ•°ï¼Œ$A$ å…ˆå–ã€‚æ¯æ¬¡ç©å®¶åªèƒ½ä»å·¦ç«¯æˆ–è€…å³ç«¯å–ä»»æ„æ•°é‡çš„æ•°ï¼Œä½†ä¸èƒ½ä¸¤è¾¹éƒ½å–ã€‚æ‰€æœ‰æ•°éƒ½è¢«å–èµ°è§†ä¸ºæ¸¸æˆç»“æŸï¼Œç„¶åç»Ÿè®¡æ¯ä¸ªäººå–èµ°çš„æ•°ä¹‹å’Œï¼Œä½œä¸ºå„è‡ªçš„å¾—åˆ†ã€‚ä¸¤ä¸ªäººé‡‡å–çš„ç­–ç•¥éƒ½æ˜¯è®©è‡ªå·±å¾—åˆ†å°½å¯èƒ½é«˜ï¼Œå¹¶ä¸”ä¸¤ä¸ªäººéƒ½å¾ˆæœºæ™ºï¼Œæ±‚ $A$ å¾—åˆ† - $B$ å¾—åˆ†åçš„ç»“æœã€‚

è¾“å…¥æ ¼å¼

è¾“å…¥åŒ…å«å¤šç»„æ•°æ®ï¼Œæ¯ç»„æ•°æ®ç¬¬ä¸€è¡Œä¸ºæ­£æ•´æ•° $n(1\leq n\leq 100)$ ï¼Œç¬¬äºŒè¡Œä¸ºç»™å®šçš„æ•´æ•°åºåˆ—ï¼Œè¾“å…¥ç»“æŸæ ‡å¿—æ˜¯ $n=0$ ã€‚

è¾“å‡ºæ ¼å¼

å¯¹äºæ¯ç»„æ•°æ®ï¼Œè¾“å‡º $A$ å’Œ $B$ éƒ½é‡‡å–æœ€ä¼˜ç­–ç•¥ä¸‹ï¼Œ$A$ çš„å¾—åˆ†$-B$ çš„å¾—åˆ†ã€‚

**é¢˜ç›®åˆ†æ**

å› ä¸ºå–æ•°å­—çš„æ“ä½œåªèƒ½åœ¨å¤´å’Œå°¾è¿›è¡Œï¼Œé‚£ä¹ˆå…¶åœ¨ä»»æ„æ—¶å€™éƒ½æ˜¯ä¸€ä¸ªè¿ç»­çš„åºåˆ—ï¼Œè®°$dp[l][r]$ä¸ºå…ˆæ‰‹åœ¨$l,r$è¿™ä¸ªå­åºåˆ—ä¸­è·å¾—çš„æœ€å¤§åˆ†æ•°ï¼Œé‚£ä¹ˆå¾ˆå®¹æ˜“æƒ³åˆ°$n^3$æš´åŠ›åŒºé—´dpï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸º$dp[l][r]=sum[l][r]-min(dp[l][l+1],dp[l][l+2]....dp[l][r],dp[r][r],dp[r-1][r],dp[r-2][r]...dp[l][r])$ç­”æ¡ˆä¸º$dp[1][n]+(sum[n]-dp[1][n])$ï¼Œè€ƒè™‘å¦‚ä½•å†™$n^2$ï¼Œè§‚å¯Ÿåˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸­æœ‰ä¸¤å¨ä¸œè¥¿ï¼Œè¿™å¨ä¸œè¥¿å¯ä»¥åœ¨çŠ¶æ€è½¬ç§»çš„æ—¶å€™è®°å½•åœ¨å¦ä¸€ä¸ªæ•°ç»„é‡Œï¼Œç„¶åå°±å®Œæˆäº†ä¼˜åŒ–ï¼Œç›´æ¥å˜æˆ$O(n^2)$

**ä»£ç **

```c++
//
// Created by mrx on 2022/9/24.
//
#include <iostream>
#include <algorithm>
#include <vector>
#include <array>

using ll = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n;
	while (std::cin >> n && n) {
		std::vector<int> a(n + 1);
		for (int i = 1; i <= n; ++i)std::cin >> a[i];
		std::vector<int> sum(n + 1);
		for (int i = 1; i <= n; ++i)sum[i] = sum[i - 1] + a[i];
		std::vector<std::vector<int>> dp(n + 1, std::vector<int>(n + 1, 0));
		std::vector<int> lmin(n + 1, 0x3f3f3f3f), rmin(n + 1, 0x3f3f3f3f);

		for (int len = 1; len <= n; ++len) {
			for (int l = 1; l + len - 1 <= n; ++l) {
				int r = l + len - 1;
				dp[l][r] = sum[r] - sum[l - 1] - std::min({0, lmin[l], rmin[r]});
				lmin[l] = std::min(lmin[l], dp[l][r]);
				rmin[r] = std::min(rmin[r], dp[l][r]);
			}
		}
		std::cout << 2 * dp[1][n] - sum[n] << '\n';
	}
	return 0;
}
```



## æ ‘å½¢dp

### 1.P1270â€œè®¿é—®â€ç¾æœ¯é¦†



**é¢˜ç›®æè¿°**

ç»è¿‡æ•°æœˆçš„ç²¾å¿ƒå‡†å¤‡ï¼ŒPeer Brelstetï¼Œä¸€ä¸ªå‡ºäº†åçš„ç›—ç”»è€…ï¼Œå‡†å¤‡å¼€å§‹ä»–çš„ä¸‹ä¸€ä¸ªè¡ŒåŠ¨ã€‚è‰ºæœ¯é¦†çš„ç»“æ„ï¼Œæ¯æ¡èµ°å»Šè¦ä¹ˆåˆ†å‰ä¸ºä¸¤æ¡èµ°å»Šï¼Œè¦ä¹ˆé€šå‘ä¸€ä¸ªå±•è§ˆå®¤ã€‚PeerçŸ¥é“æ¯ä¸ªå±•å®¤é‡Œè—ç”»çš„æ•°é‡ï¼Œå¹¶ä¸”ä»–ç²¾ç¡®æµ‹é‡äº†é€šè¿‡æ¯æ¡èµ°å»Šçš„æ—¶é—´ã€‚ç”±äºç»éªŒè€åˆ°ï¼Œä»–æ‹¿ä¸‹ä¸€å¹…ç”»éœ€è¦5ç§’çš„æ—¶é—´ã€‚ä½ çš„ä»»åŠ¡æ˜¯ç¼–ä¸€ä¸ªç¨‹åºï¼Œè®¡ç®—åœ¨è­¦å¯Ÿèµ¶æ¥ä¹‹å‰ï¼Œä»–æœ€å¤šèƒ½å·åˆ°å¤šå°‘å¹…ç”»ã€‚

![](https://cdn.luogu.com.cn/upload/pic/85.png)

**è¾“å…¥æ ¼å¼**

ç¬¬1è¡Œæ˜¯è­¦å¯Ÿèµ¶åˆ°çš„æ—¶é—´ï¼Œä»¥sä¸ºå•ä½ã€‚ç¬¬2è¡Œæè¿°äº†è‰ºæœ¯é¦†çš„ç»“æ„ï¼Œæ˜¯ä¸€ä¸²éè´Ÿæ•´æ•°ï¼Œæˆå¯¹åœ°å‡ºç°ï¼šæ¯ä¸€å¯¹çš„ç¬¬ä¸€ä¸ªæ•°æ˜¯èµ°è¿‡ä¸€æ¡èµ°å»Šçš„æ—¶é—´ï¼Œç¬¬2ä¸ªæ•°æ˜¯å®ƒæœ«ç«¯çš„è—ç”»æ•°é‡ï¼›å¦‚æœç¬¬2ä¸ªæ•°æ˜¯0ï¼Œé‚£ä¹ˆè¯´æ˜è¿™æ¡èµ°å»Šåˆ†å‰ä¸ºä¸¤æ¡å¦å¤–çš„èµ°å»Šã€‚æ•°æ®æŒ‰ç…§æ·±åº¦ä¼˜å…ˆçš„æ¬¡åºç»™å‡ºï¼Œè¯·çœ‹æ ·ä¾‹ã€‚

ä¸€ä¸ªå±•å®¤æœ€å¤šæœ‰20å¹…ç”»ã€‚é€šè¿‡æ¯ä¸ªèµ°å»Šçš„æ—¶é—´ä¸è¶…è¿‡20sã€‚è‰ºæœ¯é¦†æœ€å¤šæœ‰100ä¸ªå±•å®¤ã€‚è­¦å¯Ÿèµ¶åˆ°çš„æ—¶é—´åœ¨10minä»¥å†…ã€‚

**è¾“å‡ºæ ¼å¼**

è¾“å‡ºå·åˆ°çš„ç”»çš„æ•°é‡

**é¢˜ç›®åˆ†æ**

æŒ‰ç…§é¢˜ç›®æ„æ€å»ºæ ‘ï¼Œè§‚å¯Ÿå¯å¾—ï¼Œå·ä¸€å¹…ç”»è¦è¿›å»å‡ºæ¥ï¼Œé‚£ä¹ˆå°±æŠŠè¾¹é•¿ä¹˜äºŒï¼Œç„¶åç›´æ¥è·‘æ ‘å½¢dpå°±å¥½äº†ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/9/4.
//
#include <bits/stdc++.h>

using ll = long long;

int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int limit;
    std::cin >> limit;
    std::vector<std::pair<int, int>> s;
    s.emplace_back(0, 0);
    int tot = 0;
    int c, paint;
    while (std::cin >> c >> paint) {
        s.emplace_back(c * 2, paint);
        tot += paint;
    }
    int n = s.size();
    std::vector<std::vector<std::pair<int, int>>> G(n + 1);
    std::vector<int> fa(n + 1);
    std::vector<int> wei(n + 1);
    int cur = 1;
    std::function<void(int)> build = [&](int id) {
        wei[id] = s[id].second;
        if (wei[id] == 0) {
            G[id].emplace_back(cur + 1, s[cur + 1].first);
            build(++cur);//ls
            G[id].emplace_back(cur + 1, s[cur + 1].first);
            build(++cur);//rs
        }
    };
    G[0].emplace_back(1, s[1].first);
    build(1);
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(tot + 1, 0x3f3f3f3f));

    std::function<void(int)> dfs = [&](int u) {
        if (G[u].empty()) {
            for (int i = 0; i <= wei[u]; ++i) {
                dp[u][i] = i * 5;
            }
        }
        dp[u][0] = 0;
        for (auto [v, w]: G[u]) {
            dfs(v);
            wei[u] += wei[v];
            for (int i = std::min(tot, wei[u]); i >= 1; --i) {
                for (int j = std::min(i , wei[v]); j >= 0; --j) {
                    dp[u][i] = std::min(dp[u][i], dp[u][i - j] + dp[v][j] + w);
                }
            }
        }

    };
    dfs(0);
    int ans = 0;
    for (int i = 0; i <= tot; ++i) {
        if (dp[0][i] <limit)ans = i;
    }
    std::cout << ans << '\n';
    return 0;
}
```

### 2.CF461BAppleman and Tree

**é¢˜ç›®æè¿°**

ç»™ä½ ä¸€æ£µæœ‰ $n$ ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œä¸‹æ ‡ä» $0$ å¼€å§‹ã€‚

ç¬¬ $i$ ä¸ªèŠ‚ç‚¹å¯ä»¥ä¸ºç™½è‰²æˆ–é»‘è‰²ã€‚

ç°åœ¨ä½ å¯ä»¥ä»ä¸­åˆ å»è‹¥å¹²æ¡è¾¹ï¼Œä½¿å¾—å‰©ä¸‹çš„æ¯ä¸ªéƒ¨åˆ†æ°æœ‰ä¸€ä¸ªé»‘è‰²èŠ‚ç‚¹ã€‚

é—®æœ‰å¤šå°‘ç§ç¬¦åˆæ¡ä»¶çš„åˆ è¾¹æ–¹æ³•ï¼Œç­”æ¡ˆå¯¹ $10^9+7$ å–æ¨¡ã€‚

è¾“å…¥æ ¼å¼

ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•° $n(1\leq n\leq 10^5)$ï¼Œè¡¨ç¤ºèŠ‚ç‚¹ä¸ªæ•°ã€‚

æ¥ä¸‹æ¥ä¸€è¡Œ $n-1$ ä¸ªæ•´æ•° $(p_0,p_1,\cdots,p_{n-2},0\leq p_i\leq i)$ï¼Œè¡¨ç¤ºæ ‘ä¸­æœ‰ä¸€æ¡è¿æ¥èŠ‚ç‚¹ $p_i$ å’ŒèŠ‚ç‚¹ $i+1$ çš„è¾¹ã€‚

æ¥ä¸‹æ¥ä¸€è¡Œ $n$ ä¸ªæ•´æ•° $(x_0,x_1,\cdots,x_{n-1},0\leq x_i\leq 1)$ï¼Œè‹¥ $x_i$ ä¸º $1$ï¼Œåˆ™èŠ‚ç‚¹ $i$ ä¸ºé»‘è‰²ï¼Œå¦åˆ™ä¸ºç™½è‰²ã€‚

è¾“å‡ºæ ¼å¼

ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç¬¦åˆæ¡ä»¶çš„åˆ è¾¹æ–¹æ³•çš„æ–¹æ¡ˆæ•°å¯¹ $10^9+7$ å–æ¨¡åçš„å€¼ã€‚

**é¢˜ç›®åˆ†æ**

è€ƒè™‘æ ‘å½¢dpï¼Œå‘ç°æ¯ä¸ªèŠ‚ç‚¹å’Œå…¶å­æ ‘çš„å…³ç³»æœ‰ï¼š1.èŠ‚ç‚¹æ‰€åœ¨çš„è¿é€šå—æ²¡æœ‰1ã€‚2.èŠ‚ç‚¹æ‰€åœ¨çš„è¿é€šå—æœ‰1ã€‚è®¾$dp[u][0/1]$ä¸ºuèŠ‚ç‚¹æ‰€åœ¨çš„è¿é€šå—æ²¡æœ‰1çš„æ–¹æ¡ˆï¼Œæœ‰1çš„æ–¹æ¡ˆã€‚é‚£ä¹ˆå¯ä»¥å¾—åˆ°dpçš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š$dp[u][1]=dp[u][1]*dp[v][0]+dp[u][1]*dp[v][1]+dp[u][0]*dp[v][1]$ä¸‰ä¸ªé¡¹åˆ†åˆ«ä»£è¡¨1.uåˆæ³•ï¼Œvä¸åˆæ³•ï¼Œä¸åˆ‡æ–­ã€‚2.uåˆæ³•ï¼Œvåˆæ³•ï¼Œåˆ‡æ–­ã€‚3.uä¸åˆæ³•ï¼Œvåˆæ³•ï¼Œä¸åˆ‡æ–­ã€‚åŒç†ï¼Œ$dp[u][0]=dp[u][0]*dp[v][1]+dp[u][0]*dp[v][0]$ä»£è¡¨1.uä¸åˆæ³•ï¼Œvåˆæ³•ï¼Œåˆ‡æ–­ã€‚2.uä¸åˆæ³•ï¼Œvä¹Ÿä¸åˆæ³•ï¼Œä¸åˆ‡æ–­ã€‚æ¯ä¸ªèŠ‚ç‚¹å¤„ç†ä¸€ä¸‹åˆå§‹å€¼å³å¯ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/9/27.
//
#include <vector>
#include <algorithm>
#include <iostream>
#include <array>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
	T u = 0, v = 1;
	while (a != 0) {
		T t = b / a;
		b -= t * a;
		std::swap(a, b);
		u -= t * v;
		std::swap(u, v);
	}
	assert(b == 1);
	return u;
}

template<typename T>
T power(T a, int b) {
	T ans = 1;
	for (; b; a *= a, b >>= 1) {
		if (b & 1)ans *= a;
	}
	return ans;
}

template<int Mod>
class Modular {
public:
	using Type = int;

	template<typename U>
	static Type norm(U& x) {
		Type v;
		if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
		else v = static_cast<Type>(x % Mod);
		if (v < 0) v += Mod;
		return v;
	}

	constexpr Modular() : value() {}

	int val() const { return value; }

	Modular inv() const {
		return Modular(inverse(value, Mod));
	}

	template<typename U>
	Modular(const U& x) {
		value = norm(x);
	}

	const Type& operator ()() const {
		return value;
	}

	template<typename U>
	explicit operator U() const {
		return static_cast<U>(value);
	}

	Modular& operator +=(const Modular& other) {
		if ((value += other.value) >= Mod) value -= Mod;
		return *this;
	}

	Modular& operator -=(
			const Modular& other) {
		if ((value -= other.value) < 0) value += Mod;
		return *this;
	}

	template<typename U>
	Modular& operator +=(const U& other) { return *this += Modular(other); }

	template<typename U>
	Modular& operator -=(const U& other) { return *this -= Modular(other); }

	Modular& operator ++() { return *this += 1; }

	Modular& operator --() { return *this -= 1; }

	Modular operator ++(int) {
		Modular result(*this);
		*this += 1;
		return result;
	}

	Modular operator --(int) {
		Modular result(*this);
		*this -= 1;
		return result;
	}

	Modular operator -() const { return Modular(-value); }

	template<class ISTREAM_TYPE>
	friend ISTREAM_TYPE& operator >>(ISTREAM_TYPE& is, Modular& rhs) {
		ll v;
		is >> v;
		rhs = Modular(v);
		return is;
	}

	template<class OSTREAM_TYPE>
	friend OSTREAM_TYPE& operator <<(OSTREAM_TYPE& os, const Modular& rhs) {
		return os << rhs.val();
	}

	Modular& operator *=(const Modular& rhs) {
		value = ll(value) * rhs.value % Mod;
		return *this;
	}

	Modular& operator /=(const Modular& other) { return *this *= Modular(inverse(other.value, Mod)); }

	friend const Type& abs(const Modular& x) { return x.value; }

	friend bool operator ==(const Modular& lhs, const Modular& rhs) { return lhs.value == rhs.value; }

	friend bool operator <(const Modular& lhs, const Modular& rhs) { return lhs.value < rhs.value; }


	bool operator ==(const Modular& rhs) { return *this == rhs.value; }

	template<typename U>
	bool operator ==(U rhs) { return *this == Modular(rhs); }

	template<typename U>
	friend bool operator ==(U lhs, const Modular& rhs) { return Modular(lhs) == rhs; }

	bool operator !=(const Modular& rhs) { return *this != rhs; }

	template<typename U>
	bool operator !=(U rhs) { return *this != rhs; }

	template<typename U>
	friend bool operator !=(U lhs, const Modular& rhs) { return lhs != rhs; }

	bool operator <(const Modular& rhs) { return this->value < rhs.value; }

	Modular operator +(const Modular& rhs) { return Modular(*this) += rhs; }

	template<typename U>
	Modular operator +(U rhs) { return Modular(*this) += rhs; }

	template<typename U>
	friend Modular operator +(U lhs, const Modular& rhs) { return Modular(lhs) += rhs; }

	Modular operator -(const Modular& rhs) { return Modular(*this) -= rhs; }

	template<typename U>
	Modular operator -(U rhs) { return Modular(*this) -= rhs; }

	template<typename U>
	friend Modular operator -(U lhs, const Modular& rhs) { return Modular(lhs) -= rhs; }

	Modular operator *(const Modular& rhs) { return Modular(*this) *= rhs; }

	template<typename U>
	Modular operator *(U rhs) { return Modular(*this) *= rhs; }

	template<typename U>
	friend Modular operator *(U lhs, const Modular& rhs) { return Modular(lhs) *= rhs; }

	Modular operator /(const Modular& rhs) { return Modular(*this) /= rhs; }

	template<typename U>
	Modular operator /(U rhs) { return Modular(*this) /= rhs; }

	template<typename U>
	friend Modular operator /(U lhs, const Modular& rhs) { return Modular(lhs) /= rhs; }

private:
	Type value;
};

const int mod = 1e9 + 7;
using Z = Modular<mod>;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n;
	std::cin >> n;
	std::vector<std::vector<int>> G(n);
	for (int i = 1; i < n; ++i) {
		int x;
		std::cin >> x;
		G[i].push_back(x);
		G[x].push_back(i);
	}
	std::vector<int> color(n);
	for (int i = 0; i < n; ++i) {
		std::cin >> color[i];
	}

	std::vector<std::array<Z, 2>> dp(n);
	std::function<void(int, int)> dfs = [&](int u, int fa) {
		dp[u][color[u]] = 1;
		for (auto v: G[u]) {
			if (v == fa)continue;
			dfs(v, u);
			dp[u][1] = dp[u][0] * dp[v][1] + dp[u][1] * (dp[v][1] + dp[v][0]);
			dp[u][0] = dp[u][0] * (dp[v][1] + dp[v][0]);
		}
	};


	dfs(0, -1);
//	for (int i = 0; i < n; ++i) {
//		std::cout << dp[i][0] << ' ' << dp[i][1] << '\n';
//	}
	std::cout << dp[0][1] << '\n';
	return 0;
}
```

### 3.æ ‘

**é¢˜ç›®æè¿°**

ç»™ä½ ä¸¤æ£µåˆ†åˆ«æœ‰nä¸ªèŠ‚ç‚¹å’Œmä¸ªèŠ‚ç‚¹çš„æ ‘ã€‚

åˆšå¼€å§‹ä¸¤æ£µæ ‘æ˜¯ä¸è¿é€šçš„,ä½ éœ€è¦åœ¨ä¸¤æ£µæ ‘ä¸­å„é€‰ä¸€ä¸ªèŠ‚ç‚¹,è¿æ¥ä»–ä»¬,ä½¿å¾—ä¸¤æ£µæ ‘å˜è”é€šã€‚

æˆ‘ä»¬ç”¨dis(i,j) æ¥è¡¨ç¤ºä»iåˆ°è¾¾jç»è¿‡è¾¹çš„æœ€å°æ•°é‡ã€‚

å¯¹äºè¿æ¥åçš„è”é€šå›¾,ä½ éœ€è¦æœ€å°åŒ–$\frac{(n+m)(n+m-1)}{2}$ä¸ªç‚¹å¯¹çš„dis

**é¢˜ç›®åˆ†æ**

å°†ä¸¤æ£µæ ‘çš„æ ¹è¿æ¥åœ¨ä¸€èµ·ï¼Œå¯ä»¥å¾—åˆ°è¿™ä¸¤æ£µæ ‘é€‰å‡ºä¸¤ä¸ªç‚¹çš„è·ç¦»å’Œå¹³æ–¹ä¸º$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}(dis(i,root1)+dis(j,root2)+1)^2$,è®°$A_1$ä¸ºæ ‘1çš„$\sum dis(i,root)$,$A_2$ä¸ºæ ‘2çš„$\sum dis(i,root)$,$B_1$ä¸ºæ ‘1çš„$\sum dis(i,root)+dis^2(i,root)$,$B_2$ä¸ºæ ‘2çš„$\sum dis(i,root)+dis^2(i,root)$,å¯ä»¥æŠŠä¸ŠæŸ¿åŒ–ç®€ä¸º$A_1\cdot A_2+m\cdot B_1+n\cdot B_2+n\cdot m$ã€‚ç„¶ååŠ ä¸Šæ ‘å†…çš„è´¡çŒ®å³å¯ã€‚æ±‚æ ‘å†…è´¡çŒ®æ—¶å¯ä»¥è€ƒè™‘å½“å…¶ä½äº$u$,å…¶æœ‰å­æ ‘$v$,éå†uçš„å­æ ‘ï¼Œå…¶å¯¹ç­”æ¡ˆäº§ç”Ÿçš„è´¡çŒ®å°±æ˜¯uçš„å­æ ‘å’Œvçš„å­æ ‘è¿›è¡Œåˆå¹¶ï¼ŒåŒæ—¶ç»´æŠ¤$sumdis$å’Œ$sumdis^2$,ç„¶åè¿›è¡Œæ¢æ ¹dpï¼Œæ¢æ ¹å®Œä¹‹åè€ƒè™‘å°†æ ‘1å’Œæ ‘2åˆå¹¶ï¼Œæˆ‘è¿™é‡Œæ˜¯æŒ‰$A_1+mB_1$å¯¹æ ‘1çš„ç‚¹è¿›è¡Œsortï¼Œ$A_2+nB_2$å¯¹æ ‘2çš„ç‚¹è¿›è¡Œsortç„¶åå„å–å‰ä¸€ä¸‡ä¸ªå–minï¼Œå› ä¸º$sumdis$å’Œ$sumdis^2$éƒ½æ˜¯æ­£æ•°ï¼Œæ‰€ä»¥å¾ˆéš¾å¡æ‰ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/10/5.
//
#include <vector>
#include <algorithm>
#include <iostream>
#include <array>
#include <numeric>

using ll = long long;

ll merge(ll sa1, ll sa2, ll nn, ll sb1, ll sb2, ll mm) {
	return mm * sa2 + nn * sb2 + 2 * sa1 * sb1 + nn * mm + 2 * mm * sa1 + 2 * nn * sb1;
}

struct tree {
	std::vector<std::vector<int>> adj;

	std::vector<ll> sumdep, sumdep2, siz;
	ll val = 0;

	tree(int n) : adj(n + 1), sumdep(n + 1), sumdep2(n + 1), siz(n + 1) {}

	void ade(int u, int v) {
		adj[u].push_back(v);
		adj[v].push_back(u);
	}

	void dfs1(int u, int fa) {
		siz[u] = 1;
		sumdep[u] = 0;
		sumdep2[u] = 0;
		for (auto v: adj[u]) {
			if (v == fa)continue;
			dfs1(v, u);
			val += merge(sumdep[u], sumdep2[u], siz[u], sumdep[v], sumdep2[v], siz[v]);
			siz[u] += siz[v];
			sumdep[u] += sumdep[v] + siz[v];
			sumdep2[u] += sumdep2[v] + 2 * sumdep[v] + siz[v];
		}
	}

	void dfs2(int u, int fa) {
		for (auto v: adj[u]) {
			if (v == fa)continue;
			sumdep2[v] = (sumdep2[u] - sumdep2[v] - 2 * sumdep[v] - siz[v]) + 2 * (sumdep[u] - sumdep[v] - siz[v]) + siz[u] - siz[v] + sumdep2[v];
			sumdep[v] = (sumdep[u] - sumdep[v] + siz[u] - siz[v]) + sumdep[v] - siz[v];
			siz[v] = siz[u];
			dfs2(v, u);
		}
	}

	void show() {
		for (int i = 1; i < sumdep.size(); ++i)std::cerr << sumdep[i] << " \n"[i == sumdep.size() - 1];
		for (int i = 1; i < sumdep2.size(); ++i)std::cerr << sumdep2[i] << " \n"[i == sumdep2.size() - 1];
		for (int i = 1; i < siz.size(); ++i)std::cerr << siz[i] << " \n"[i == siz.size() - 1];
	}
};

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n, m;
	std::cin >> n;
	tree t1(n);
	for (int i = 1; i < n; ++i) {
		int u, v;
		std::cin >> u >> v;
		t1.ade(u, v);
	}
	t1.dfs1(1, 1);
	t1.dfs2(1, 1);

	std::cin >> m;
	tree t2(m);
	for (int i = 1; i < m; ++i) {
		int u, v;
		std::cin >> u >> v;
		t2.ade(u, v);
	}
	t2.dfs1(1, 1);
	t2.dfs2(1, 1);
	ll ans = 4e18;
	//ä»¤A = sumdep , B = sumdep + sumdep2;
	//ans = min(A1*A2 + mB1 + nB2 + nm);
	std::vector<int> aa(n), bb(m);
	std::iota(aa.begin(), aa.end(), 1);
	std::iota(bb.begin(), bb.end(), 1);
	std::sort(aa.begin(), aa.end(), [&](int i, int j) {
		return t1.sumdep2[i] + m * (t1.sumdep[i] + t1.sumdep2[i]) < t1.sumdep2[j] + m * (t1.sumdep[j] + t1.sumdep2[j]);
	});

	std::sort(bb.begin(), bb.end(), [&](int i, int j) {
		return t2.sumdep2[i] + n * (t2.sumdep[i] + t2.sumdep2[i]) < t2.sumdep2[j] + n * (t2.sumdep[j] + t2.sumdep2[j]);
	});

	for (int i = 0; i < std::min(int(1e4), n); ++i) {
		for (int j = 0; j < std::min(int(1e4), m); ++j) {
			ans = std::min(ans, merge(t1.sumdep[aa[i]], t1.sumdep2[aa[i]], t1.siz[aa[i]], t2.sumdep[bb[j]], t2.sumdep2[bb[j]], t2.siz[bb[j]]));
		}
	}
	std::cout << t1.val + t2.val + ans << '\n';
	return 0;
}
```



## ä¼˜åŒ–

### 1.CF1715 ELong Way Home

**é¢˜ç›®æè¿°**

æœ‰ $n$ åº§åŸå¸‚ï¼ŒåŸå¸‚é—´æœ‰ $m$ æ¡åŒå‘é“è·¯ï¼Œé€šè¿‡ç¬¬ $i$ æ¡é“è·¯éœ€è¦èŠ±è´¹ $w_i$ çš„æ—¶é—´ï¼Œä»»æ„ä¸¤ä¸ªåŸå¸‚ä¹‹é—´éƒ½æœ‰èˆªç­ï¼Œä¹˜ååŸå¸‚ $u$ å’Œ $v$ ä¹‹é—´çš„èˆªç­éœ€è¦èŠ±è´¹ $(u-v)^2$ çš„æ—¶é—´ã€‚

ç°åœ¨è¯·å¯¹äºä»»æ„åŸå¸‚ $i(1 \le i \le n)$ï¼Œæ±‚å‡ºä»åŸå¸‚ $1$ å‡ºå‘ï¼Œåˆ°è¾¾åŸå¸‚ $i$ æ‰€éœ€è¦çš„æœ€çŸ­æ—¶é—´ï¼Œæ³¨æ„ä»åŸå¸‚ $1$ åˆ° $i$ çš„è¿‡ç¨‹ä¸­**æœ€å¤šä¹˜å $k$ æ¬¡èˆªç­**ã€‚

**é¢˜ç›®åˆ†æ**

çœ‹åˆ°å¹³æ–¹ç›´æ¥ä¸€çœ¼dpï¼Œä½†æ˜¯å‘ç°è¿˜æœ‰åœ°ä¸Šçš„é“è·¯ï¼Œæ‰€ä»¥è¦è·‘ä¸€è·‘dijï¼Œç„¶å ç”±äºæ¯ä¸ªç‚¹å¯ä»¥ä»æ‰€æœ‰ç‚¹è½¬ç§»è¿‡æ¥ï¼Œæ‰€ä»¥å…ˆé¢„å¤„ç†å‡ºä¸€ä¸ªå‡¸å£³ï¼Œç„¶ååˆ©ç”¨æ–œç‡çš„å•è°ƒæ€§è¿›è¡Œæ–œç‡ä¼˜åŒ–ï¼Œæ›´æ–°ä¸€ä¸‹æ—¶é—´ï¼Œç„¶åå†æ”¾ç¼©ä¸€éã€‚å› ä¸ºæœ€å¤šåškæ¬¡æ”¾ç¼©ï¼Œæ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(k(n+mlogn))$

```c++
//
// Created by mrx on 2022/9/29.
//
#include <vector>
#include <algorithm>
#include <iostream>
#include <array>
#include <queue>

using ll = long long;

struct line {
	ll k, b;

	line(ll k, ll b) : k(k), b(b) {}

	double intersect(const line& l) const { return 1.0 * (l.b - b) / (k - l.k); }

	bool operator <(const line& rhs) const {
		if (k == rhs.k) return b > rhs.b;
		return k < rhs.k;
	}

	ll operator ()(ll x) const { return k * x + b; }
};

struct ConvexHull {
	std::vector<double> points;
	std::vector<line> lines;

	int size() { return points.size(); }

	void reset() {
		points.clear();
		lines.clear();
	}

	void init(const line& l) {
		points.push_back(-1e9);
		lines.push_back(l);
	}

	void addLine(const line& l) {
		if (points.size() == 0) {
			points.push_back(-1e9);
			lines.push_back(l);
			return;
		}
		while (lines.size() >= 2 && l.intersect(lines[lines.size() - 2]) <= points.back()) {
			points.pop_back();
			lines.pop_back();
		}
		points.push_back(l.intersect(lines.back()));
		lines.push_back(l);
	}

	ll query(int x, int id) { return lines[id](x); }

	ll query(int x) {
		int id = upper_bound(points.begin(), points.end(), x) - points.begin() - 1;
		return lines[id](x);
	}
};

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n, m, k;
	std::cin >> n >> m >> k;

	std::vector<std::vector<std::pair<int, ll>>> adj(n);
	for (int i = 0; i < m; ++i) {
		int u, v;
		ll w;
		std::cin >> u >> v >> w;
		u--, v--;
		adj[u].emplace_back(v, w);
		adj[v].emplace_back(u, w);
	}

	std::vector<ll> dis(n, 0x3f3f3f3f3f3f3f3f);
	std::function<void(const std::vector<int>&)> dijkstra = [&](const std::vector<int>& start) {
		std::priority_queue<std::pair<ll, int>, std::vector<std::pair<ll, int>>, std::greater<>> q;
		for (auto i: start)q.emplace(dis[i], i);
		while (!q.empty()) {
			auto [dist, u] = q.top();
			q.pop();
			if (dis[u] != dist)continue;
			for (auto [v, w]: adj[u]) {
				if (w + dis[u] < dis[v]) {
					dis[v] = w + dis[u];
					q.emplace(dis[v], v);
				}
			}
		}
	};

	dis[0] = 0;
	dijkstra((std::vector<int>(1)));

	for (int i = 0; i < k; ++i) {
		ConvexHull ch;
		std::vector<int> change;
		for (ll j = 0; j < n; ++j) {
			ch.addLine(line(-2 * j, dis[j] + j * j));
		}
		int id = 0;
		for (ll u = 1; u < n; u++) {
			while (id + 1 < ch.size() && ch.query(u, id + 1) < ch.query(u, id)) id++;
			ll cur = ch.query(u, id) + ll(u) * u;
			if (cur < dis[u]) {
				change.push_back(u);
				dis[u] = cur;
			}
		}
		dijkstra(change);
	}
	for (int i = 0; i < n; ++i)std::cout << dis[i] << " \n"[i == n - 1];
	return 0;
}
```

 

### 2.CFGYM104017C  Il Derby della Madonnina

**é¢˜æ„**

è£åˆ¤åœ¨ä¸€æ¡ç›´çº¿ä¸Šï¼Œåœ¨ç¬¬$t_i$æ—¶ï¼Œä»–èµ°åˆ°$a_i$ç‚¹ï¼Œä»–è·å¾—ä¸€åˆ†ï¼Œèµ·å§‹ï¼Œè£åˆ¤åœ¨0å·ç‚¹ï¼Œæœ€å¤§é€Ÿåº¦ä¸ºvï¼Œæ±‚å…¶èƒ½å¾—å‡ åˆ†ã€‚

**é¢˜è§£**

$|a_i-a_j|\le v*(t_i-t_j)$æ—¶ï¼Œè£åˆ¤å¯ä»¥ä»$j$å·ç‚¹è½¬ç§»åˆ°$i$å·ç‚¹ã€‚å³

$a_i-a_j \le v*(t_i-t_j) $ä¸”$a_i-a_j\ge -v*(t_i-t_j)$æ—¶å¯ä»¥è½¬ç§»ï¼Œç§»é¡¹å¾—åˆ°ï¼š

$a_i-v*t_i\le a_j-v*t_j$ä¸”$a_i+v*t_i\ge a_j+v*t_j$æ—¶æ‰å¯è½¬ç§»ï¼Œè®°$l_i=a_i-v*t_i$,$r_i= a_i+v*t_i$ï¼Œé‚£ä¹ˆå½“

$l_i\le l_j$,$r_i\ge r_j$æ—¶å¯ä»¥è½¬ç§»ï¼Œé‚£ä¹ˆé—®é¢˜è½¬åŒ–ä¸ºäº†æœ‰å¤šå°‘ä¸ª(l,r)å¥—åœ¨ä¸€èµ·ï¼Œç”¨çº¿æ®µæ ‘å¯ä»¥ç»´æŠ¤ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2023/4/9.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

using i64 = long long;


struct Nod {
    i64 max;
    
    Nod() : max(0) {}
    
    Nod(int x) {
        max = x;
    }
    
    //æ ¹æ®éœ€è¦æ”¹å˜
    friend Nod merge(const Nod& lhs, const Nod& rhs) {
        Nod ans;
        ans.max = std::max(lhs.max, rhs.max);
        return ans;
    }
    
};


struct SegmentTree {
    std::vector<Nod> tree;
    int n;
    
    inline void push_up(int rt) {
        tree[rt] = merge(tree[rt << 1], tree[rt << 1 | 1]);
    }
    
    template<typename M>
    void build(int l, int r, int rt, const std::vector<M>& base) {
        if (l == r) {
            tree[rt] = base[l];
            return;
        }
        int m = (l + r) >> 1;
        build(l, m, rt << 1, base);
        build(m + 1, r, rt << 1 | 1, base);
        push_up(rt);
    }
    
    template<typename M>
    void _modify(int l, int r, int L, int R, int rt, const M& v) {
        if (L <= l && r <= R) {
            tree[rt] = v;
            return;
        }
        int m = (l + r) >> 1;
        if (L <= m)_modify(l, m, L, R, rt << 1, v);
        if (R > m)_modify(m + 1, r, L, R, rt << 1 | 1, v);
        push_up(rt);
    }
    
    Nod qry(int l, int r, int L, int R, int rt) {
        if (L <= l && r <= R) {
            return tree[rt];
        }
        int m = (l + r) >> 1;
        Nod res;
        if (R <= m)res = qry(l, m, L, R, rt << 1);
        else if (L > m)res = qry(m + 1, r, L, R, rt << 1 | 1);
        else res = merge(qry(l, m, L, R, rt << 1), qry(m + 1, r, L, R, rt << 1 | 1));
        push_up(rt);
        return res;
    }
    
    template<class Type>
    SegmentTree(const std::vector<Type>& a) {
        n = a.size();
        n--;
        tree.resize((n << 2) + 1);
        build(1, n, 1, a);
    }
    
    template<typename M>
    void modify(int L, int R, const M& v) {
        _modify(1, n, L, R, 1, v);
    }
    
    Nod query(int L, int R) {
        return qry(1, n, L, R, 1);
    }
    
    Nod query(int pos) {
        return qry(1, n, pos, pos, 1);
    }
};


void solve() {
    int n, v;
    std::cin >> n >> v;
    std::vector<i64> a(n), t(n);
    for (int i = 0; i < n; ++i)std::cin >> t[i];
    for (int i = 0; i < n; ++i)std::cin >> a[i];
    std::vector<std::pair<i64, i64>> lr;
    for (int i = 0; i < n; ++i) {
        i64 l = a[i] - v * t[i], r = a[i] + v * t[i];
        if (l <= 0 && r >= 0)lr.emplace_back(l, r);
    }
    lr.emplace_back(0, 0);
    std::vector<i64> lsh;
    for (auto& [l, r]: lr) {
        lsh.push_back(l);
        lsh.push_back(r);
    }
    std::sort(lsh.begin(), lsh.end());
    lsh.erase(std::unique(lsh.begin(), lsh.end()), lsh.end());
    for (auto& [l, r]: lr) {
        l = std::lower_bound(lsh.begin(), lsh.end(), l) - lsh.begin() + 1;
        r = std::lower_bound(lsh.begin(), lsh.end(), r) - lsh.begin() + 1;
    }
    SegmentTree Tree(std::vector<int>(lsh.size() + 2, 0));
    std::sort(lr.begin(), lr.end(), [](const auto& lhs, const auto& rhs) {
        return lhs.second == rhs.second ? lhs.first > rhs.first : lhs.second < rhs.second;
    });
    i64 ans = 0;
    for (auto [l, r]: lr) {
        auto tmp = Tree.query(l, r).max;
        tmp++;
        ans = std::max(ans, tmp);
        Tree.modify(l, l, tmp);
    }
    std::cout << ans - 1 << '\n';
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    solve();
    return 0;
}
```







## çŠ¶æ€å‹ç¼©

### 1.P2167Billçš„æŒ‘æˆ˜

**é¢˜ç›®æè¿°**

Sheng_bill ä¸ä»…æœ‰æƒŠäººçš„å¿ƒç®—èƒ½åŠ›ï¼Œè¿˜å¯ä»¥è½»æ¾åœ°å®Œæˆå„ç§ç»Ÿè®¡ã€‚åœ¨æ˜¨å¤©çš„æ¯”èµ›ä¸­ï¼Œä½ å‡­å€Ÿä¼˜ç§€çš„ç¨‹åºä¸ä»–æ‰“æˆäº†å¹³å±€ï¼Œè¿™å¯¼è‡´ Sheng_bill  æåº¦çš„ä¸æ»¡ã€‚äºæ˜¯ä»–å†æ¬¡æŒ‘æˆ˜ä½ ã€‚è¿™æ¬¡ä½ å¯ä¸èƒ½è¾“ã€‚

è¿™æ¬¡ï¼Œæ¯”èµ›è§„åˆ™æ˜¯è¿™æ ·çš„ï¼š

ç»™å‡º $N$ ä¸ªé•¿åº¦ç›¸åŒçš„å­—ç¬¦ä¸²ï¼ˆç”±å°å†™è‹±æ–‡å­—æ¯å’Œ `?` ç»„æˆï¼‰ï¼Œ$S_1,S_2,\dots,S_N$ï¼Œæ±‚ä¸è¿™ $N$ ä¸ªä¸²ä¸­çš„åˆšå¥½ $K$ ä¸ªä¸²åŒ¹é…çš„å­—ç¬¦ä¸² $T$ çš„ä¸ªæ•°ï¼Œç­”æ¡ˆå¯¹ $1000003$ å–æ¨¡ã€‚

è‹¥å­—ç¬¦ä¸² $S_x(1\le x\le N)$ å’Œ $T$ åŒ¹é…ï¼Œæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š
1. $|S_x|=|T|$ã€‚
2. å¯¹äºä»»æ„çš„ $1\le i\le|S_x|$ï¼Œæ»¡è¶³ $S_x[i]= \texttt{?}$ æˆ–è€… $S_x[i]=T[i]$ã€‚

å…¶ä¸­ $T$ åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚

**é¢˜ç›®åˆ†æ**

å®¹æ˜“æƒ³åˆ°ç®€å•çš„dpï¼š$dp[i][2][2][2][2]...[2]$è¡¨ç¤ºåŒ¹é…åˆ°ç¬¬iä½ï¼Œå…¶ä»–ç»´åº¦è¡¨ç¤ºè‹¥å¹²ä¸ªå­—ç¬¦ä¸²æ˜¯ä¸æ˜¯åŒ¹é…çš„æ–¹æ¡ˆæ•°ï¼Œnamoè€ƒè™‘çŠ¶æ€å‹ç¼©$dp[i][s]$è¡¨ç¤ºåŒ¹é…åˆ°ç¬¬iä½ï¼Œå­—ç¬¦ä¸²çŠ¶æ€ä¸ºsçš„åŒ¹é…æ–¹æ¡ˆæ•°ã€‚

è€ƒè™‘çŠ¶æ€è½¬ç§»ï¼Œæšä¸¾ç¬¬iä½çš„å­—ç¬¦ï¼Œå¯¹äºå…¶ä¸­æšä¸¾çŠ¶æ€ï¼Œå¦‚æœ$str[j][i](s_0>>j\&1)$å¯ä»¥äºæšä¸¾çš„å­—ç¬¦åŒ¹é…ï¼Œé‚£ä¹ˆçŠ¶æ€è½¬ç§»è‡³$dp[i+1][s_0]$,ä½†æ˜¯æ¯æ¬¡éƒ½è¿™ä¹ˆæšä¸¾å¤ªæ…¢äº†ï¼Œæ‰€ä»¥å¯¹äºæ¯ä¸€ä¸ªä½ç½®æ¯ä¸€ä¸ªé¢œè‰²é¢„å¤„ç†åˆæ³•å­—ç¬¦ä¸²çš„çŠ¶æ€ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/8/7.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, int b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    int val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

constexpr int mod = 1000003;
using Z = Modular<mod>;

void sol() {
    int n, k;
    std::cin >> n >> k;
    std::vector<std::string> str(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> str[i];
    }
    int len = str[0].length();
    std::vector<std::vector<int>> match(26, std::vector<int>(len, 0));//char,pos


    for (int i = 0; i < 26; ++i) {
        for (int j = 0; j < n; ++j) {
            for (int pos = 0; pos < len; ++pos) {
                if (str[j][pos] == '?' || str[j][pos] == 'a' + i) {
                    match[i][pos] |= (1 << j);
                }
            }
        }
    }

    std::vector<std::vector<Z>> dp((1 << n), std::vector<Z>(len + 1, 0));
    dp[(1 << n) - 1][0] = 1;
    for (int pos = 0; pos < len; ++pos) {
        for (int s = 0; s < 1 << n; ++s) {
            for (int i = 0; i < 26; ++i) {
                dp[s & match[i][pos]][pos + 1] += dp[s][pos];
            }
        }
    }
    Z ans = 0;
    for (int s = 0; s < 1 << n; ++s) {
        if (__builtin_popcount(s) == k) {
            ans += dp[s][len];
        }
    }
    std::cout << ans << '\n';
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int t;
    std::cin >> t;
    while (t--)sol();
    return 0;
}
```



### 2.P3959å®è—

**é¢˜ç›®æè¿°**

å‚ä¸è€ƒå¤æŒ–æ˜çš„å°æ˜å¾—åˆ°äº†ä¸€ä»½è—å®å›¾ï¼Œè—å®å›¾ä¸Šæ ‡å‡ºäº† $n$ ä¸ªæ·±åŸ‹åœ¨åœ°ä¸‹çš„å®è—å±‹ï¼Œ ä¹Ÿç»™å‡ºäº†è¿™ $n$ ä¸ªå®è—å±‹ä¹‹é—´å¯ä¾›å¼€å‘çš„ $m$ æ¡é“è·¯å’Œå®ƒä»¬çš„é•¿åº¦ã€‚

å°æ˜å†³å¿ƒäº²è‡ªå‰å¾€æŒ–æ˜æ‰€æœ‰å®è—å±‹ä¸­çš„å®è—ã€‚ä½†æ˜¯ï¼Œæ¯ä¸ªå®è—å±‹è·ç¦»åœ°é¢éƒ½å¾ˆè¿œï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä»åœ°é¢æ‰“é€šä¸€æ¡åˆ°æŸä¸ªå®è—å±‹çš„é“è·¯æ˜¯å¾ˆå›°éš¾çš„ï¼Œè€Œå¼€å‘å®è—å±‹ä¹‹é—´çš„é“è·¯åˆ™ç›¸å¯¹å®¹æ˜“å¾ˆå¤šã€‚

å°æ˜çš„å†³å¿ƒæ„ŸåŠ¨äº†è€ƒå¤æŒ–æ˜çš„èµåŠ©å•†ï¼ŒèµåŠ©å•†å†³å®šå…è´¹èµåŠ©ä»–æ‰“é€šä¸€æ¡ä»åœ°é¢åˆ°æŸä¸ªå®è—å±‹çš„é€šé“ï¼Œé€šå¾€å“ªä¸ªå®è—å±‹åˆ™ç”±å°æ˜æ¥å†³å®šã€‚

åœ¨æ­¤åŸºç¡€ä¸Šï¼Œå°æ˜è¿˜éœ€è¦è€ƒè™‘å¦‚ä½•å¼€å‡¿å®è—å±‹ä¹‹é—´çš„é“è·¯ã€‚å·²ç»å¼€å‡¿å‡ºçš„é“è·¯å¯ä»¥ ä»»æ„é€šè¡Œä¸æ¶ˆè€—ä»£ä»·ã€‚æ¯å¼€å‡¿å‡ºä¸€æ¡æ–°é“è·¯ï¼Œå°æ˜å°±ä¼šä¸è€ƒå¤é˜Ÿä¸€èµ·æŒ–æ˜å‡ºç”±è¯¥æ¡é“è·¯æ‰€èƒ½åˆ°è¾¾çš„å®è—å±‹çš„å®è—ã€‚å¦å¤–ï¼Œå°æ˜ä¸æƒ³å¼€å‘æ— ç”¨é“è·¯ï¼Œå³ä¸¤ä¸ªå·²ç»è¢«æŒ–æ˜è¿‡çš„å®è—å±‹ä¹‹é—´çš„é“è·¯æ— éœ€å†å¼€å‘ã€‚

æ–°å¼€å‘ä¸€æ¡é“è·¯çš„ä»£ä»·æ˜¯ $\mathrm{L} \times \mathrm{K}$ã€‚å…¶ä¸­ $L$ ä»£è¡¨è¿™æ¡é“è·¯çš„é•¿åº¦ï¼Œ$K$ ä»£è¡¨ä»èµåŠ©å•†å¸®ä½ æ‰“é€šçš„å®è—å±‹åˆ°è¿™æ¡é“è·¯èµ·ç‚¹çš„å®è—å±‹æ‰€ç»è¿‡çš„å®è—å±‹çš„æ•°é‡ï¼ˆåŒ…æ‹¬èµåŠ©å•†å¸®ä½ æ‰“é€šçš„å®è—å±‹å’Œè¿™æ¡é“è·¯èµ·ç‚¹çš„å®è—å±‹ï¼‰ ã€‚

è¯·ä½ ç¼–å†™ç¨‹åºä¸ºå°æ˜é€‰å®šç”±èµåŠ©å•†æ‰“é€šçš„å®è—å±‹å’Œä¹‹åå¼€å‡¿çš„é“è·¯ï¼Œä½¿å¾—å·¥ç¨‹æ€»ä»£ä»·æœ€å°ï¼Œå¹¶è¾“å‡ºè¿™ä¸ªæœ€å°å€¼ã€‚

### 3.UVA1099 Sharing Chocolate

**é¢˜ç›®æè¿°**

ç»™å‡ºä¸€å—é•¿ä¸º $x$, å®½ä¸º $y$ çš„çŸ©å½¢å·§å…‹åŠ›ï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥æ²¿ä¸€æ¡ç›´çº¿æŠŠä¸€å—å·§å…‹åŠ›åˆ‡å‰²æˆä¸¤å—é•¿å®½å‡ä¸ºæ•´æ•°çš„å·§å…‹åŠ›ï¼ˆä¸€æ¬¡ä¸èƒ½åŒæ—¶åˆ‡å‰²å¤šå—å·§å…‹åŠ›ï¼‰ã€‚ 

é—®ï¼šæ˜¯å¦å¯ä»¥ç»è¿‡è‹¥å¹²æ¬¡æ“ä½œå¾—åˆ° $n$ å—é¢ç§¯åˆ†åˆ«ä¸º $a_1, a_2, ..., a_n$ çš„å·§å…‹åŠ›

**é¢˜ç›®åˆ†æ**

å› ä¸ºä¸€æ¬¡åˆ‡å‰²åªèƒ½æ¨ªç€åˆ‡æˆ–è€…ç«–ç€åˆ‡ï¼ŒåŒæ—¶è€ƒè™‘åˆ°$n$éå¸¸å°ï¼Œé‚£ä¹ˆè€ƒ $dp[x][y][z]$ è¡¨ç¤ºé•¿ $x$ ï¼Œå®½ $y$ çš„å·§å…‹åŠ›èƒ½ä¸èƒ½åˆ†å‰²å‡ºçŠ¶æ€ $s$ çš„å·§å…‹åŠ›ã€‚çŠ¶æ€è½¬ç§»æ—¶æšä¸¾ $s$ çš„å­é›†ã€‚ä½†æ˜¯è¿™æ ·è¿›è¡ŒçŠ¶æ€è½¬ç§»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(x*y*(x+y)*3^n)$ æ€»çš„çŠ¶æ€æ•°æœ‰$x*y*2^n$ ä¸ªï¼Œè¿™æ ·å¿…ç„¶tleï¼ŒåŒæ—¶ä»”ç»†ä¸€åˆ†æï¼Œå‘ç°å¦‚æœä¸€å—å·§å…‹åŠ›èƒ½æ°å¥½åˆ†å‰²ä¸ºè‹¥å¹²å—ï¼Œé‚£ä¹ˆä»–ä»¬çš„é¢ç§¯å’Œå¿…ç„¶æ˜¯ä¸€æ ·çš„ã€‚è¿™æ ·å¯ä»¥å¿½ç•¥éå¸¸å¤šçš„çŠ¶æ€ã€‚åŒæ—¶ï¼ŒçŸ¥é“$x$å’Œ$s$ä¹‹åå°±èƒ½æ±‚å‡ºæ¥$y$ï¼Œæ‰€ä»¥çŠ¶æ€å˜ä¸ºäº†$dp[x][s]$ã€‚æ—¶ç©ºå¤æ‚åº¦éƒ½å¤§å¹…ä¸‹é™ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/10/28.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

using i64 = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n;
	int cas = 1;
	while (std::cin >> n && n) {
		int x, y;
		std::cin >> x >> y;
		std::vector<int> a(n);
		for (int i = 0; i < n; ++i)std::cin >> a[i];
		std::vector<int> sum(1 << n);
		for (int s = 0; s < 1 << n; ++s) {
			int tmp = s;
			while (tmp) {
				int lbt = tmp & -tmp;
				int i = __builtin_ctz(lbt);
				sum[s] += a[i];
				tmp -= lbt;
			}
		}

//		std::vector<std::vector<std::vector<bool>>> mp(105, std::vector<std::vector<bool>>(105, std::vector<bool>(1 << n)));
//		std::vector<std::vector<std::vector<bool>>> vis(105, std::vector<std::vector<bool>>(105, std::vector<bool>(1 << n)));
//
//		std::function<bool(int, int, int)> dfs = [&](int c, int r, int s) -> bool {
//			if (vis[c][r][s])return mp[c][r][s];
//			vis[c][r][s] = true;
//
//			if (c == 1) return mp[c][r][s] = r >= sum[s];
//			if (r == 1) return mp[c][r][s] = c >= sum[s];
//
//			for (int s0 = s; s0; s0 = s & (s0 - 1)) {
//				for (int j = 1; j < c; ++j) if (dfs(c - j, r, s0) && dfs(j, r, s ^ s0))return mp[c][r][s] = true;
//				for (int j = 1; j < r; ++j) if (dfs(c, r - j, s0) && dfs(c, j, s ^ s0))return mp[c][r][s] = true;
//			}
//
//			return mp[c][r][s] = false;
//		};

		std::vector<std::vector<bool>> dp(101, std::vector<bool>(1 << n));
		std::vector<std::vector<bool>> vis(101, std::vector<bool>(1 << n));

		std::function<bool(int, int)> dfs = [&dp, &vis, &sum, &dfs](int x, int s) -> bool {
			if (vis[x][s])return dp[x][s];
			vis[x][s] = true;
			if (__builtin_popcount(s) == 1)return dp[x][s] = true;
			int y = sum[s] / x;
			for (int s0 = (s - 1) & s; s0; s0 = (s0 - 1) & s) {
				int x0 = sum[s0] / y;
				int y0 = sum[s0] / x;
				int x1 = sum[s ^ s0] / y;
				int y1 = sum[s ^ s0] / x;
				if (sum[s0] % x == 0 && dfs(std::min(x, y0), s0) && dfs(std::min(x, y1), s0 ^ s))return dp[x][s] = true;
				if (sum[s0] % y == 0 && dfs(std::min(x0, y), s0) && dfs(std::min(x1, y), s ^ s0))return dp[x][s] = true;
			}
			return dp[x][s] = false;
		};

		std::cout << "Case " << cas++ << ": ";
		std::cout << (dfs(std::min(x, y)//
// Created by mrx on 2022/10/28.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

using i64 = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n;
	int cas = 1;
	while (std::cin >> n && n) {
		int x, y;
		std::cin >> x >> y;
		std::vector<int> a(n);
		for (int i = 0; i < n; ++i)std::cin >> a[i];
		std::vector<int> sum(1 << n);
		for (int s = 0; s < 1 << n; ++s) {
			int tmp = s;
			while (tmp) {
				int lbt = tmp & -tmp;
				int i = __builtin_ctz(lbt);
				sum[s] += a[i];
				tmp -= lbt;
			}
		}

//		std::vector<std::vector<std::vector<bool>>> mp(105, std::vector<std::vector<bool>>(105, std::vector<bool>(1 << n)));
//		std::vector<std::vector<std::vector<bool>>> vis(105, std::vector<std::vector<bool>>(105, std::vector<bool>(1 << n)));
//
//		std::function<bool(int, int, int)> dfs = [&](int c, int r, int s) -> bool {
//			if (vis[c][r][s])return mp[c][r][s];
//			vis[c][r][s] = true;
//
//			if (c == 1) return mp[c][r][s] = r >= sum[s];
//			if (r == 1) return mp[c][r][s] = c >= sum[s];
//
//			for (int s0 = s; s0; s0 = s & (s0 - 1)) {
//				for (int j = 1; j < c; ++j) if (dfs(c - j, r, s0) && dfs(j, r, s ^ s0))return mp[c][r][s] = true;
//				for (int j = 1; j < r; ++j) if (dfs(c, r - j, s0) && dfs(c, j, s ^ s0))return mp[c][r][s] = true;
//			}
//
//			return mp[c][r][s] = false;
//		};

		std::vector<std::vector<bool>> dp(101, std::vector<bool>(1 << n));
		std::vector<std::vector<bool>> vis(101, std::vector<bool>(1 << n));

		std::function<bool(int, int)> dfs = [&dp, &vis, &sum, &dfs](int x, int s) -> bool {
			if (vis[x][s])return dp[x][s];
			vis[x][s] = true;
			if (__builtin_popcount(s) == 1)return dp[x][s] = true;
			int y = sum[s] / x;
			for (int s0 = (s - 1) & s; s0; s0 = (s0 - 1) & s) {
				int x0 = sum[s0] / y;
				int y0 = sum[s0] / x;
				int x1 = sum[s ^ s0] / y;
				int y1 = sum[s ^ s0] / x;
				if (sum[s0] % x == 0 && dfs(std::min(x, y0), s0) && dfs(std::min(x, y1), s0 ^ s))return dp[x][s] = true;
				if (sum[s0] % y == 0 && dfs(std::min(x0, y), s0) && dfs(std::min(x1, y), s ^ s0))return dp[x][s] = true;
			}
			return dp[x][s] = false;
		};

		std::cout << "Case " << cas++ << ": ";
		if (sum[(1 << n) - 1] != x * y)std::cout << "No\n";
		else std::cout << (dfs(std::min(x, y), (1 << n) - 1) ? "Yes" : "No") << '\n';
	}
	return 0;
}, (1 << n) - 1) ? "Yes" : "No");
		std::cout << '\n';
	}

	return 0;
}
```





# æ•°å­¦

## ç»„åˆæ•°å­¦

### å¢å¡æ–¯å®šç†

#### P5598ã€XR-4ã€‘æ··ä¹±åº¦

**é¢˜ç›®æè¿°**

å° X æœ‰ $n$ ç§é¢œè‰²çš„çƒï¼Œå…¶ä¸­ç¬¬ $i$ ç§é¢œè‰²çš„çƒå…±æœ‰ $a_i$ ä¸ªï¼ŒåŒè‰²çš„çƒæ— æ³•åŒºåˆ†ã€‚å®šä¹‰ç¬¬ $l \sim r$ ç§é¢œè‰²çš„æ··ä¹±åº¦ $f(l, r)$ ä¸ºï¼šå°†ç¬¬ $l \sim r$ ç§é¢œè‰²çš„æ‰€æœ‰çƒæ’æˆä¸€æ’ï¼Œæ€»å…±çš„æ–¹æ¡ˆæ•°å¯¹ $p$ å–æ¨¡åçš„å€¼ã€‚å° X æƒ³è¯·ä½ å¸®å¿™è®¡ç®—ä¸‹åˆ—å¼å­çš„å€¼ï¼š

$$ \sum_{l=1}^n \sum_{r=l}^n f(l, r) $$

**é¢˜ç›®åˆ†æ**

ä¸€çœ¼å°±çœ‹å‡ºæ¥fæ˜¯ä¸€ä¸ªå¯é‡é›†åˆçš„æ’åˆ—ï¼Œè€Œä¸”è®¡ç®—å¾ˆå¿«ï¼Œå›°éš¾çš„æ˜¯açš„å€¼åŸŸå¤ªå¤§äº†ï¼Œä¸€èˆ¬çš„å¢å¡æ–¯å®šç†è¿˜ä¸èƒ½é€šè¿‡æ­¤é¢˜ã€‚æ‰€ä»¥è¦è¿›è¡Œé¢„å¤„ç†æ¥åŠ å¿«å¢å¡æ–¯å®šç†çš„è®¡ç®—é€Ÿåº¦ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/10/6.
//

#include <vector>
#include <algorithm>
#include <iostream>
#include <array>

using ll = long long;
int P = 1;

struct digit {
	std::vector<int> d;
	int cnt;

	digit() : d(10), cnt(0) {}

	digit(ll x) : d(10), cnt(0) {
		ll tmp = x;
		while (tmp) {
			d[cnt++] = tmp % P;
			tmp /= P;
		}
	}

	void add(const digit& rhs) {
		for (int i = 0; i < std::max(cnt, rhs.cnt); i++) {
			d[i] += rhs.d[i];
			if (d[i] >= P) {
				d[i] -= P;
				d[i + 1]++;
			}
		}
	}
};


int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);
	int n, p;
	std::cin >> n >> p;
	P = 1;
	while (P < 5000)P *= p;
	P /= p;
	std::vector<std::vector<int>> C(P + 1, std::vector<int>(P + 1));
	C[0][0] = 1;
	for (int i = 1; i <= P; ++i) {
		C[i][0] = C[i][i] = 1;
		for (int j = 1; j < P; ++j) {
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % p;
		}
	}
	auto lucas = [&](const digit& n, const digit& m) {
		int s = 1;
		for (int i = 0; i < m.cnt; ++i) {
			s *= C[n.d[i]][m.d[i]] %= p;
		}
		return s;
	};
	std::vector<digit> a(n + 1);
	for (int i = 0; i < n; ++i) {
		ll x;
		std::cin >> x;
		a[i] = digit(x);
	}

	std::vector<int> r(n + 1);
	a[n].cnt = 1;
	int st = 0;
	for (int i = 0; i <= n; i++) {
		if (a[i].cnt) {
			for (int j = i - 1; j >= st; j--)r[j] = i;
			st = i;
		}
	}

	ll ans = 0;
	for (int i = 0; i < n; ++i) {
		int ptr = i;
		digit tmp = a[ptr];
		int cur = 1;
		while (cur && ptr < n) {
			ans += (r[ptr] - ptr) * cur;
			ptr = r[ptr];
			tmp.add(a[ptr]);
			cur *= lucas(tmp, a[ptr]);
			cur %= p;
		}
	}
	std::cout << ans << '\n';
	return 0;
}
```





## æ•°è®º

## 

### åŒæ¨¡å…³ç³»

#### 1.UVA1069

**é¢˜ç›®ç¿»è¯‘**

ç»™ä¸€ä¸ªé¡¹æ•°å°äº100çš„å¤šé¡¹å¼ï¼Œé—®å…¶åœ¨ä»»æ„æ•´æ•°ä¸‹çš„å€¼æ¨¡Dæ˜¯å¦ä¸º0 ã€‚

**é¢˜ç›®åˆ†æ**

éšæœºå–è‹¥å¹²ä¸ªå€¼ï¼Œå¦‚æœè¿™äº›å€¼éƒ½ä»¤å¤šé¡¹å¼çš„å–å€¼éƒ½æ¨¡Dä¸º0ï¼Œé‚£ä¹ˆè¿™ä¸ªå¤šé¡¹å¼å¤§æ¦‚ç‡æ˜¯åœ¨æ¨¡Dæ„ä¹‰ä¸‹ä¸º0çš„ã€‚

é‚£ä¹ˆè€ƒè™‘æŠŠå€¼(1,2,3,4,â€¦.n+1)ç»™å¸¦å…¥æ–¹ç¨‹ï¼Œæ ¹æ®å·®åˆ†æ•°ç»„çš„æ€§è´¨ï¼Œ$f(n+1)-f(n)$ä¸ºä¸€ä¸ªæœ€é«˜æ¬¡é¡¹æ¯”fçš„æœ€é«˜æ¬¡é¡¹å°1çš„å¤šé¡¹å¼ï¼Œé‚£ä¹ˆå¯¹äºné˜¶çš„å¤šé¡¹å¼è®¡ç®—å‡ºæ¥né˜¶çš„å·®åˆ†å³å¯å˜ä¸ºä¸€ä¸ªå¸¸æ•°ï¼Œå› ä¸ºå–æ¨¡å¯¹äºåŠ å‡æ³•æœ‰åˆ†é…ç‡ï¼Œé‚£ä¹ˆå¦‚æœæ‰€æœ‰çš„å·®åˆ†å€¼éƒ½æ¨¡Dä¸º0ï¼Œé‚£ä¹ˆæ•´ä¸ªå¤šé¡¹å¼æ— è®ºå–ä»€ä¹ˆå€¼éƒ½æ¨¡Dä¸º0ã€‚é‚£ä¹ˆå°±å¾—å‡ºäº†åšæ³•ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/9/13.
//
#include <bits/stdc++.h>

using ll = long long;

ll power(ll a, ll b, ll mod) {
    ll ans = 1;
    for (; b; b >>= 1, a = a * a % mod) if (b & 1)ans = a * ans % mod;
    return ans;
}

int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    std::string s;
    int n = 0;
    while (std::cin >> s && s != ".") {
        n++;
        std::cout << "Case " << n;

        auto check = [&](std::string &str) -> bool {
            std::vector<int> a, e;
            std::string poly = str.substr(1, str.find('/') - 2);
            int ptr = 0, n = poly.size();
            while (ptr < n) {
                int sig = 1;
                //sign
                if (poly[ptr] == '+') sig = 1, ptr++;
                if (poly[ptr] == '-') sig = -1, ptr++;

                //è®¡ç®—ç³»æ•°
                int digit = 0;
                while (ptr < n && isdigit(poly[ptr])) digit = digit * 10 + poly[ptr++] - '0';
                //å¸¸æ•°
                if (ptr == n) {
                    a.push_back(digit);
                    e.push_back(0);
                } else {
                    ptr++;
                    if (digit == 0)digit = 1;
                    digit *= sig;
                    int pw = 0;
                    if (poly[ptr] == '^') {
                        ptr++;
                        //ä¸ä¸º1æ¬¡é¡¹k
                        while (ptr < n && isdigit(poly[ptr])) pw = pw * 10 + poly[ptr++] - '0';
                    } else pw = 1;
                    a.push_back(digit);
                    e.push_back(pw);
                }
            }

            int D = stoi(str.substr(str.find('/') + 1));
//            for (int i = 0; i < a.size(); ++i)std::cerr << a[i] << '^' << e[i] << ' ';
            std::cerr << '\n';
            for (int x = 1; x <= e[0] + 1; ++x) {
                ll ans = 0;
                for (int i = 0; i < a.size(); ++i) {
                    ans = (ans + a[i] * power(x, e[i], D) % D) % D;
                }
                if (ans)return false;
            }
            return true;
        };

        if (check(s))std::cout << ": Always an integer\n";
        else std::cout << ": Not always an integer\n";
    }
    return 0;
}
```



### æ¨¡æ–¹ç¨‹

#### 1.CF1728ERed-Black Pepper

**é¢˜ç›®æè¿°**

Monocarp is going to host a party for his friends. He prepared $ n $ dishes and is about to serve them. First, he has to add some powdered pepper to each of them â€” otherwise, the dishes will be pretty tasteless.

The $ i $ -th dish has two values $ a_i $ and $ b_i $ â€” its tastiness with red pepper added or black pepper added, respectively. Monocarp won't add both peppers to any dish, won't add any pepper multiple times, and won't leave any dish without the pepper added.

Before adding the pepper, Monocarp should first purchase the said pepper in some shop. There are $ m $ shops in his local area. The $ j $ -th of them has packages of red pepper sufficient for $ x_j $ servings and packages of black pepper sufficient for $ y_j $ servings.

Monocarp goes to exactly one shop, purchases multiple (possibly, zero) packages of each pepper in such a way that each dish will get the pepper added once, and no pepper is left. More formally, if he purchases $ x $ red pepper packages and $ y $ black pepper packages, then $ x $ and $ y $ should be non-negative and $ x \cdot x_j + y \cdot y_j $ should be equal to $ n $ .

For each shop, determine the maximum total tastiness of the dishes after Monocarp buys pepper packages only in this shop and adds the pepper to the dishes. If it's impossible to purchase the packages in the said way, print -1.

**è¾“å…¥æ ¼å¼**

The first line contains a single integer $ n $ ( $ 1 \le n \le 3 \cdot 10^5 $ ) â€” the number of dishes.

The $ i $ -th of the next $ n $ lines contains two integers $ a_i $ and $ b_i $ ( $ 1 \le a_i, b_i \le 10^9 $ ) â€” the tastiness of the $ i $ -th dish with red pepper added or black pepper added, respectively.

The next line contains a single integer $ m $ ( $ 1 \le m \le 3 \cdot 10^5 $ ) â€” the number of shops.

The $ j $ -th of the next $ m $ lines contains two integers $ x_j $ and $ y_j $ ( $ 1 \le x_j, y_j \le n $ ) â€” the number of servings the red and the black pepper packages are sufficient for in the $ j $ -th shop, respectively.

**è¾“å‡ºæ ¼å¼**

Print $ m $ integers. For each shop, print the maximum total tastiness of the dishes after Monocarp buys pepper packages only in this shop and adds the pepper to the dishes. If it's impossible to purchase the packages so that each dish will get the pepper added once and no pepper is left, print -1.

**é¢˜ç›®ç¿»è¯‘**

æœ‰né“èœï¼Œ å¯¹äºç¬¬ié“èœåŠ å…¥ä¸€ä»½aä½æ–™æœ‰$a[i]$çš„ä»·å€¼ï¼ŒåŠ å…¥ä¸€ä»½bæœ‰$b[i]$çš„ä»·å€¼ï¼Œæ¯é“èœåªèƒ½åŠ å…¥ä¸€ä»½ä½æ–™ã€‚ç°åœ¨æœ‰mä¸ªå•†åº—ï¼Œæ¯ä¸ªå•†åº—éƒ½æŒ‰ç“¶å”®å–ä½æ–™ï¼Œä¸€ä¸ªç“¶ä¸­åªèƒ½æœ‰ä½æ–™aæˆ–è€…ä½æ–™bï¼Œä¸€ç“¶ä½æ–™aæœ‰xä»½ï¼Œä¸€ç“¶ä½æ–™ä½æ–™bæœ‰yä»½ï¼Œè´­ä¹°çš„ä½æ–™å¿…é¡»å®Œå…¨ç”¨å®Œã€‚æ±‚åˆ†åˆ«åœ¨æ¯ä¸ªå•†åº—è´­ä¹°ä½æ–™èƒ½è·å¾—ä»·å€¼çš„æœ€å¤§å€¼ï¼Œå¦‚æœä¸èƒ½è¾“å‡º-1ã€‚

**é¢˜ç›®åˆ†æ**

å¯¹æ¯ä¸ªå•†åº—ä¸€çœ¼å°±èƒ½åˆ—å‡ºä¸å®šæ–¹ç¨‹ç»„$ax+by=n$,å¦‚æœæœ‰è§£ï¼Œæœ‰açš„é€šè§£ï¼š$a0+lcm(x,y)*k$,é‚£ä¹ˆå¯ä»¥ç®—å‡ºæ¥açš„å–å€¼åœ¨ä¸€ä¸ªèŒƒå›´ï¼Œè€Œä¸”é—´éš”éƒ½æ˜¯lcmï¼Œé‚£ä¹ˆå…ˆé¢„å¤„ç†å‡ºæ¥é€‰æ‹©ié“èœåŠ å…¥ä½æ–™aï¼Œn-ié“èœåŠ å…¥ä½æ–™bçš„æœ€å¤§ä»·å€¼ï¼Œå¯ä»¥å‘ç°ï¼Œé€‰æ‹©ié“èœåŠ å…¥ä½æ–™açš„ä»·å€¼è‚¯å®šæ˜¯ä¸ªå•å³°å‡½æ•°ï¼Œè€Œaçš„å–å€¼èŒƒå›´ä¹Ÿå·²çŸ¥ï¼Œé‚£ä¹ˆå¯ä»¥é€šè¿‡äºŒåˆ†æ±‚è§£ï¼Œæˆ–è€…ç›´æ¥åˆ¤æ–­åœ¨å³°ä¸¤ä¾§çš„å€¼å’Œå–å€¼èŒƒå›´ä¸¤ç«¯çš„æœ€å¤§å€¼ã€‚

**ä»£ç **

```c++
#include <bits/stdc++.h>

using ll = long long;

long long exgcd(long long a, long long b, long long &x, long long &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    ll d = exgcd(b, a % b, x, y);
    ll t = x;
    x = y;
    y = t - a / b * x;
    return d;
}

void sol() {
    int n;
    std::cin >> n;
    std::vector<int> diff(n);
    long long sum = 0;
    for (int i = 0; i < n; ++i) {
        int a, b;
        std::cin >> a >> b;
        diff[i] = a - b;
        sum += b;
    }
    std::sort(diff.begin(), diff.end(), std::greater());
    std::vector<long long> pref(n + 1);
    for (int i = 1; i <= n; ++i)pref[i] = pref[i - 1] + diff[i - 1];
    long long big = std::max_element(pref.begin(), pref.end()) - pref.begin();

    int m;
    std::cin >> m;
    while (m--) {
        int x, y;
        std::cin >> x >> y;

        long long a, b;
        long long g = exgcd(x, y, a, b);
        if (n % g) {
            std::cout << -1 << "\n";
            continue;
        }
        a = a * (n / g) % (y / g);
        if (a < 0) a += y / g;

        if (1LL * x * a > n) {
            std::cout << -1 << "\n";
            continue;
        }

        long long lcm = x * y / g;
        long long lef = x * a;
        long long rig = n - (n - x * a) % lcm;

        long long ans = std::max(pref[lef], pref[rig]);
        if (big >= lef && big <= rig) {
            int l = big - (big - lef) % lcm;
            int r = big + (rig - big) % lcm;
            ans = std::max({ans, pref[l], pref[r]});
        }
        std::cout << ans + sum << "\n";
    }
}

int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    sol();
    return 0;
}
```

#### 2.UVA11754 Code Feat

**é¢˜ç›®æè¿°**



![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA11754/32298c9e57055dfda9f1f95dd26a078fe1e03f37.png)

**è¾“å…¥æ ¼å¼**

![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA11754/7116a0bc6bf56a48f9df3e293b782181c6fee335.png)

**è¾“å‡ºæ ¼å¼**

![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA11754/264a0de69cadb63313cdf5409291cd6946776de2.png)

**é¢˜ç›®åˆ†æ**

å¦‚æœå¯¹äºæ‰€æœ‰çš„xåªæœ‰ä¸€ä¸ªyé‚£ä¹ˆå…¶ä¸ºä¸€ä¸ªä¸­å›½å‰©ä½™å®šç†æ¿å­é¢˜ï¼Œæ³¨æ„åˆ°ï¼Œå¦‚æœkå¾ˆå°çš„æ—¶å€™ç›´æ¥è¿›è¡Œæš´åŠ›æšä¸¾+ä¸­å›½å‰©ä½™å®šç†å³å¯ï¼Œå¦‚æœkå¾ˆå¤§çš„æ—¶å€™ï¼Œé‚£ä¹ˆå¦‚æœå–ä¸€ä¸ªxå–å€¼ï¼Œåˆ†åˆ«éªŒè¯å…¶æ¨¡æ„ä¹‰ä¸‹å…¶ä»–çº¦æŸæ¡ä»¶çš„æ­£ç¡®æ€§ï¼Œå› ä¸ºså¾ˆå°æ‰€ä»¥å¯ä»¥å¾ˆå¿«ç®—å‡ºæ¥ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/9/13.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
std::array<T, 3> exgcd(T a, T b) {
    if (b == 0)return {a, 1, 0};
    auto [g, x, y] = exgcd(b, a % b);
    return {g, y, x - a / b * y};
};

void sol(int n, int c) {
    std::vector<ll> m(n), a(n);
    std::vector<ll> solution;
    std::vector<std::vector<int>> g(n);
    ll LCM = 1;

    auto crt = [&](ll n) {
        ll ret = 0;
        for (int i = 0; i < n; ++i) {
            ll w = LCM / m[i];
            auto [g, x, y] = exgcd(w, (ll) m[i]);
            ret = (ret + x * w * a[i]) % LCM;
        }
        return ret;
    };
    std::function<void(int)> dfs = [&](int dep) {
        if (dep == n) {
            solution.push_back(crt(n));
        } else {
            for (int j = 0; j < g[dep].size(); ++j) {
                a[dep] = g[dep][j];
                dfs(dep + 1);
            }
        }
    };
    ll tot = 1, bestc = 0;
    for (int i = 0; i < n; ++i) {
        int k;
        std::cin >> m[i] >> k;
        tot *= k;
        g[i].resize(k);
        for (int j = 0; j < k; ++j) std::cin >> g[i][j];
        std::sort(g[i].begin(), g[i].end());
        if (m[bestc] * g[i].size() <= m[i] * g[bestc].size())bestc = i;
    }
    if (tot > 1e4) {
        std::vector<std::set<ll>> mp(n);
        for (int i = 0; i < n; ++i) {
            if (i != bestc) {
                for (int j = 0; j < g[i].size(); ++j) {
                    mp[i].insert(g[i][j]);
                }
            }
        }

        for (int k = 0;; k++) {
            for (int j = 0; j < g[bestc].size(); ++j) {
                ll cur = k * m[bestc] + g[bestc][j];
                if (cur == 0)continue;
                bool ok = true;
                for (int i = 0; i < n; ++i) {
                    if (i == bestc)continue;
                    if (!mp[i].count(cur % m[i])) {
                        ok = false;
                        break;
                    }
                }
                if (ok) {
                    std::cout << cur << '\n';
                    if (--c == 0)return;
                }
            }
        }
    } else {
        for (int i = 0; i < n; ++i)LCM *= m[i];
        dfs(0);
        std::sort(solution.begin(), solution.end());
        for (int i = 0;; ++i) {
            for (long long X: solution) {
                ll cur = i * LCM + X;
                if (cur > 0) {
                    std::cout << cur << '\n';
                    if (--c == 0)return;
                }
            }
        }
    }
}

int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int n, c;
    while (std::cin >> n >> c && n + c) {
        sol(n, c);
        std::cout << '\n';
    }
}
```



#### Emoogle Grid

**é¢˜é¢ç¿»è¯‘**

ç»™ä¸€ä¸ª $M$ è¡Œ $N$ åˆ—çš„ç½‘æ ¼æ¶‚ä¸Š $K$ ç§é¢œè‰²ï¼Œå…¶ä¸­æœ‰ $B$ ä¸ªæ ¼å­ä¸ç”¨æ¶‚è‰²ï¼Œå…¶ä»–æ¯ä¸ªæ ¼å­æ¶‚ä¸€ç§é¢œè‰²ï¼ŒåŒä¸€åˆ—ä¸­çš„ä¸Šä¸‹ä¸¤ä¸ªç›¸é‚»æ ¼å­ä¸èƒ½æ¶‚ç›¸åŒé¢œè‰²ã€‚

ç»™å‡ºæ¶‚è‰²æ–¹æ¡ˆ$\mod 100000007$ çš„ç»“æœ$R,N,K,B$ ä¸ªæ ¼å­çš„ä½ç½®ï¼Œæ±‚å‡ºæœ€å°çš„ $M$ ã€‚

$1\le M,N\le 10^8$

$0\le B\le500$

$2\le K\le10^8$

**è¾“å…¥æ ¼å¼**

è¾“å…¥ç¬¬ä¸€è¡Œä¸ºæ•°æ®ç»„æ•° $T(T\le150)$ ã€‚æ¯ç»„æ•°æ®ç¬¬ä¸€è¡Œä¸º $4$ ä¸ªæ•´æ•° $N,K,B,R(0\le R\le100000007)$ ã€‚ä»¥ä¸‹ $B$ è¡Œæ¯è¡Œä¸ºä¸¤ä¸ªæ•´æ•° $x$ å’Œ $y(1\le x\le M,1\le y\le N)$ ï¼Œå³æ¯ä¸ªä¸éœ€è¦æ¶‚è‰²çš„æ ¼å­çš„è¡Œåˆ—ç¼–å·ã€‚è¿™äº›æ ¼å­çš„ä½ç½®å„ä¸ç›¸åŒã€‚

**è¾“å‡ºæ ¼å¼**

å¯¹äºæ¯ç»„æ•°æ®ï¼Œè¾“å‡ºæœ€å°çš„ $M$ ã€‚è¾“å…¥ä¿è¯ä¸€å®šæœ‰è§£ã€‚

**é¢˜ç›®åˆ†æ**

å¯¹äºä¸€ä¸ªç½‘æ ¼çº¸è€Œè¨€ï¼Œå…¶å¯ä»¥è¢«åˆ’åˆ†ä¸ºä¸¤å—ï¼Œä¸€å—ä¸ºé™åˆ¶ç‚¹çš„åŒºåŸŸï¼Œå¦ä¸€å—ä¸ºæ²¡æœ‰ä»»ä½•é™åˆ¶çš„åŒºåŸŸï¼Œé‚£ä¹ˆé¦–å…ˆç®—å‡ºæ¥æœ‰é™åˆ¶çš„åŒºåŸŸçš„æ¶‚è‰²æ–¹æ¡ˆï¼Œç„¶åæ²¡æœ‰é™åˆ¶çš„åŒºåŸŸæ¯ä¸€è¡Œæ‰€æ„æˆçš„æ–¹æ¡ˆéƒ½æ˜¯$(k-1)^m$ï¼Œç„¶åå°±æ˜¯ä¸€ä¸ªé«˜æ¬¡åŒä½™æ–¹ç¨‹äº†ã€‚

è›‹tmdä¸€å¼€å§‹ä¸çŸ¥é“ä¸ºä»€ä¹ˆtleäº†é‚£ä¹ˆå¤šå‘

**ä»£ç **

```c++
//
// Created by mrx on 2022/9/14.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T power(T a, int b) {
	T ans = 1;
	for (; b; a *= a, b >>= 1) {
		if (b & 1)ans *= a;
	}
	return ans;
}

template<typename T>
T inverse(T a, T b) {
	return power(a, b - 2);
}

template<int Mod>
class Modular {
public:
	using Type = int;

	template<typename U>
	static Type norm(U& x) {
		Type v;
		if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
		else v = static_cast<Type>(x % Mod);
		if (v < 0) v += Mod;
		return v;
	}

	constexpr Modular() : value() {}

	int val() const { return value; }

	Modular inv() const {
		return Modular(inverse(value, Mod));
	}

	template<typename U>
	Modular(const U& x) {
		value = norm(x);
	}

	const Type& operator()() const {
		return value;
	}

	template<typename U>
	explicit operator U() const {
		return static_cast<U>(value);
	}

	Modular& operator+=(const Modular& other) {
		if ((value += other.value) >= Mod) value -= Mod;
		return *this;
	}

	Modular& operator-=(
			const Modular& other) {
		if ((value -= other.value) < 0) value += Mod;
		return *this;
	}

	template<typename U>
	Modular& operator+=(const U& other) { return *this += Modular(other); }

	template<typename U>
	Modular& operator-=(const U& other) { return *this -= Modular(other); }

	Modular& operator++() { return *this += 1; }

	Modular& operator--() { return *this -= 1; }

	Modular operator++(int) {
		Modular result(*this);
		*this += 1;
		return result;
	}

	Modular operator--(int) {
		Modular result(*this);
		*this -= 1;
		return result;
	}

	Modular operator-() const { return Modular(-value); }

	template<class ISTREAM_TYPE>
	friend ISTREAM_TYPE& operator>>(ISTREAM_TYPE& is, Modular& rhs) {
		ll v;
		is >> v;
		rhs = Modular(v);
		return is;
	}

	template<class OSTREAM_TYPE>
	friend OSTREAM_TYPE& operator<<(OSTREAM_TYPE& os, const Modular& rhs) {
		return os << rhs.val();
	}

	Modular& operator*=(const Modular& rhs) {
		value = ll(value) * rhs.value % Mod;
		return *this;
	}

	Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, Mod)); }

	friend const Type& abs(const Modular& x) { return x.value; }


	friend bool operator<(const Modular& lhs, const Modular& rhs) { return lhs.value < rhs.value; }


	bool operator==(const Modular& rhs) { return this->value == rhs.value; }

	template<typename U>
	bool operator==(U rhs) const { return *this == Modular(rhs); }

	template<typename U>
	friend bool operator==(U lhs, const Modular& rhs) { return Modular(lhs) == rhs; }

	bool operator!=(const Modular& rhs) { return *this != rhs; }

	template<typename U>
	bool operator!=(U rhs) { return *this != rhs; }

	template<typename U>
	friend bool operator!=(U lhs, const Modular& rhs) { return lhs != rhs; }

	bool operator<(const Modular& rhs) { return this->value < rhs.value; }

	Modular operator+(const Modular& rhs) { return Modular(*this) += rhs; }

	template<typename U>
	Modular operator+(U rhs) { return Modular(*this) += rhs; }

	template<typename U>
	friend Modular operator+(U lhs, const Modular& rhs) { return Modular(lhs) += rhs; }

	Modular operator-(const Modular& rhs) { return Modular(*this) -= rhs; }

	template<typename U>
	Modular operator-(U rhs) { return Modular(*this) -= rhs; }

	template<typename U>
	friend Modular operator-(U lhs, const Modular& rhs) { return Modular(lhs) -= rhs; }

	Modular operator*(const Modular& rhs) { return Modular(*this) *= rhs; }

	template<typename U>
	Modular operator*(U rhs) { return Modular(*this) *= rhs; }

	template<typename U>
	friend Modular operator*(U lhs, const Modular& rhs) { return Modular(lhs) *= rhs; }

	Modular operator/(const Modular& rhs) { return Modular(*this) /= rhs; }

	template<typename U>
	Modular operator/(U rhs) { return Modular(*this) /= rhs; }

	template<typename U>
	friend Modular operator/(U lhs, const Modular& rhs) { return Modular(lhs) /= rhs; }

private:
	Type value;
};

constexpr int mod = 1e8 + 7;
using Z = Modular<mod>;

int bsgs(Z a, Z b) {
	std::map<Z, int> hash;
	int m = std::sqrt(mod) + 0.5;
	Z cur = 1;
	Z inv = 1 / power(a, m);
	hash[cur] = 0;
	for (int i = 1; i < m; ++i) {
		cur *= a;
		if (!hash.count(cur))hash[cur] = i;
	}

	for (int i = 0; i < m; ++i) {
		if (hash.count(b))return i * m + hash[b];
		b *= inv;
	}
	return -1;
}

int main() {
#ifdef LOCAL
	freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);
#endif
	int t;
	std::cin >> t;
	for (int cas = 1; cas <= t; ++cas) {
		std::cout << "Case " << cas << ": ";
		int n, k, b;
		Z r;
		std::cin >> n >> k >> b >> r;
		std::vector<int> x(b), y(b);
		std::set<std::pair<int, int>> ban;
		int m = 1;
		for (int i = 0; i < b; ++i) {
			std::cin >> x[i] >> y[i];
			m = std::max(x[i], m);
			ban.emplace(x[i], y[i]);
		}

		int cnt = n;
		for (int i = 0; i < b; ++i) {
			if (x[i] != m && !ban.count({x[i] + 1, y[i]}))cnt++;
			if (x[i] == 1)cnt--;
		}
		Z p = power(Z(k), cnt);
		p *= power(Z(k - 1), 1ll * n * m - b - cnt);

		if (r == p) {
			std::cout << m << '\n';
		} else {
			cnt = 0;
			for (int i = 0; i < b; ++i) if (x[i] == m)cnt++;
			m++;
			p *= power(Z(k), cnt) * power(Z(k - 1), n - cnt);

			if (p == r) std::cout << m << '\n';
			else {
				std::cout << bsgs(power(Z(k - 1), n), r / p) + m << '\n';
			}
		}
	}
	return 0;
}
```





### è«å

#### 1.3455 ZAP-Queries

**é¢˜ç›®æè¿°**

å¯†ç å­¦å®¶æ­£åœ¨å°è¯•ç ´è§£ä¸€ç§å« BSA çš„å¯†ç ã€‚

ä»–å‘ç°ï¼Œåœ¨ç ´è§£ä¸€æ¡æ¶ˆæ¯çš„åŒæ—¶ï¼Œä»–è¿˜éœ€è¦å›ç­”è¿™æ ·ä¸€ç§é—®é¢˜ï¼š

ç»™å‡º $a,b,d$ï¼Œæ±‚æ»¡è¶³ $1 \leq x \leq a$ï¼Œ$1 \leq y \leq b$ï¼Œä¸” å…ƒç»„ $(x,y)$ çš„æ•°é‡ã€‚

å› ä¸ºè¦è§£å†³çš„é—®é¢˜å®åœ¨å¤ªå¤šäº†ï¼Œä»–ä¾¿è¿‡æ¥å¯»æ±‚ä½ çš„å¸®åŠ©ã€‚

**é¢˜ç›®åˆ†æ**

é¢˜ç›®å³æ±‚$\sum\limits^a_{i=1}\sum \limits_{j=1}^bgcd(i,j)=d$

è€ƒè™‘è«æ¯”ä¹Œæ–¯åæ¼”ï¼Œ$[gcd(i,j)=1]=\sum\limits_{ gcd(i,j)\mid d}\mu (d)$é‚£ä¹ˆé¢˜ç›®æ‰€æ±‚å€¼å¯ä»¥å˜ä¸º$\sum\limits_{i=1}^{a/d}\sum\limits_{j=1}^{b/d}\sum\limits_{gcd(i,j)\mid k}\mu (k)$ï¼Œé‚£ä¹ˆæŠŠkæå–åˆ°å‰é¢ï¼Œå¾—åˆ°ï¼š$\sum\limits_{k=1}^{\frac{a}{d}}\sum\limits_{i=1}^{\frac{a}{d}}\sum\limits_{j=1}^{\frac {b}{d}}[k\mid gcd(i,j)]*\mu (k)$æå–å‡º$\sum\limits_{k=1}^{\frac{a}{d}}\mu (k)\sum\limits_{i=1}^{\frac{a}{d}}\sum\limits_{j=1}^{\frac {b}{d}}[k\mid gcd(i,j)]$,æ ¹æ®gcdçš„æ€§è´¨ï¼Œåªæœ‰å½“$i,jéƒ½æ˜¯kçš„å€æ•°çš„æ—¶å€™[k\mid gcd(i,j)]=1$,é‚£ä¹ˆä¸Šå¼å˜ä¸º$\sum\limits_{k=1}^{\frac{a}{d}}\mu (k)\sum\limits_{i=1}^{\frac{a}{kd}}\sum\limits_{j=1}^{\frac {b}{kd}}1=\sum\limits_{k=1}^{\frac{a}{d}}\mu (k)\frac{a}{kd}\frac {b}{kd}$è¦çƒè¿™ä¸ªå¼å­ï¼Œå°±å¯ä»¥è¿›è¡Œæ•´é™¤åˆ†å—ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/9/8.
//
#include <bits/stdc++.h>

using ll = long long;


int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif

    std::vector<int> prime, vis(1e6 + 10), mu(1e6 + 10);
    mu[1] = 1;
    for (int i = 2; i <= 1e6; ++i) {
        if (!vis[i]) {
            mu[i] = -1;
            prime.push_back(i);
        }
        for (int j = 0; j < prime.size() && i * prime[j] <= 1e6; ++j) {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            } else {
                mu[i * prime[j]] = -mu[i];
            }
        }
    }
    std::vector<int> sum(1e6 + 10, 0);
    for (int i = 1; i <= 1e6; ++i) {
        sum[i] = sum[i - 1] + mu[i];
    }

    int t;
    std::cin >> t;
    while (t--) {
    long long a, b, d;
    std::cin >> a >> b >> d;
    long long ans = 0;
    a /= d, b /= d;
    for (long long l = 1, r; l <= std::min(a, b); l = r + 1) {
        r = std::min(b / (b / l), a / (a / l));
        ans += (a / l) * (b / l) * (sum[r] - sum[l - 1]);

    }
    std::cout << ans << '\n';
    }

    return 0;
}
```

#### 2.2522Problem b

**é¢˜ç›®æè¿°**

å¯¹äºç»™å‡ºçš„ $n$ ä¸ªè¯¢é—®ï¼Œæ¯æ¬¡æ±‚æœ‰å¤šå°‘ä¸ªæ•°å¯¹ $(x,y)$ï¼Œæ»¡è¶³ $a \le x \le b$ï¼Œ$c \le y \le d$ï¼Œä¸” $\gcd(x,y) = k$ï¼Œ$\gcd(x,y)$ å‡½æ•°ä¸º $x$ å’Œ $y$ çš„æœ€å¤§å…¬çº¦æ•°ã€‚

**è¾“å…¥æ ¼å¼**

ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•° $n$ï¼Œæ¥ä¸‹æ¥ $n$ è¡Œæ¯è¡Œäº”ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«è¡¨ç¤º $a,b,c,d,k$ã€‚

**è¾“å‡ºæ ¼å¼**

å…± $n$ è¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ•´æ•°è¡¨ç¤ºæ»¡è¶³è¦æ±‚çš„æ•°å¯¹ $(x,y)$ çš„ä¸ªæ•°ã€‚

**é¢˜ç›®åˆ†æ**

é€šè¿‡è«åå¯ä»¥æ±‚å‡ºæ¥$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}gcd(i,j)=k$ï¼Œé‚£ä¹ˆè€ƒè™‘å®¹æ–¥ï¼Œå…¶ç­”æ¡ˆä¸ºå¤§é›†åˆå‡å»å«æœ‰ä¸€æ®µçš„å†åŠ ä¸Šå«ä¸¤æ®µçš„ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/9/8.
//
#include <bits/stdc++.h>

using ll = long long;


int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif

    std::vector<int> prime, vis(1e6 + 10), mu(1e6 + 10);
    mu[1] = 1;
    for (int i = 2; i <= 1e6; ++i) {
        if (!vis[i]) {
            mu[i] = -1;
            prime.push_back(i);
        }
        for (int j = 0; j < prime.size() && i * prime[j] <= 1e6; ++j) {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            } else {
                mu[i * prime[j]] = -mu[i];
            }
        }
    }
    std::vector<int> sum(1e6 + 10, 0);
    for (int i = 1; i <= 1e6; ++i) {
        sum[i] = sum[i - 1] + mu[i];
    }

    int t;
    std::cin >> t;
    while (t--) {
    long long a, b, d;
    std::cin >> a >> b >> d;
    long long ans = 0;
    a /= d, b /= d;
    for (long long l = 1, r; l <= std::min(a, b); l = r + 1) {
        r = std::min(b / (b / l), a / (a / l));
        ans += (a / l) * (b / l) * (sum[r] - sum[l - 1]);

    }
    std::cout << ans << '\n';
    }

    return 0;
}
```

#### 3.1829 [å›½å®¶é›†è®­é˜Ÿ]Crashçš„æ•°å­—è¡¨æ ¼ / JZPTAB

**é¢˜ç›®æè¿°**

ä»Šå¤©çš„æ•°å­¦è¯¾ä¸Šï¼ŒCrash å°æœ‹å‹å­¦ä¹ äº†æœ€å°å…¬å€æ•°ï¼ˆLeast Common Multipleï¼‰ã€‚å¯¹äºä¸¤ä¸ªæ­£æ•´æ•° $a$ å’Œ $b$ï¼Œ$\text{lcm}(a,b)$ è¡¨ç¤ºèƒ½åŒæ—¶æ•´é™¤ $a$ å’Œ $b$ çš„æœ€å°æ­£æ•´æ•°ã€‚ä¾‹å¦‚ï¼Œ$\text{lcm}(6, 8) = 24$ã€‚

å›åˆ°å®¶åï¼ŒCrash è¿˜åœ¨æƒ³ç€è¯¾ä¸Šå­¦çš„ä¸œè¥¿ï¼Œä¸ºäº†ç ”ç©¶æœ€å°å…¬å€æ•°ï¼Œä»–ç”»äº†ä¸€å¼  $ n \times m$ çš„è¡¨æ ¼ã€‚æ¯ä¸ªæ ¼å­é‡Œå†™äº†ä¸€ä¸ªæ•°å­—ï¼Œå…¶ä¸­ç¬¬ $i$ è¡Œç¬¬ $j$ åˆ—çš„é‚£ä¸ªæ ¼å­é‡Œå†™ç€æ•°ä¸º $\text{lcm}(i, j)$ã€‚

çœ‹ç€è¿™ä¸ªè¡¨æ ¼ï¼ŒCrash æƒ³åˆ°äº†å¾ˆå¤šå¯ä»¥æ€è€ƒçš„é—®é¢˜ã€‚ä¸è¿‡ä»–æœ€æƒ³è§£å†³çš„é—®é¢˜å´æ˜¯ä¸€ä¸ªååˆ†ç®€å•çš„é—®é¢˜ï¼šè¿™ä¸ªè¡¨æ ¼ä¸­æ‰€æœ‰æ•°çš„å’Œæ˜¯å¤šå°‘ã€‚å½“ $n$ å’Œ $m$ å¾ˆå¤§æ—¶ï¼ŒCrash å°±æŸæ‰‹æ— ç­–äº†ï¼Œå› æ­¤ä»–æ‰¾åˆ°äº†èªæ˜çš„ä½ ç”¨ç¨‹åºå¸®ä»–è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ç”±äºæœ€ç»ˆç»“æœå¯èƒ½ä¼šå¾ˆå¤§ï¼ŒCrash åªæƒ³çŸ¥é“è¡¨æ ¼é‡Œæ‰€æœ‰æ•°çš„å’Œ $\bmod 20101009$ çš„å€¼ã€‚

è¾“å…¥æ ¼å¼

è¾“å…¥åŒ…å«ä¸€è¡Œä¸¤ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«è¡¨ç¤º $n$ å’Œ $m$ã€‚

è¾“å‡ºæ ¼å¼

è¾“å‡ºä¸€ä¸ªæ­£æ•´æ•°ï¼Œè¡¨ç¤ºè¡¨æ ¼ä¸­æ‰€æœ‰æ•°çš„å’Œ $\bmod 20101009$çš„å€¼ã€‚

**é¢˜ç›®åˆ†æ**

åŸå¼å¯ä»¥è¡¨ç¤ºä¸º$\sum\limits_{i=1}^n\sum\limits_{j=1}^mlcm(i,j)$ï¼Œè¿›è¡Œæ¨å¼å­ï¼Œ$\sum\limits_{i=1}^n\sum\limits_{j=1}^m \frac{i*j}{gcd(i,j)}$è½¬æ¢ä¸ºæšä¸¾å…¬å…±å› å­,ä¸º$\sum\limits_{d=1}^{min(n,m)}\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d} d*i*j[gcd(i,j)=1]$ ç„¶åå°±èƒ½è¿›è¡Œè«æ¯”ä¹Œæ–¯åæ¼”ï¼Œå˜ä¸º$\sum\limits_{d=1}^{min(n,m)}d\cdot \sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d} i*j[gcd(i,j)=1]$

#### 4.HDU4746 Mophues

**é¢˜ç›®æè¿°**

ç»™$Q(1\le Q\le 5000)$ä¸ªè¯¢é—®ï¼Œæ¯ä¸ªè¯¢é—®ç»™å‡º$n,m,p$æ±‚$\sum\limits_{i=1}^N\sum\limits_{j=1}^M[h(gcd(i,j))<=p]$ã€‚

**é¢˜ç›®åˆ†æ**

å› ä¸ºæŠŠæ•°æ®èŒƒå›´å†…çš„æ•°å­—åˆ†è§£ï¼Œpæœ€å¤šä¸º19ï¼Œé‚£ä¹ˆ$18\le p$æ—¶ç›´æ¥è¾“å‡º$n*m$ï¼Œå¯¹äºå¦ä¸€ç§æƒ…å†µï¼Œä»¤$f(x)=\sum\limits_{i=1}^N\sum\limits_{j=1}^M[gcd(i,j)=x]$,é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯$\sum\limits_{1\le x\le n,h(x)\le p}f(x)$,è¦æ±‚$f(x)$ï¼Œè€ƒè™‘è«æ¯”ä¹Œæ–¯åæ¼”ï¼Œå®šä¹‰$g(x)=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^m[x|gcd(i,j)]$ï¼Œæ˜“å¾—æ‰€æœ‰çš„$i,j$ä¸ºxçš„å€æ•°ï¼Œé‚£å°±å¾ˆå®¹æ˜“æ±‚å‡ºæ¥$g(x)=\frac{n}{x}\frac{m}{x}$ï¼ŒåŒæ—¶æœ‰$g(x)=\sum\limits_{x|y}f(y)$,é€šè¿‡å€æ•°å½¢å¼çš„è«åå¾—åˆ°$f(x)=\sum\limits_{x|y}\mu(y/x)*g(y)=\sum\limits_{x|y}\mu(y/x)(n/y)*(m/y)$.é‚£ä¹ˆç­”æ¡ˆä¸º
$$
\sum\limits_{1\le x\le n,h(x)\le p}\sum\limits_{x|y}\mu(y/x)(n/y)(m/y)
\\=\sum\limits_{1\le x\le n,h(x)\le p}\ \sum\limits_{1\le k\le n/x}\mu(k)(n/xk)(m/xk)
\\=\sum\limits_{1\le x\le n,h(x)\le p}\  \sum\limits_{1\le  k\le n/x}\mu(k)(n/xk)(m/xk)
\\äº¤æ¢æ±‚å’Œé¡ºåº
\\=\sum\limits_{1\le T\le n}(n/T)(m/T) \sum\limits_{x|T}\mu(T/x)[h(x)\le p]
$$
ç„¶åé€šè¿‡ä¸€äº›å¦™å“‡çš„ç­›æ³•æ±‚å‡ºæ¥åé¢çš„ä¸€å¨ä¸œè¥¿ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/9/24.
//

#include <vector>
#include <algorithm>
#include <iostream>
#include <array>

using ll = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	std::vector<int> prime, vis(5e5 + 10), mu(5e5 + 10), h(5e5 + 10);
	mu[1] = 1, h[1] = 0;
	for (int i = 2; i <= 5e5; ++i) {
		if (!vis[i])prime.push_back(i), mu[i] = -1, h[i] = 1;
		for (int j = 0; j < prime.size() && i * prime[j] <= 5e5; ++j) {
			vis[i * prime[j]] = 1;
			h[prime[j] * i] = h[i] + 1;
			if (i % prime[j]) {
				mu[i * prime[j]] = -mu[i];
			} else {
				mu[i * prime[j]] = 0;
				break;
			}
		}
	}

	std::vector<std::array<ll, 20>> pref(5e5 + 10);
	for (int i = 1; i <= 5e5; ++i) {
		for (int k = 1; i * k <= 5e5; k++) {
			pref[i * k][h[i]] += mu[k];
		}
	}

	for (int i = 0; i <= 5e5; ++i) for (int j = 1; j < 20; ++j)pref[i][j] += pref[i][j - 1];
	for (int i = 1; i < 5e5; ++i)for (int j = 0; j < 20; ++j)pref[i][j] += pref[i - 1][j];

	int q;
	std::cin >> q;
	while (q--) {
		ll n, m, p;
		std::cin >> n >> m >> p;
		if (p >= 18) {
			std::cout << n * m << '\n';
		} else {
			if (n > m)std::swap(n, m);
			ll ans = 0;
			for (ll l = 1, r; l <= n; l = r + 1) {
				r = std::min(n / (n / l), m / (m / l));
				ans += (pref[r][p] - pref[l - 1][p]) * (n / l) * (m / l);
			}
			std::cout << ans << '\n';

		}
	}
	return 0;
}
```



#### 5.SP7001VLATTICE - Visible Lattice Points

**é¢˜é¢ç¿»è¯‘**

ç»™å®šä¸€ä¸ª  $N \times N \times N$ çš„ç«‹æ–¹ä½“ï¼Œç‚¹çš„ç¼–å·åˆ†åˆ«ä»  $(0,0,0)$ åˆ°  $(N,N,N)$ã€‚

æ±‚æœ‰å¤šå°‘ä¸ªç‚¹ä»ç‚¹  $(0,0,0)$ å¤„èƒ½çœ‹è§æˆ–ä¸è¢«é®æŒ¡ã€‚

**é¢˜ç›®æè¿°**

Consider a N\*N\*N lattice. One corner is at (0,0,0) and the opposite one is at (N,N,N). How many lattice points are visible from corner at (0,0,0) ? A point X is visible from point Y iff no other lattice point lies on the segment joining X and Y.   

Input :

The first line contains the number of test cases T. The next T lines contain an interger N   

Output :

Output T lines, one corresponding to each test case.   

Sample Input : 
3 
1 
2 
5   

Sample Output : 
7 
19 
175   

Constraints : 
T <= 50 
1 <= N <= 1000000

**é¢˜ç›®åˆ†æ**

ç±»ä¼¼äºäºŒç»´å¹³é¢çš„ç­‰ä»·é—®é¢˜ï¼Œå¯ä»¥å¾—åˆ°é™¤äº†ä¸‰ä¸ªåæ ‡å¹³é¢å†…çš„åˆæ³•ç‚¹ç­”æ¡ˆä¸º$\sum\limits_{i=1}^{N}\sum\limits_{k=1}^{N}\sum\limits_{k=1}^{N}[gcd(i,j,k)=1]$è®°$f(d)$ä¸º$\sum\limits_{i=1}^{N}\sum\limits_{k=1}^{N}\sum\limits_{k=1}^{N}[gcd(i,j,k)=d]$,$g(n)$ä¸º$\sum\limits_{i=1}^{N}\sum\limits_{k=1}^{N}\sum\limits_{k=1}^{N}[n|gcd(i,j,k)]$æ˜“å¾—ï¼Œ $g(n)=(N/n)^3$ï¼Œä¸”$g(n)=\sum\limits_{n|d}f(d)$ã€‚é€šè¿‡å€æ•°å½¢å¼çš„è«æ¯”ä¹Œæ–¯åæ¼”ï¼Œå¯ä»¥å¾—åˆ°$f(n)=\sum\limits_{n|d}\mu(d/n)*g(d)$,ç„¶åå°±èƒ½å¾—åˆ°ç­”æ¡ˆ$f(1)=\sum\limits_{d=1}^{N}\mu(d)*(N/d)^3$,åŒç†ï¼ŒäºŒç»´çš„ç‚¹æ•°ä¸º$3*\sum\limits_{d=1}^{N}\mu(d)*(N/d)^2$ï¼Œä¸€ç»´çš„ç‚¹æ•°ä¸º3ï¼Œé‚£ä¹ˆå°±ç®—å‡ºæ¥äº†ç­”æ¡ˆï¼Œçº¿æ€§æ±‚ä¸€ä¸‹$\mu$å°±è¡Œäº†ã€‚

**ä»£ç **

```c++
//
// Created by meiru on 2022/9/22.
//

#include <bits/stdc++.h>

using ll = long long;


int main() {
#ifdef LOCAL
	freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);
#endif
	std::vector<int> prime, vis(1e6 + 10), mu(1e6 + 10);
	mu[1] = 1;
	for (int i = 2; i <= 1e6; ++i) {
		if (!vis[i]) {
			mu[i] = -1;
			prime.push_back(i);
		}
		for (int j = 0; j < prime.size() && i * prime[j] <= 1e6; ++j) {
			vis[i * prime[j]] = 1;
			if (i % prime[j] == 0) {
				mu[i * prime[j]] = 0;
				break;
			} else mu[i * prime[j]] = mu[i] * -1;
		}
	}

	int t;
	std::cin >> t;
	while (t--) {
		int n;
		std::cin >> n;
		ll ans = 3;
		for (int d = 1; d <= n; ++d) {
			ll k = n / d;
			ans += mu[d] * (k * k * (k + 3));
		}
		std::cout << ans << '\n';
	}
	return 0;
}
```



#### 5.HDU5528Count a * b

**é¢˜ç›®æè¿°**

å®šä¹‰$f(m)$ä¸ºæ»¡è¶³$a*b \nmid m$çš„äºŒå…ƒç»„$(a,b)$çš„ä¸ªæ•°ï¼Œæ±‚$g(n)=\sum\limits_{m\mid n}f(m)$ã€‚

**é¢˜ç›®åˆ†æ**

ç›´æ¥æ±‚å‘ç°éå¸¸çš„ä¸å¥½æ±‚ï¼Œé‚£ä¹ˆæˆ‘ä»¬è€ƒè™‘è¿‚å›æˆ˜æœ¯ï¼Œå¯ä»¥å‘ç°$ m\nmid ab$çš„ä¸ªæ•°æ ¹$m^2-m\mid ab$çš„ä¸ªæ•°ä¸€æ ·ï¼Œé‚£ä¹ˆå°±æŠŠé—®é¢˜è½¬åŒ–æˆäº†$g(n) = \sum\limits_{m|n}m^2-h(m)$ï¼Œ$h(m)$ä¸º$m \mid ab$çš„ä¸ªæ•°ã€‚å› ä¸º$x^2$æ˜¯ä¸€ä¸ªå…¸å‹çš„é¸¡æ€§å‡½æ•°ï¼Œ$\sum\limits_{m\mid  n}m^2 = (1+p_1^2+p_1^4+...p_1^{2k_1})*(1+p_2^2+p_2^4+...p_2^{2k_2})...(1+p_t^2+p_t^4+...p_t^{2k_t})$ï¼Œ
è€ƒè™‘h(x)ï¼Œå¯¹äº$d = gcd(a,m)$è€Œè¨€ï¼Œ$\frac{m}{d} \mid \frac{a}{d} b = \frac{m}{d} \mid b$,å› ä¸ºaæ»¡è¶³ä¸Šè¿°æ¡ä»¶çš„ä¸ªæ•°ä¸º$\varphi(m/d)$é‚£ä¹ˆ$h(m)=\sum\limits_{d\mid m}d\cdot \varphi(m/d)$ï¼Œè¦æ±‚çš„ç­”æ¡ˆå°±æ˜¯$\sum \limits_{m \mid n}\sum\limits_{d\mid m}d\cdot \varphi(m/d)=\sum\limits_{d \mid n}d\sum\limits_{\frac{m}{d} \mid \frac{n}{d}}\varphi(m/d)$æ ¹æ®è«åå…¶ä¸º$\sum\limits_{d \mid n}d \cdot \frac{n}{d}=\sum\limits_{d \mid n} n$ ï¼Œè¿™äº›ä¸œè¥¿éƒ½å¯ä»¥é€šè¿‡è´¨å› æ•°åˆ†è§£è¿›è¡Œæ±‚ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/9/24.
//
#include <vector>
#include <algorithm>
#include <iostream>
#include <array>

using ll = long long;
using ull = unsigned long long;


int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	std::vector<bool> vis(4e4 + 10);
	std::vector<int> prime;
	for (int i = 2; i <= 4e4; ++i) {
		if (!vis[i])prime.push_back(i);
		for (int j = 0; j < prime.size() && i * prime[j] <= 4e4; ++j) {
			vis[i * prime[j]] = true;
			if (i % prime[j] == 0)break;
		}
	}

	int t;
	std::cin >> t;
	while (t--) {
		int n;
		std::cin >> n;
		ull ans1 = 1, ans2 = n;
		int tmp = n;
		for (int i = 0; i < prime.size() && prime[i] * prime[i] <= tmp; ++i) {
			if (tmp % prime[i] == 0) {
				int cnt = 0;
				while (tmp % prime[i] == 0)tmp /= prime[i], cnt++;
				ull cur = 1, base = prime[i] * prime[i];
				for (int j = 0; j < cnt; ++j) {
					cur += base;
					base *= (ull) prime[i] * (ull) prime[i];
				}
				ans1 *= cur;
				ans2 *= cnt + 1;
			}
		}
		if (tmp != 1)ans1 *= (1ull + (ull) tmp * (ull) tmp), ans2 *= 2ull;
		ull ans = ans1 - ans2;
		std::cout << ans << '\n';
	}
	return 0;
}
```

## ç­›æ³•

### çº¿æ€§ç­›

#### 1.P5435 åŸºäºå€¼åŸŸé¢„å¤„ç†çš„å¿«é€Ÿ GCD

**æ€è·¯**

åˆ†å—trickï¼Œæ„Ÿè§‰è·Ÿå…‰é€Ÿå¹‚å·®ä¸å¤š

å¤§é¢˜æ€è·¯æ˜¯æŠŠæ¯ä¸ªæ•°æ‹†æˆ3ä¸ªå°äºæ ¹å·çš„æ•°å­—ä¹‹ä¹˜ç§¯ï¼Œç„¶åé€šè¿‡é¢„å¤„ç†æ ¹å·å€¼åŸŸçš„gcdç„¶åé€šè¿‡è¿™ä¸‰ä¸ªæ•°å­—æ¥O(1)æ±‚gcd

æ€»å¤æ‚åº¦ï¼š$O(å€¼åŸŸ)$é¢„å¤„ç†ï¼Œ$O(1)$æŸ¥è¯¢

**ä»£ç **

```c++
#include <iostream>
#include <numeric>
#include <vector>
#include <array>
#include <algorithm>
#include <cmath>

const int mod = 998244353;

std::vector<int> minp, primes;
std::vector<std::array<int,3>> factors;
void sieve(int n) {
    minp.resize(n + 1);
    factors.resize(n + 1, {1, 1, 1});
    for (int i = 2; i <= n; ++i) {
        if (!minp[i]) {
            minp[i] = i;
            primes.push_back(i);
            factors[i][2] = i;
        }
        for (auto p: primes) {
            if (p * i > n)break;
            minp[i * p] = p;
            factors[i * p] = factors[i];
            factors[i * p][0] *= p;
            std::sort(factors[i * p].begin(), factors[i * p].end());
            if (p == minp[i]) {
                break;
            }
        }
    }
}
void solve() {
    int n;
    std::cin >> n;
    std::vector<int> a(n), b(n);

    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
    }
    
    for (int i = 0; i < n; ++i) {
        std::cin >> b[i];
    }

    int v = std::max(*std::max_element(a.begin(), a.end()), *std::max_element(b.begin(), b.end()));
    int vv = std::sqrt(v) + 1;

    sieve(v);

    std::vector<std::vector<int>> gcd(vv + 1, std::vector<int> (vv + 1));
    for (int i = 1; i <= vv; ++i) gcd[i][0] = gcd[0][i] = i;
    for (int i = 1; i <= vv; ++i) {
        for (int j = 1; j <= i; ++j) {
            gcd[i][j] = gcd[j][i] = gcd[i % j][j];
        }
    }

    auto calc = [&] (int x, int y) {
        int g = 1;
        for (int tmp, i = 0; i < 3; ++i) {
            if (factors[x][i] > vv) {
                if (y % factors[x][i] == 0) {
                    tmp = factors[x][i];
                } else tmp = 1;
            } else {
                tmp = gcd[factors[x][i]][y % factors[x][i]];
            }
            y /= tmp;
            g *= tmp;
        }
        return g;
    };

    for (int i = 0; i < n; ++i) {
        int base = 1, ans = 0;
        for (int j = 0; j < n; ++j) {
            base = 1ll * base * (i + 1) % mod;
            ans = (ans + 1ll * base * calc(a[i], b[j])) % mod;
        }
        std::cout << ans << '\n';
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    solve();
    return 0;
}
```



### æœæ•™ç­›

è¯æ˜ç”±ç‹„åˆ©å…‹é›·å·ç§¯å…¥æ‰‹

è¦æ±‚$S(x) = \sum\limits_{i = 1}^{x}f(i)$

å¯»æ‰¾ä¸€ä¸ªç§¯æ€§å‡½æ•°g

$$\sum\limits_{i= 1}^{n}(f*g)(i) \\ = \sum\limits_{i=1}^{n}\sum\limits_{d|i}f(d)g(\frac{i}{d})\\ = \sum\limits_{d=1}^{n}g(d)s(\lfloor\frac{n}{d}\rfloor)$$

$g(1)s(n)=\sum\limits_{d=1}^{n}g(d)s(\lfloor\frac{n}{d}\rfloor)-\sum\limits_{d=2}^{n}g(d)s(\lfloor\frac{n}{d}\rfloor)\\=\sum\limits_{i= 1}^{n}ï¼ˆf*g)(i)-\sum\limits_{d=2}^{n}g(d)s(\lfloor\frac{n}{d}\rfloor)$

ç„¶åå¦‚æœèƒ½æ„é€ å‡ºæ¥ä¸€ç§ç§¯æ€§å‡½æ•°ä½¿å¾—$f*g$çš„å‰ç¼€å’Œä»¥åŠgçš„å‰ç¼€å’Œå¾ˆå¥½ç®—ï¼Œé‚£ä¹ˆæ•´ä¸ªå¼å­å°±å¯ä»¥ä½¿ç”¨æ•´é™¤åˆ†å—å’Œé€’å½’è¿›è¡Œæ±‚è§£ã€‚



```c++
i64 GetSum(int n) {
    i64 ans = f_g_sum(n);
    for(i64 l = 2, r; l <= n; l = r + 1) {
        r = (n / (n / l)); 
        ans -= (g_sum(r) - g_sum(l - 1)) * GetSum(n / l);
    } 
    return ans; 
}
```

è¿™æ ·çš„å¤æ‚åº¦ä¸º$T(n)= \sum\limits_{i=1}^{\sqrt n}O(\sqrt i)+O(\sqrt{\frac{n}{i}}) = n^{0.75}$

#### 1. HDU7325 GCD Magic

æ±‚$\sum\limits_{i = 1}^n\sum\limits_{j = 1}^n[gcd(2^i-1, 2^j -1)] ^K$

æœŸä¸­$1\le n \le 10^9$,$0\le K \le 10$

ä½¿ç”¨è¾—è½¬ç›¸å‡å¯ä»¥å‘ç°å¼å­å˜æˆ$\sum\limits_{i = 1}^n\sum\limits_{j = 1}^n[2^{gcd(i,j) }-1] ^K$ï¼Œä¸‹é¢è¿›è¡Œæ¨å¼å­
$$
\sum\limits_{t = 1}^{n}\sum\limits_{i = 1} ^ {n}\sum\limits_{j = 1} ^ {n}[2^{t}-1]^K[gcd(i, j) = t]
\\
 \sum\limits_{t = 1}^{n}\sum\limits_{i = 1} ^ {\lfloor\frac{n}{t}\rfloor}\sum\limits_{j = 1} ^ {\lfloor\frac{n}{t}\rfloor}[2^{t}-1]^K[gcd(i, j) = 1]
 \\
 
 \sum\limits_{t = 1}^{n}[2^{t}-1]^K\sum\limits_{i = 1} ^ {\lfloor\frac{n}{t}\rfloor}\sum\limits_{j = 1} ^ {\lfloor\frac{n}{t}\rfloor}\sum\limits_{g|gcd(i,j)}\mu(g)
$$


ä»¤ $f(x)= (2^x - 1) ^ K$, $T = t\cdot g$æœ‰ï¼š
$$
\sum\limits_{T = 1}^{n}{\lfloor\frac{n}{t}\rfloor}^2\sum\limits_{t|T}f(t)\mu(\frac{T}{d})
$$
ç„¶åè€ƒè™‘æœæ•™ç­›ï¼Œè®¡ $g =f * \mu$ï¼Œè¦å¿«é€Ÿæ±‚å‡ºå‰ç¼€å’Œï¼Œåœ¨$g$å³è¾¹å·ä¸Šä¸€ä¸ª1å¯ä»¥æŠŠè¿™ä¸ªå¾ˆæ¶å¿ƒçš„$\mu$å˜æˆ$\varepsilon$ï¼Œå¾—$g*1=f$ã€‚



æ ¹æ®æœæ•™ç­›çš„å…¬å¼ï¼š
$$
\sum\limits_{i=1}^{n}(f*g)(i)
\\=\sum\limits_{i=1}^{n}\sum\limits_{d|i}f(d)g(\frac{i}{d})
\\=\sum\limits_{d=1}^{n}g(d)F(\lfloor\frac{n}{d}\rfloor)

\\
g(1)F(n)=\sum\limits_{d=1}^{n}g(d)F(\lfloor\frac{n}{d}\rfloor)-\sum\limits_{d=2}^{n}g(d)F(\lfloor\frac{n}{d}\rfloor)
\\=\sum\limits_{i=1}^{n}(f*g)(i)-\sum\limits_{d=2}^{n}g(d)F(\lfloor\frac{n}{d}\rfloor)
$$
å¥—è¿›æœæ•™ç­›å¼å­åˆ™æœ‰ï¼š
$$
1\cdot S(n)=\sum\limits_{i=1}^{n}(f*\mu*1)(i)-\sum\limits_{d=2}^{n}d\cdot S(\lfloor\frac{n}{d}\rfloor)
\\
S(n)=\sum\limits_{i=1}^{n}f(i)-\sum\limits_{d=2}^{n}d\cdot S(\lfloor\frac{n}{d}\rfloor)
$$
ç„¶ååªè¦å¿«é€Ÿæ±‚å‡º$\sum\limits_{i=1}^nf(i)$,è§‚å¯Ÿè¿™ä¸ªå¼å­ï¼Œå‘ç°å…¶Kå¾ˆå°ï¼Œé‚£ä¹ˆæš´åŠ›äºŒé¡¹å¼å±•å¼€åå‘ç°å…¶ä¸ºkä¸ªç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼Œç„¶åå°±å¯ä»¥$O(Kn^{\frac{2}{3}})$æ±‚å‡ºåŸå…¬å¼ååŠéƒ¨åˆ†çš„å‰ç¼€å’Œï¼Œç„¶åå‰é¢ä½¿ç”¨æ•´é™¤åˆ†å—å°±è¡Œï¼Œå› ä¸ºnçš„ä¸Šç•Œä¸€æ ·ï¼Œæ‰€ä»¥æ¯ä¸ªå‰ç¼€å’Œæœ€å¤šç®—ä¸€æ¬¡ï¼Œè®°å¿†åŒ–åä¿è¯æ±‚å‰ç¼€å’Œçš„å¤æ‚åº¦ä¸º$O(Kn^{\frac{2}{3}})$ã€‚



## æ¦‚ç‡

### 1.P5104å‘çº¢åŒ…

é¢˜ç›®å¤§æ„ï¼šæœ‰wå…ƒçš„çº¢åŒ…ï¼Œnä¸ªäººæ¥æŠ¢ï¼Œç¬¬kä¸ªäººæŠ¢åˆ°é’±çš„æ¦‚ç‡æ˜¯å¤šå°‘ã€‚

é¢˜ç›®åˆ†æï¼šæœŸæœ›çš„çº¿æ€§æ€§

ä»£ç ï¼š

```c++
//
// Created by mrx on 2022/6/26.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

const int mod = 1e9 + 7;

ll quickPow(ll base, ll fact) {
    ll ans = 1;
    while (fact) {
        if (fact & 1) ans = ans * base % mod;
        base = base * base % mod;
        fact >>= 1;
    }
    return ans;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    ll w, n, k;
    cin >> w >> n >> k;
    cout << w * quickPow(quickPow(2, k), mod - 2) % mod << endl;
    return 0;
}
```

### 2.P1850æ¢æ•™å®¤

é¢˜ç›®å¤§æ„ï¼šæœ‰nèŠ‚è¯¾ï¼Œç‰›ç‰›è¢«å®‰æ’åœ¨ciä¸Šè¯¾ï¼Œä»–å¯ä»¥ç”³è¯·æ¢æ•™å®¤ï¼Œæ¯ä¸€èŠ‚è¯¾éƒ½å¯ä»¥ç”³è¯·ï¼Œåˆ†åˆ«æœ‰biçš„å‡ ç‡ç”³è¯·é€šè¿‡ï¼Œæ•™å®¤å½¢æˆäº†ä¸€ä¸ªè”é€šå›¾ï¼Œç‰›ç‰›æœ€å¤šç”³è¯·mæ¬¡æ¢è¯¾ï¼Œä»ä¸€ä¸ªæ•™å®¤åˆ°å¦ä¸€ä¸ªæ•™å®¤è¦æ¶ˆè€—vijç‚¹ä½“åŠ›ï¼Œç‰›ç‰›æƒ³çŸ¥é“ä»–çš„æœŸæœ›æ¶ˆè€—ä½“åŠ›ã€‚

é¢˜ç›®åˆ†æï¼šå®¹æ˜“æƒ³åˆ°$dp[i][j]$è¡¨ç¤ºåˆ°ç¬¬ièŠ‚è¯¾å‰ç”³è¯·æ¢äº†jèŠ‚è¯¾ã€‚ä½†æ˜¯å¦‚æœåªæœ‰è¿™ä¸¤ä¸ªç»´åº¦ï¼Œå‘ç°çŠ¶æ€è½¬ç§»è¿˜æ˜¯éå¸¸å›°éš¾ï¼Œæ‰€ä»¥å¤šåŠ ä¸€ç»´kï¼Œè¡¨ç¤ºåœ¨iè¿™ä¸ªåœ°æ–¹ç‰›ç‰›æœ‰æ²¡æœ‰é€‰æ‹©æ¢è¯¾ï¼Œç„¶åå°±èƒ½è½»æ¾å¾—åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œå…¶ä¸ºä»i-1è½¬ç§»åˆ°iæ¶ˆè€—çš„ä½“åŠ›ä¹˜ä»¥æ¦‚ç‡æ±‚å’Œã€‚

ä»£ç ï¼š

```c++
//
// Created by mrx on 2022/6/26.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int n, m, v, e;
    cin >> n >> m >> v >> e;
    vector<int> pri(n), swp(n);
    vector<double> prob(n);
    vector<vector<int>> cost(v, vector<int>(v, 0x3f3f3f3f));
    for (int i = 0; i < n; ++i) {
        cin >> pri[i];
        pri[i]--;
    }
    for (int i = 0; i < n; ++i) {
        cin >> swp[i];
        swp[i]--;
    }
    for (int i = 0; i < n; ++i) {
        cin >> prob[i];
    }
    for (int i = 0; i < e; ++i) {
        int x, y, w;
        cin >> x >> y >> w;
        x--, y--;
        cost[x][y] = cost[y][x] = min(cost[x][y], w);
    }
    for (int k = 0; k < v; ++k) {
        for (int i = 0; i < v; ++i) {
            for (int j = 0; j < v; ++j) {
                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);
            }
        }
    }
    vector<vector<array<double, 2>>> dp(n, vector<array<double, 2>>(m + 2));//dp[i][j][0/1]è¡¨ç¤ºåˆ°ç¬¬iä¸ªæ¢äº†jä¸ªç‚¹0è¡¨ç¤ºå·²ç»æ¢æˆåŠŸç‚¹ï¼Œ1è¡¨ç¤ºæ²¡æœ‰æ¢æˆåŠŸç‚¹
    for (int i = 0; i < v; i++)cost[i][i] = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= m; j++)dp[i][j][0] = dp[i][j][1] = 1e18;
    }
    dp[0][0][0] = dp[0][1][1] = 0;
    for (int i = 1; i < n; ++i) {
        dp[i][0][0] = dp[i - 1][0][0] + cost[pri[i - 1]][pri[i]];
        for (int j = 1; j <= min(i + 1, m); ++j) {
            dp[i][j][0] = min({dp[i][j][0], dp[i - 1][j][0] + cost[pri[i - 1]][pri[i]],
                               dp[i - 1][j][1] + prob[i - 1] * cost[swp[i - 1]][pri[i]] + (1 - prob[i - 1]) * cost[pri[i - 1]][pri[i]]});
            dp[i][j][1] = min({dp[i][j][1],
                               dp[i - 1][j - 1][0] + prob[i] * cost[pri[i - 1]][swp[i]] + (1 - prob[i]) * cost[pri[i - 1]][pri[i]],
                               dp[i - 1][j - 1][1]
                               + prob[i - 1] * prob[i] * cost[swp[i - 1]][swp[i]]
                               + prob[i - 1] * (1 - prob[i]) * cost[swp[i - 1]][pri[i]]
                               + (1 - prob[i - 1]) * prob[i] * cost[pri[i - 1]][swp[i]]
                               + (1 - prob[i - 1]) * (1 - prob[i]) * cost[pri[i - 1]][pri[i]]});
        }
    }
    double ans = 1e18;
    for (int i = 0; i <= m; ++i) {
        ans = min({ans, dp[n - 1][i][0], dp[n - 1][i][1]});
    }
    cout << fixed << setprecision(2) << ans << endl;
    return 0;
}
```





### 3.P3830éšæœºæ ‘

é¢˜ç›®å¤§æ„ï¼šç»™ä¸€ä¸ªåªæœ‰æ ¹èŠ‚ç‚¹çš„äºŒå‰æ ‘ï¼Œéšæœºé€‰æ‹©ä¸€ä¸ªå¶å­ç»“ç‚¹ï¼ŒæŠŠå®ƒå˜æˆä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œç„¶åç»™ä½¿å…¶åº•ä¸‹å¤š2ä¸ªå¶å­ç»“ç‚¹ã€‚

é¢˜ç›®åˆ†æï¼šè®¾è®¡$dp[i]$è¡¨ç¤ºæœ‰iä¸ªå¶å­ç»“ç‚¹çš„å¹³å‡æ·±åº¦ï¼Œè¿›è¡Œè®¾è®¡çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œå®ƒæœ‰ä¸¤ä¸ªqueryï¼Œä¸€ä¸ªæ˜¯æŸ¥è¯¢æ ‘çš„æ·±åº¦æœŸæœ›ï¼Œå¦ä¸€ä¸ªæ˜¯æŸ¥è¯¢å¶å­ç»“ç‚¹çš„æ·±åº¦æœŸæœ›ã€‚åªè€ƒè™‘å¶å­ç»“ç‚¹çš„æ·±åº¦æœŸæœ›çš„æ—¶å€™ï¼Œæœ‰$f[n]=f[n-1]+\frac {2}{n}$ï¼Œå¯¹äºç¬¬äºŒç§æŸ¥è¯¢ï¼Œå°±æ¯”è¾ƒéº»çƒ¦äº†å‡è®¾$dp[i][j]$ä¸ºiä¸ªå¶å­ç»“ç‚¹ï¼Œæ ‘é«˜åº¦å¤§äºç­‰äºjçš„æ¦‚ç‡ï¼Œé‚£ä¹ˆå¯¹äºä»»æ„ä¸€é¢—æ ‘ï¼Œå®ƒçš„æ·±åº¦å¤§äºjçš„æ¦‚ç‡$P[j]=dp[k][j-1]+dp[i-k][j-1]+dp[k][j-1]*dp[i-k][j-1]$ï¼Œé‚£ä¹ˆå‡è®¾å·¦å­æ ‘çš„ç»“ç‚¹æ ‘ä¸ºkï¼Œæ“ä½œi-1æ¬¡ï¼Œ$P=\sum_{k=1}^{i-1}P_k*P'_k$,$P'_k$ä¸ºå·¦å­æ ‘æœ‰kä¸ªç»“ç‚¹çš„æ¦‚ç‡ã€‚è€ƒè™‘æ“ä½œï¼Œæ¯ä¸€æ¬¡æ“ä½œè¦ä¹ˆæ”¾å·¦è¾¹ï¼Œè¦ä¹ˆæ”¾å³è¾¹ï¼Œå¯¹äºå·¦å­æ ‘ï¼Œæ¯ä¸€æ¬¡åœ¨å·¦å­æ ‘çš„æ‰©å±•æ“ä½œéƒ½æœ‰iä¸­å¯èƒ½æ€§ï¼Œé‚£ä¹ˆï¼Œå½¢æˆå·¦å­æ ‘æœ‰kä¸ªèŠ‚ç‚¹çš„æ ‘çš„ä¸ªæ•°ä¸º$(k-1)!*(i-k-1)!$ã€‚è€Œæ“ä½œé¡ºåºæœ‰$C_{i-2}^{k-1}$ç§ï¼Œä¹˜èµ·æ¥å°±æ˜¯æ‰€æœ‰æ“ä½œå¯èƒ½æ€§ä¸­ç”Ÿæˆå·¦å­æ ‘æœ‰kä¸ªèŠ‚ç‚¹çš„ä¸ªæ•°ã€‚å³ä¸º$(i-2)!$é‚£ä¹ˆ$P'_k=\frac{1}{i-1}$ä»è€Œå¾—åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€‚$dp[i][j]=\sum_{k=1}^{i-1}\frac{dp[k][j-1]+dp[i-k][j-1]-dp[k][j-1]*dp[i-k][j-1]}{i-1}$ã€‚è¿›è¡Œä¸€ä¸‹dpå°±è¡Œ

ä»£ç ï¼š

```c++
//
// Created by mrx on 2022/6/27.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int q, n;
    cin >> q >> n;
    if (q == 1) {
        double ans = 0;
        for (int i = 2; i <= n; ++i)ans += 2.0 / i;
        cout << fixed << setprecision(6) << ans << endl;
    } else {

        vector<vector<double  >> dp(n + 1, vector<double>(n + 1, 0));
        for (int i = 1; i <= n; ++i)dp[i][0] = 1;
        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j < i; ++j) {
                for (int k = 1; k < i; ++k) {
                    dp[i][j] += (dp[k][j - 1] + dp[i - k][j - 1] - dp[k][j - 1] * dp[i - k][j - 1]) / (i - 1);
                }
            }
        }
        double ans = 0;
        for (int i = 1; i <= n; ++i)ans += dp[n][i];
        cout << fixed << setprecision(6) << ans << endl;
    }
    return 0;
}
```



### 4.P3193 GTè€ƒè¯•

é¢˜ç›®å¤§æ„ï¼šæœ‰ä¸€ä¸ªnä½æ•°ï¼Œä¸èƒ½å‡ºç°å­—ä¸²mï¼Œæ±‚è¿™ä¸ªnä½æ•°å­—æœ‰å¤šå°‘ä¸ª

é¢˜ç›®åˆ†æï¼šä¸€çœ¼ä¸çœŸï¼Œæ„Ÿè§‰åƒä¸ªdpï¼Œè®¾è®¡çŠ¶æ€è½¬ç§»æ–¹ç¨‹$dp[i][j]$ï¼Œiï¼Œjä¸ºä¸¤ä¸ªå­—ç¬¦ä¸²åŒ¹é…ä½ã€‚ä½†æ˜¯å¤æ‚åº¦è¦å¯„ï¼Œæ‰€ä»¥è€ƒè™‘ä¼˜åŒ–ï¼Œæ ¹æ®å­—ç¬¦ä¸²åŒ¹é…ï¼Œä½¿ç”¨kmpç®—æ³•ã€‚ç„¶åå¯ä»¥é€šè¿‡kmpçš„nxtæ•°ç»„å¾—åˆ°$dp[i]å’Œdp[i+1]$çš„çŠ¶æ€è½¬ç§»çŸ©é˜µã€‚ç„¶åè¿›è¡ŒçŸ©é˜µå¿«é€Ÿèœœã€‚

ä»£ç ï¼š

```c++
//
// Created by mrx on 2022/6/27.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;
int mod;

vector<int> nxt(string &s) {
    int n = s.length();
    vector<int> nxt(n + 1, 0);
    for (int i = 2, j = 0; i <= n && j <= n; ++i) {
        while (j && s[j + 1] != s[i])j = nxt[j];
        if (s[j + 1] == s[i])j++;
        nxt[i] = j;
    }
    return nxt;
}

struct matrix {
    vector<vector<int>> mat;
    int n, m;

    matrix(int n, int m) : n(n), m(m), mat(n, vector<int>(m, 0)) {}

    void E() {
        m = n;
        mat.clear();
        mat.resize(n);
        for (auto &x: mat)x.resize(m, 0);
        for (int i = 0; i < n; ++i)mat[i][i] = 1;
    }

    friend matrix operator*(const matrix &lhs, const matrix &rhs) {
        if (lhs.m != rhs.n) {
            throw (runtime_error("matrix multiply not matching"));
        }
        matrix ans(lhs.n, rhs.m);
        for (int i = 0; i < lhs.n; ++i) {
            for (int j = 0; j < rhs.m; ++j) {
                for (int k = 0; k < lhs.m; ++k) {
                    ans.mat[i][j] = (ans.mat[i][j] + lhs.mat[i][k] * rhs.mat[k][j] % mod) % mod;
                }
            }
        }
        return ans;
    }

    friend matrix operator^(matrix a, long long b) {
        if (a.n != a.m) {
            throw (runtime_error("matrix pow not matching"));
        }
        matrix ans(a.n, a.n);
        ans.E();
        while (b) {
            if (b & 1) {
                ans = ans * a;
            }
            a = a * a;
            b >>= 1;
        }
        return ans;
    }
};

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int n, m;
    string s;
    cin >> n >> m >> mod;
    cin >> s;
    s = '*' + s;
    vector<int> kmp = nxt(s);
    matrix xs(m, m);
    for (int i = 0; i < m; ++i) {
        for (int j = '0'; j <= '9'; ++j) {
            int temp = i;
            while (s[temp + 1] != j && temp > 0) temp = kmp[temp];
            if (s[temp + 1] == j) temp++;
            if (temp < m) xs.mat[i][temp]++;
        }
    }
    matrix dp(1, m);
    dp.mat[0][0] = 1;
    long long ans = 0;
    matrix ansm = dp * (xs ^ n);
    for (int i = 0; i < m; ++i) {
        ans = (ansm.mat[0][i] + ans) % mod;
    }
    cout << ans << endl;
    return 0;
}
```



### 5.P4564å‡é¢

é¢˜ç›®å¤§æ„ï¼šå‡é¢æœ‰ä¸¤ä¸ªæŠ€èƒ½ï¼Œç¬¬ä¸€ä¸ªæŠ€èƒ½å¯¹æ¯ä¸ªæ•Œäººæœ‰pçš„æ¦‚ç‡é€ æˆä¸€ç‚¹ä¼¤å®³ï¼Œç¬¬äºŒä¸ªæŠ€èƒ½å¯ä»¥ä»é€‰å®šçš„æ´»ç€ç›®æ ‡é‡Œé¢ç­‰æ¦‚ç‡å¾—é”å®šä¸€äººï¼Œæ±‚æ¯æ¬¡ç¬¬äºŒä¸ªæŠ€èƒ½é‡Šæ”¾ä¹‹åæ¯ä¸ªæ•Œäººè¢«å‡»ä¸­çš„æ¦‚ç‡ï¼Œä»¥åŠæŠ€èƒ½å…¨éƒ¨é‡Šæ”¾å®Œæˆä¹‹åæ¯ä¸ªæ•Œäººè¡€é‡çš„æœŸæœ›ã€‚

é¢˜ç›®åˆ†æï¼šç¬¬äºŒä¸ªæŠ€èƒ½ä¸ä¼šå½±å“è¡€é‡ï¼Œç¬¬äºŒä¸ªæŠ€èƒ½å–å†³äºåœºä¸Šå­˜æ´»çš„æ•Œäººï¼Œé‚£ä¹ˆå¯¹äºé—®é¢˜ä¸€ï¼Œå¯ä»¥å¾ˆå®¹æ˜“å¾—æƒ³åˆ°ç›´æ¥é€’æ¨å‡ºç»“æœã€‚å¯¹äºç¬¬äºŒä¸ªæŠ€èƒ½ï¼Œå°±æ¯”è¾ƒå¤æ‚äº†ï¼Œå®¹æ˜“æ¨åˆ°å‡ºæŸ¿å­ï¼Œç„¶åå‘ç°ä¸‹æ ‡å¹¶æ²¡æœ‰éå¸¸çš„é™åˆ¶ï¼Œé‚£ä¹ˆå°±å¯ä»¥è¿›è¡Œç§»é¡¹ã€‚ç§»é¡¹å®Œæˆä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥ç®—å‡ºæ¥ä¸€ä¸ªä¸­é—´å€¼$G[i]$ï¼Œé€šè¿‡è¿™ä¸ªä¸­é—´å€¼å¯ä»¥åœ¨$o(n^2)$çš„å¤æ‚åº¦å†…ç®—å‡ºæ¥æ¯ä¸€ä¸ªç‚¹å­˜æ´»çš„æ¦‚ç‡å€¼ï¼Œç„¶åé€šè¿‡æœŸæœ›çš„å®šä¹‰ç®—å‡ºæ¥æœŸæœ›å°±è¡Œäº†ã€‚

ä»£ç ï¼š

```c++
//
// Created by mrx on 2022/6/27.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;
const long long mod = 998244353;

template<typename T>
T quickPow(T base, T fact) {
    T ans = 1;
    while (fact) {
        if (fact & 1) ans = ans * base % mod;
        base = base * base % mod;
        fact >>= 1;
    }
    return ans;
}

template<typename T>
T normal(T a) {
    return a < 0 ? a + mod : a >= mod ? a - mod : a;
}

template<typename T>
struct ModInt {
    T base;

    ModInt() : base(0) {}

    ModInt(T a) : base(normal(a % mod)) {}

    ModInt(int a) : base(normal(a % mod)) {}

    ModInt(const ModInt &rhs) {
        base = rhs.base;
    }

    ModInt inv() const {
        return quickPow(base, mod - 2);
    }

    ModInt &operator=(const ModInt &rhs) {
        base = rhs.base;
        return *this;
    }

    ModInt operator-() const { return ModInt(normal(mod - base)); }

    ModInt &operator*=(const ModInt &rhs) {
        base = 1ll * base * rhs.base % mod;
        return *this;
    }

    ModInt &operator+=(const ModInt &rhs) {
        base = normal(base + rhs.base);
        return *this;
    }

    ModInt &operator-=(const ModInt &rhs) {
        base = normal(base - rhs.base);
        return *this;
    }

    ModInt &operator/=(const ModInt &rhs) { return *this *= rhs.inv(); }

    ModInt &operator++() { return *this += 1; }

    ModInt &operator--() { return *this -= 1; }

    ModInt operator++(int) {
        ModInt res = *this;
        ++*this;
        return res;
    }

    ModInt operator--(int) {
        ModInt res = *this;
        --*this;
        return res;
    }

    friend ModInt operator*(const ModInt &lhs, const ModInt &rhs) {
        ModInt res = lhs;
        res *= rhs;
        return res;
    }

    friend ModInt operator+(const ModInt &lhs, const ModInt &rhs) {
        ModInt res = lhs;
        res += rhs;
        return res;
    }

    friend ModInt operator-(const ModInt &lhs, const ModInt &rhs) {
        ModInt res = lhs;
        res -= rhs;
        return res;
    }

    friend ModInt operator/(const ModInt &lhs, const ModInt &rhs) {
        ModInt res = lhs;
        res /= rhs;
        return res;
    }

    template<class stream>
    friend stream &operator>>(stream &is, ModInt &rhs) {
        T x;
        is >> x;
        rhs = ModInt(x);
        return is;
    }

    operator T() {
        return base;
    }

    template<class stream>
    friend stream &operator<<(stream &os, const ModInt &rhs) {
        return os << rhs.base;
    }

    friend bool operator==(const ModInt &lhs, const ModInt &rhs) {
        return lhs.base == rhs.base;
    }

    friend bool operator!=(const ModInt &lhs, const ModInt &rhs) {
        return lhs.base != rhs.base;
    }
};

using Mint = ModInt<long long>;

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    int q;
    cin >> q;
    vector<vector<Mint>> prob(n + 1, vector<Mint>(211, 0));
    vector<Mint> g(211), inv(211), tmp(211);
    for (int i = 1; i <= 203; ++i)inv[i] = Mint(i).inv();
    for (int i = 1; i <= n; ++i)prob[i][a[i]] = 1;
    while (q--) {
        int opt;
        cin >> opt;
        if (opt == 0) {
            Mint id, u, v;
            cin >> id >> u >> v;
            Mint p = u * v.inv();
            Mint mp = Mint(1) - p;
            prob[id][0] = prob[id][0] + prob[id][1] * p;
            for (int i = 1; i <= a[id]; ++i) {
                prob[id][i] = prob[id][i + 1] * p + prob[id][i] * mp;
            }
        } else {
            int cnt, tot = 0;
            cin >> cnt;
            vector<int> atkid(cnt + 2);
            for (int i = 1; i <= cnt; ++i) {
                cin >> atkid[i];
            }
            g[0] = 1;
            for (int i = 1; i <= cnt; ++i) {
                Mint id = atkid[i], p = Mint(1) - prob[id][0];
                Mint invp = prob[id][0];
                if (invp == Mint(0)) {
                    tot++;
                    continue;
                }
                for (int j = cnt; j >= 1; --j) {
                    g[j] = g[j - 1] * p + g[j] * invp;
                }
                g[0] = g[0] * invp;
            }
            for (int i = 1; i <= cnt; ++i) {
                Mint id = atkid[i], p = Mint(1) - prob[id][0];
                Mint invp = prob[id][0], invp_inv = invp.inv();
                Mint ans = 0;
                if (invp == Mint(0)) {
                    for (int j = 0; j <= cnt; ++j) {
                        ans = ans + inv[j + tot] * g[j];
                    }
                    cout << ans << ' ';
                } else {
                    for (int j = 0; j <= cnt; ++j) {
                        tmp[j] = g[j];
                    }
                    tmp[0] = tmp[0] * invp_inv;
                    for (int j = 1; j <= cnt; ++j) {
                        tmp[j] = (tmp[j] - tmp[j - 1] * p) * invp_inv;
                    }
                    for (int j = 0; j <= cnt; ++j)ans = ans + inv[j + tot + 1] * tmp[j] * p;
                    cout << ans << ' ';
                }
            }
            cout << endl;
            for (int j = 0; j <= cnt; ++j)g[j] = 0;
        }
    }
    for (int i = 1; i <= n; ++i) {
        Mint ans = 0;
        for (int j = 0; j <= a[i]; ++j)ans += Mint(j) * prob[i][j];
        cout << ans << ' ';
    }
    cout << endl;
    return 0;
}
```



### 6.3426 SZA-Template

é¢˜ç›®å¤§æ„ï¼šåˆ¶ä½œä¸€ä¸ªå°ç« ï¼Œä½¿å¾—å°ç« é‡å¤å°è‹¥å¹²æ¬¡å¯ä»¥å˜æˆç»™å®šçš„å­—ç¬¦ä¸²ï¼Œæ±‚å°ç« çš„å­—ç¬¦ä¸²é•¿åº¦æœ€å°å€¼ã€‚

é¢˜ç›®åˆ†æï¼šå®¹æ˜“çŸ¥é“ï¼Œå°ç« è‚¯å®šæ˜¯ä¸€ä¸ªborderï¼Œå¯¹äºè¿™ä¸ªborderå¦‚æœå…¶çš„é•¿åº¦æ¯”è¿™ä¸ªiåˆ°$nxt[i]$åˆ°é•¿åº¦ä¸€å®šè¦å¤§ï¼Œç„¶åè¿›è¡Œdpï¼Œç„¶åè¦ç»´æŠ¤æ¯ä¸€ä¸ªborderèƒ½è¦†ç›–åˆ°çš„æœ€è¿œç‚¹ï¼Œè¿™ä¸ªå¯ä»¥é€šè¿‡ä¸€ä¸ªæ¡¶æ¥ç»´æŠ¤ã€‚

ä»£ç ï¼š

```c++
//
// Created by mrx on 2022/6/27.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

vector<int> nxt(string &s) {
    int n = s.length() - 1;
    vector<int> nxt(n + 1);
    for (int i = 2, j = 0; i <= n; ++i) {
        while (j && s[i] != s[j + 1])j = nxt[j];
        if (s[i] == s[j + 1])j++;
        nxt[i] = j;
    }
    return nxt;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    string s;
    cin >> s;
    int n = s.length();
    s = '*' + s;
    vector<int> kmp = nxt(s), pre(n + 1), len(n + 1);
    for (int i = 1; i <= n; ++i) {
        len[i] = i;
        if (pre[len[kmp[i]]] >= i - kmp[i]) len[i] = len[kmp[i]];
        pre[len[i]] = i;
    }
    cout << len[n] << endl;
    return 0;
}
```



### 7.P3232æ¸¸èµ°

é¢˜ç›®å¤§æ„ï¼šç»™å®šä¸€ä¸ªæ— å‘å›¾ï¼Œä½ éœ€è¦ä»1å·ç‚¹èµ°åˆ°nå·ç‚¹ï¼Œåœ¨æ¯ä¸ªç‚¹ç­‰æ¦‚ç‡åœ°é€‰æ‹©ä¸€æ¡è¾¹èµ°ï¼Œæ¯ä¸€æ¡è¾¹æœ‰ä¸€ä¸ªç¼–å·ï¼Œä»1åˆ°mï¼Œè‡ªå·±ç¡®å®šå“ªæ¡è¾¹æ˜¯ä»€ä¹ˆç¼–å·ï¼Œæ±‚èµ°è¿‡è¾¹çš„ç¼–å·å’Œçš„æœŸæœ›ã€‚

é¢˜ç›®åˆ†æï¼šå› ä¸ºæ˜¯æ±‚ç¼–å·å’Œçš„æœŸæœ›ï¼Œä½†æ˜¯ç¼–å·æ˜¯ä½ è‡ªå·±ç¼–çš„ï¼Œé‚£ä¹ˆç®—å‡ºæ¥æ¯æ¡è¾¹æœŸæœ›èµ°è¿‡çš„æ¬¡æ•°ç„¶åæ’åºï¼Œæœ€åå°±å¯ä»¥æ±‚å‡ºæ¥é¢˜ç›®è¦æ±‚çš„æœŸæœ›äº†ã€‚è€Œèµ°è¿‡è¾¹çš„æ¬¡æ•°æœŸæœ›åˆå’Œèµ°è¿‡ç‚¹çš„æœŸæœ›æœ‰å…³ç³»ï¼Œå¯¹äº$e_{u,v}$è¿™ä¸ªè¾¹ï¼Œè¿™æ¡è¾¹èµ°è¿‡çš„æœŸæœ›å°±æ˜¯$\frac{E(u)}{deg(u)}+\frac{E(v)}{deg(v)}$,é‚£é—®é¢˜è½¬åŒ–æˆäº†æ±‚æ¯ä¸ªç‚¹çš„æœŸæœ›ç»è¿‡æ¬¡æ•°ï¼Œå¯¹äº$E(U)$æ¥è®²ï¼Œ$E(u)=\sum \frac{E(v)}{deg(v)}(u,vé‚»æ¥)$ç‰¹åˆ«çš„ï¼Œå¯¹äº$Eï¼ˆ1ï¼‰=1+\sum \frac{E(v)}{deg(v)}(u,vé‚»æ¥)$ï¼Œæ ¹æ®Eï¼ˆnï¼‰=0å¯ä»¥è¿›è¡Œé«˜æ–¯æ¶ˆå…ƒï¼Œä»è€Œè§£å‡ºæ–¹ç¨‹ç»„ï¼Œä»è€Œå¾—å‡ºæ¯ä¸ªç‚¹çš„æœŸæœ›ç»è¿‡æ¬¡æ•°ï¼Œç„¶åå°±èƒ½å¾—åˆ°æ¯ä¸ªè¾¹çš„æœŸæœ›ç»è¿‡æ¬¡æ•°ã€‚æœ€åæŒ‰ç…§è¾¹çš„æœŸæœ›ç»è¿‡æ¬¡æ•°æ’åºï¼Œç„¶åå°±èƒ½å‡ºç­”æ¡ˆäº†ã€‚

ä»£ç ï¼š

```c++
//
// Created by mrx on 2022/6/27.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;
double eps = 1e-8;

struct matrix {
    vector<vector<double>> mat;
    int n, m;

    matrix(int n, int m) : n(n), m(m), mat(n, vector<double>(m + 1, 0.0)) {}

    void gauss() {
        for (int col = 0, row = 0; col <= m && row < n; ++col) {
            int nxt = row;
            for (; nxt < n - 1; nxt++) if (abs(mat[nxt][col]) > eps)break;
            if (abs(mat[nxt][col]) > eps) {
                swap(mat[row], mat[nxt]);
                double div = mat[row][col];
                for (int i = 0; i <= m; ++i) mat[row][i] /= div;
                for (int i = 0; i < n; ++i) {
                    if (i != row && abs(mat[row][col]) > eps) {
                        div = mat[i][col];
                        for (int j = 0; j <= m; ++j) {
                            mat[i][j] -= div * mat[row][j];
                        }
                    }
                }
            }
            row++;
        }
    }

    void show() {
        for (auto &x: mat) {
            for (auto y: x) { cout << y << ' '; }
            cout << endl;
        }
    }
};

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int n, m;
    cin >> n >> m;
    vector<int> E[n + 1];
    vector<pair<double, pair<int, int>>> e;
    vector<int> d(n + 1, 0);
    for (int i = 1; i <= m; ++i) {
        int x, y;
        cin >> x >> y;
        E[x].push_back(y), E[y].push_back(x);
        e.emplace_back(0, make_pair(x, y));
        d[x]++, d[y]++;
    }
    matrix M(n, n);
    M.mat[0][n] = 1;
    M.mat[n - 1][n - 1] = 1;
    for (int u = 1; u < n; ++u) {
        M.mat[u - 1][u - 1] = 1;
        for (auto v: E[u]) {
            if (v != n)
                M.mat[u - 1][v - 1] -= 1.0 / d[v];
        }
    }
    M.gauss();
    for (auto &x: e) {
        x.first += M.mat[x.second.first - 1][n] / d[x.second.first] + M.mat[x.second.second - 1][n] / d[x.second.second];
    }
    std::sort(e.begin(), e.end());
    std::reverse(e.begin(), e.end());
    double ans = 0;
    for (int i = 1; i <= m; ++i) {
        ans += i * e[i - 1].first;
    }
    cout << fixed << setprecision(3) << ans << endl;
    return 0;
}
```

### 8.Potion(Hubei CPC)

é¢˜ç›®å¤§æ„ï¼šç»™ä¸€ä¸ªå®¹ç§¯ä¸ºa+bæœ‰åˆ»åº¦ä¸ºaçš„é‡ç­’ï¼Œç»™ä¸¤ç§æ¶²ä½“ï¼Œè¿™ä¸¤ç§æ¶²ä½“å¯ä»¥äº’èï¼Œæ±‚åˆ¶å–ç»™å®šçš„æ¶²ä½“é…æ¯”éœ€è¦è¿›è¡Œå‡ æ¬¡åŠ æ¶²ä½“çš„æ“ä½œã€‚

é¢˜ç›®åˆ†æï¼šå¯¹äºåŸæœ‰æµ“åº¦ä¸º$f[i]$çš„æ¶²ä½“æ¥è®²ï¼Œå¦‚æœåŠ å…¥bæ¯«å‡æ°´ï¼Œé‚£ä¹ˆæµ“åº¦å˜æˆ$\frac{a*f[i]+0*(a+b)}{a+b}$,å¦‚æœåŠ å…¥çš„æ˜¯æº¶è´¨ï¼Œé‚£ä¹ˆæµ“åº¦å˜æˆ$\frac {a*f[i]+b*(a+b)}{a+b}$çš„æµ“åº¦ï¼Œè€ƒè™‘$f[0]$ï¼Œ$f[0]$å¿…å®šä¸º1æˆ–è€…0ã€‚å‡è®¾çŒæ°´äº†n+1æ¬¡ï¼Œé‚£ç¬¬ä¸€æ¬¡çŒå…¥çš„æ¶²ä½“æ˜¯a+bï¼Œå…¶ä½™çš„éƒ½æ˜¯çŒå…¥bçš„æ¶²ä½“ï¼Œè®¡æ¯ä¸€æ¬¡çŒçš„æ¶²ä½“ä¸ºg[i]ï¼ŒçŒå…¥æº¶è´¨æ—¶$g[i]=1$,çŒå…¥æ°´æ—¶$g[i]=0$ï¼Œè€ƒè™‘æ¯ä¸€æ¬¡çŒæ¶²ä½“å¯¹äºç­”æ¡ˆçš„è´¡çŒ®ï¼Œé‚£ä¹ˆ$f[0]$å¯¹äºç­”æ¡ˆçš„è´¡çŒ®å°±æ˜¯$g[0]*\frac{a^n}{(a+b)^n}$ã€‚$f[i](i>0)$	å¯¹ç­”æ¡ˆçš„è´¡çŒ®ä¸ºï¼š$\frac{g[i]*b*(a+b)^{i-1}*a^{n-i}}{(a+b)^{n}}$ï¼Œæ‰€ä»¥æ€»çš„è´¡çŒ®æ˜¯$\sum\frac{a^n*g[0]+b*g[i]*(a+b)^{i-1}*a^{n-i}}{(a+b)^{n}}$ã€‚é‚£ä¹ˆï¼Œå¦‚æœæœ‰å§ï¼Œ$x+y$ä¸ºa+bçš„èœœæ¬¡ï¼Œxå¯ä»¥è¢«$a^n*g[0]+g[i]*(a+b)^{i-1}*a^{n-i}$è¡¨ç¤ºã€‚é‚£ä¹ˆåˆ†ç±»è®¨è®ºæœ‰æ— ç¬¬0é¡¹ã€‚ç„¶åç”¨å¾ªç¯æˆ–è€…é€’å½’åˆ¤æ–­æœ‰æ²¡æœ‰è§£å³å¯ã€‚

ä»£ç ï¼š

```c++
//
// Created by mrx on 2022/7/8.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

long long gcd(long long a, long long b) {
    return a % b == 0 ? b : gcd(b, a % b);
}


ll quickPow(ll base, ll fact) {
    ll ans = 1;
    while (fact) {
        if (fact & 1) ans = ans * base;
        base = base * base;
        fact >>= 1;
    }
    return ans;
}

void sol() {
    long long a, b, x, y;
    cin >> x >> y >> a >> b;
    long long g = gcd(x, y);
    x /= g, y /= g;
    g = gcd(a, b);
    a /= g, b /= g;
    long long c = a + b;
    long long n = 0;
    long long tmp = x + y;
    while (tmp % c == 0) {
        tmp /= c;
        n++;
    }
    function<bool(long long, long long, long long, long long)> check = [&](long long aa, long long bb, long long fz, long long cnt) -> bool {
        if (cnt == 0) {
            if (fz == 0)return 1;
            else return 0;
        }
        if (fz % c == 0)return check(aa, bb, fz / c, cnt - 1);
        else {
            if ((fz - quickPow(a, cnt - 1)) % c == 0 && (fz - quickPow(a, cnt - 1) >= 0))
                return check(aa, bb, (fz - quickPow(a, cnt - 1)) / c, cnt - 1);
            else return 0;
        }
    };
    if (tmp != 1) {
        cout << -1 << endl;
    } else {
        if (x - quickPow(a, n) >= 0 && (x - quickPow(a, n)) % b == 0 && check(a, b, (x - quickPow(a, n)) / b, n)) {
            cout << n + 1 << endl;
        } else if (x % b == 0 && check(a, b, x / b, n)) {
            cout << n + 1 << endl;
        } else cout << -1 << endl;
    }
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int t;
    cin >> t;
    while (t--)sol();
    return 0;
}
```

### 9.P3239äºšç‘Ÿç‹

é¢˜ç›®å¤§æ„ï¼šæœ‰nå¼ æ‰‹ç‰Œï¼Œæ¯å¼ ç‰Œæœ‰$p[i]$çš„æ¦‚ç‡é‡Šæ”¾æ”»å‡»åŠ›ä¸º$d[i]$ï¼Œé‡Šæ”¾åè¯¥å¡ç‰Œä¸èƒ½ï¼Œå¦‚æœè„¸é»‘ï¼Œä¸€å¼ æ‰‹ç‰Œéƒ½æ²¡ç”¨å‡ºå»ï¼Œé‚£ä¹ˆè¿™ä¸€è½®ä¾æ—§ç»“æŸï¼Œæ±‚è¿›è¡Œrè½®ä¹‹åç†è®ºé€ æˆä¼¤å®³çš„æœŸæœ›ã€‚

é¢˜ç›®åˆ†æï¼šç›´æ¥åˆ†ææœŸæœ›çš„è®¡ç®—å¾ˆéº»çƒ¦ï¼Œç”±äºæ¯ä¸€å¼ å¡ç‰Œåªèƒ½é‡Šæ”¾ä¸€æ¬¡ï¼Œé‚£ä¹ˆé€šè¿‡è®¡ç®—æ¯ä¸€å¼ å¡ç‰Œåœ¨æ•´ä¸ªæ¸¸æˆä¸­é‡Šæ”¾å‡ºå»çš„æ¦‚ç‡ç„¶åä¹˜ä»¥ä¼¤å®³æ±‚å’Œå³å¯æ±‚å‡ºæ¥æ•´ä¸ªæ¸¸æˆä¸­é€ æˆçš„ä¼¤å®³ã€‚å¯¹äºæ¯å¼ å¡ç‰Œé‡Šæ”¾$dp[i][j]$è¡¨ç¤ºç¬¬iå¼ ç‰Œä¹‹å‰é€‰äº†jå¼ ç‰Œï¼Œç„¶ådpä¸€ä¸‹å°±è¡Œäº†

```C++
//
// Created by mrx on 2022/7/9.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

template<class T>
T quickPow(T base, ll fact) {
    T ans = 1;
    while (fact) {
        if (fact & 1) ans = ans * base;
        base = base * base;
        fact >>= 1;
    }
    return ans;
}

void sol() {
    int n, r;
    cin >> n >> r;
    vector<double> prob(n + 1, 0);
    vector<vector<double>> dp(n + 1, vector<double>(r + 1, 0));
    vector<int> dmg(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> prob[i] >> dmg[i];
    }
    dp[1][1] = 1 - quickPow(1 - prob[1], r), dp[1][0] = quickPow(1 - prob[1], r);
    for (int i = 2; i <= n; ++i) {
        for (int j = 0; j <= min(i, r); ++j) {
            dp[i][j] += dp[i - 1][j] * quickPow(1 - prob[i], r - j);//å¦‚æœiä¸é€‰ï¼Œé‚£ä¹ˆæœ‰r-jè½®éƒ½æ²¡é€‰åˆ°ä»–
            dp[i][j] += dp[i - 1][j - 1] * (1 - quickPow((1 - prob[i]), r - j + 1));
        }
    }
    double ans = dp[1][1] * dmg[1];
    for (int i = 2; i <= n; ++i) {
        for (int j = 0; j <= min(i - 1, r); ++j) {
            ans += dp[i - 1][j] * (1 - quickPow(1 - prob[i], r - j)) * dmg[i];
        }
    }
    cout << fixed << setprecision(10) << ans << endl;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int t;
    cin >> t;
    while (t--)sol();
    return 0;
}
```

### 10.P5523çç 

é¢˜ç›®å¤§æ„ï¼šå®šä¹‰ä¸énandï¼Œç»™å®šå››ç§æ“ä½œï¼Œä»å·¦åˆ°å³æŸ¥è¯¢ï¼Œä»å³åˆ°å·¦æŸ¥è¯¢ï¼Œåœ¨å·¦è¾¹åŠ å…¥ç‚¹ï¼Œåœ¨å³è¾¹åŠ å…¥ç‚¹ã€‚è¯¢é—®å¤šå°‘æ¬¡æŸ¥è¯¢å‡º1ï¼Œå¤šå°‘æ¬¡æ“ä½œç¼–å·ä¸ºå¥‡æ•°è€Œä¸”æŸ¥è¯¢ç»“æœä¸º0ï¼Œå¤šå°‘æ¬¡æŸ¥è¯¢ç¼–å·ä¸ºå¶æ•°æŸ¥è¯¢ç»“æœä¸º1ï¼Œå¤šå°‘æ¬¡æ“ä½œç¼–å·ä¸º1024çš„å€æ•°æŸ¥è¯¢ç»“æœä¸º0ã€‚

é¢˜ç›®åˆ†æï¼šå†™å‡ºnandçš„çœŸå€¼è¡¨ï¼Œå‘ç°å…¶æ²¡æœ‰ç»“åˆå¾‹ï¼Œé‚£ä¹ˆæ•°æ®ç»“æ„å¾ˆéš¾è¿›è¡Œç»´æŠ¤ã€‚é€šè¿‡è§‚å¯Ÿå¯ä»¥å‘ç°ï¼Œè¡¨è¾¾å¼å·¦å³ä¸¤ç«¯åªè¦æœ‰0é‚£ä¹ˆnandçš„è¾“å‡ºè‚¯å®šæ˜¯1ï¼Œé‚£ä¹ˆè¿™æ ·å°±å¯ä»¥æŠŠæŸ¥è¯¢åŒ–ç®€ï¼Œæ¯”å¦‚è¯´1 nand 1 nand 0 nand 1 nand 1 nand 0 nand 1 nand 1 nand 0 nand 1 nand 1å°±å¯ä»¥æŠŠæœ€åä¸€ä½0ç‚¹çš„å‰é¢çš„æ•°å­—å…¨éƒ¨å¿½ç•¥ï¼ŒåŒ–ç®€ä¸º1 nand 1 nand 1ã€‚æœ€ç»ˆçš„æŸ¥è¯¢ç»“æœé™¤äº†åªæœ‰ä¸€ä¸ª0çš„æ—¶å€™è¦ç‰¹åˆ¤æ–­ï¼Œä¸ç„¶å°±æ˜¯ä¸€å †1è¿›è¡Œnandï¼Œä¸€å †1è¿›è¡Œnandä¹Ÿæœ‰è§„å¾‹ï¼Œ1çš„ä¸ªæ•°ä¸ºå¥‡æ•°çš„æ—¶å€™å…¶ä¸º1ï¼Œä¸ªæ•°ä¸ºå¶æ•°çš„æ—¶å€™å…¶ä¸º0ã€‚è¿™æ ·å°±å¯ä»¥ç¡®å®šè¿™é“é¢˜çš„åšæ³•äº†ï¼Œåªè¦ç»´æŠ¤æ¯ä¸€ä¸ªç‚¹çš„å·¦å³ä¸¤ç«¯æœ€è¿‘0çš„ä½ç½®å³å¯ã€‚åœ¨æ’å…¥çš„æ—¶å€™å¦‚æœæ’å…¥å·¦è¾¹é‚£å°±æŠŠå·¦è¾¹å’Œå·¦è¾¹æœ€è¿‘çš„0ä¹‹é—´çš„æ•°å­—è¿›è¡Œä¿®æ”¹ï¼Œå³è¾¹åŒç†ã€‚è¿™æ ·æ¯ä¸€ä¸ª0æœ€å¤šè¢«éå†åˆ°2éï¼Œé‚£ä¹ˆå‡æ‘Šå¤æ‚åº¦å°±æ˜¯$o(n)$çš„ã€‚

ç„¶è€Œè¯»é¢˜è¯»æ­ªäº†è¿‡ä¸€ä¼šåœ¨å†™ã€‚

### 11.P3750åˆ†æ‰‹æ—¶ç¥æ„¿

é¢˜ç›®å¤§æ„ï¼šç»™å®šnä¸ªå¼€å…³ï¼Œæ¯ä¸€ä¸ªå¼€å…³æŒ‰ä¸‹çš„æ—¶å€™èƒ½è®©å…¶æ‰€æœ‰çš„çº¦æ•°éƒ½æ”¹å˜çŠ¶æ€å½“å‰çŠ¶æ€åªè¦å°äºç­‰äºkæ¬¡çš„è¯ä»–å›æŒ‰ç…§æœ€ä¼˜æ–¹æ¡ˆæŒ‰å¼€å…³ï¼Œå¦åˆ™éšæœºæŒ‰å¼€å…³ï¼Œæ±‚æœŸæœ›æŒ‰å‡ æ¬¡å¼€å…³ã€‚

é¢˜ç›®åˆ†æï¼šæ˜“å¾—æ¯ä¸ªå¼€å…³æŒ‰ä¸¤æ¬¡ç­‰äºæ²¡æœ‰æŒ‰ï¼Œé‚£ä¹ˆæ¯ä¸€ä¸ªå¼€å…³é¡¶å¤šæŒ‰ä¸€æ¬¡ï¼Œè®¾è®¡çŠ¶æ€ï¼Œ$dp[i]$ä¸ºæœ‰iä¸ªå¼€å…³ä¸ä¸€æ ·çš„æ—¶å€™æŠŠçŠ¶æ€æŒ‰åˆ°dp[i-1]è¦çš„æœŸæœ›æ“ä½œæ¬¡æ•°ã€‚é‚£ä¹ˆå®¹æ˜“å¾—åˆ°$dp[i]=\frac{(n-i)(1+dp[i+1]+dp[i])}{n}+\frac{i}{n}$ï¼Œç„¶åç´¯åŠ å°±å¥½äº†æã€‚

ä»£ç ï¼š

```c++

//
// Created by mrx on 2022/7/10.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;
const long long mod = 100003;

ll quickPow(ll base, ll fact) {
    ll ans = 1;
    while (fact) {
        if (fact & 1) ans = ans * base % mod;
        base = base * base % mod;
        fact >>= 1;
    }
    return ans;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    long long n, k;
    cin >> n >> k;
    long long cnt = 0;
    vector<long long> a(n + 1);
    for (long long i = 1; i <= n; ++i)cin >> a[i];
    for (long long i = n; i; --i) {
        if (a[i]) {
            cnt++;
            for (long long j = 1; j * j <= i; ++j) {
                if (i % j == 0) {
                    if (j * j != i) {
                        a[j] ^= 1, a[i / j] ^= 1;
                    } else {
                        a[j] ^= 1;
                    }
                }
            }
        }
    }
    vector<long long> dp(n + 2, 0);
    dp[n + 1] = 0;
    for (long long i = n; i; --i) {
        dp[i] = (n + (n - i) * (dp[i + 1]) % mod) % mod * quickPow(i, mod - 2) % mod;
    }
    long long ans = 0;
    if (k >= cnt) {
        ans = cnt;
    } else {
        for (int i = cnt; i > k; --i)ans = (ans + dp[i]) % mod;
        ans = (ans + k) % mod;
    }
    for (int i = 1; i <= n; ++i)ans = ans * i % mod;
    cout << ans << endl;
    return 0;
}
```

### 12.P5249åŠ ç‰¹æ—è½®ç›˜èµŒ

å¤§æ„ï¼šæ¯ä¸ªäººæ¯è½®æœ‰pçš„æ¦‚ç‡æŒ‚æ‰ï¼Œæ±‚nä¸ªäººç¬¬kä¸ªäººå­˜æ´»åˆ°æœ€åçš„æ¦‚ç‡ã€‚

åˆ†æï¼šå‡è®¾$dp[i][j]$ä¸ºå­˜æ´»iä¸ªäººæ—¶jæ´»åˆ°æœ€åçš„æ¦‚ç‡ï¼Œé‚£ä¹ˆæœ‰åˆå§‹æ¡ä»¶$dp[1][1]=1$,æœ€ç»ˆç­”æ¡ˆï¼š$dp[n][m]$ã€‚å¹¶ä¸”å¯ä»¥éå¸¸å¿«å¾—çš„åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š$dp[i][j]=p*dp[i-1][j-1]+(1-p)*dp[i][j-1]$,ä½†æ˜¯è¿™æ ·å°±å‡ºç°äº†åæ•ˆæ€§ï¼Œé‚£ä¹ˆè€ƒè™‘æ¶ˆå…ƒï¼Œçœ‹äº†çœ¼æ•°æ®å‘ç°ææ­»æ¶ˆå…ƒä¼štã€‚é‚£ä¹ˆè€ƒè™‘è¿™ä¸ªæ•°æ®çš„æ€§è´¨ï¼Œå‘ç°$\sum_{j=1}^{i} dp[i][j]=1$é€šè¿‡ä¸€ç•ªåœ¨è‰ç¨¿çº¸ä¸Šçš„æš´åŠ›æ¨æ¼”ï¼Œæ±‚ç¬¬iè¡Œçš„æ—¶å€™i-1è¡Œå·²ç»æ±‚å‡ºæ¥äº†ï¼Œé‚£ä¹ˆä¸Šé¢çš„æŸ¿å­å¯ä»¥åŒ–ç®€æˆ$a*dp[i][1]+b=1$çš„å½¢å¼ã€‚æ˜“å¾—$a = \sum_{x=0}^{i-1}(1-p)^x$ï¼Œ$b=\sum_{x=0}^{i-2}(dp[i-1][x]*\sum_{y=0}^{x}(1-p)^y)$,ç„¶åå¯¹$\sum_{x=0}^{i-1}(1-p)^x$æä¸ªå°å°çš„å‰ç¼€å’Œï¼Œå°±å¯ä»¥éå¸¸æ–¹ä¾¿å¾—æ±‚å‡ºæ¥$dp[i][1]$äº†ã€‚æ€»æ—¶é—´å¤æ‚åº¦ä¸º$O(n^2)$.

ä»£ç ï¼š

```c++
//
// Created by mrx on 2022/7/11.
//

#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

long long exgcd(long long a, long long b, long long &x, long long &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    ll d = exgcd(b, a % b, x, y);
    ll t = x;
    x = y;
    y = t - a / b * x;
    return d;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    double p;
    int n, k;
    cin >> p >> n >> k;
    vector<vector<double>> dp(2, vector<double>(n + 1, 0));
    vector<double> p2(n + 1, 0), sum(n + 1, 0);
    sum[0] = 1, p2[0] = 1;
    for (int i = 1; i <= n; ++i) {
        p2[i] = p2[i - 1] * (1 - p);
        sum[i] = sum[i - 1] + p2[i];
    }
    if (p == 0) {
        cout << 0 << endl;
        return 0;
    }
    dp[1][1] = 1;
    for (int i = 2; i <= n; ++i) {
        double a = sum[i - 1];
        double b = 0;
        for (int j = 0; j <= i - 2; ++j) {
            b += p * dp[(i - 1) % 2][i - 1 - j] * sum[j];
        }
        dp[i % 2][1] = (1 - b) / a;
        for (int j = 2; j <= i; ++j) {
            dp[i % 2][j] = dp[(i - 1) % 2][j - 1] * p + dp[i % 2][j - 1] * (1 - p);
        }
    }
    cout << fixed << setprecision(9) << dp[n % 2][k] << endl;
    return 0;
}
```

### 13.Chiitoitsu(nowcoder multi1 I)

é¢˜ç›®å¤§æ„ï¼šç»™34ç§ç‰Œï¼Œæ¯ç§ç‰Œæœ‰4å¼ ï¼Œåˆå§‹æ‘¸13å¼ æ‰‹ç‰Œï¼Œæ¯è½®è¦è¿›è¡Œæ‘¸ç‰Œå’Œå¼ƒç‰Œï¼Œé—®æ‘¸ç‰Œåèƒ½æ°å¥½åŒ¹é…å‡º7å¯¹ç‰Œçš„æœŸæœ›ã€‚

é¢˜ç›®åˆ†æï¼šè€ƒè™‘æœ€ä¼˜çš„ç­–ç•¥ï¼Œç©å®¶æ— ç‰Œå¯å¼ƒçš„æ—¶å€™æ‰ä¼šå¼ƒåˆå§‹æ‰‹ç‰Œï¼Œæ‰€ä»¥è¿™ä¸ªé¢˜çš„æœ€ä¼˜å†³ç­–æ˜¯æ¯æ¬¡å–å‡ºæ¥çš„ç‰Œå¦‚æœä¸èƒ½å’Œè‡ªå·±å·²æœ‰çš„å•ç‰ŒåŒ¹é…å°±å¼ƒæ‰ï¼Œæ‰€ä»¥è€ƒè™‘æ¦‚ç‡dpä»¤$dp[i][j]$ä¸ºè¿›è¡Œiè½®æ‰‹ç‰Œä¸­æœ‰jå¯¹åŒ¹é…çš„ç‰Œï¼Œé‚£ä¹ˆåˆå§‹çŠ¶æ€å°±æ˜¯åˆå§‹æ‰‹ç‰Œçš„å¯¹å­æ•°ï¼Œå…¶æ¦‚ç‡ä¸º1ï¼Œç»ˆæ­¢çŠ¶æ€å°±æ˜¯æ‰€æœ‰è½®ä¸­æ‰‹ä¸­æœ‰7å¯¹åŒ¹é…çš„ç‰Œã€‚è€ƒè™‘çŠ¶æ€è½¬ç§»ï¼Œ$dp[i+1][j]=dp[i][j-1]*3\frac{13-2*j+2}{123-i}+dp[i][j]*\frac{123-i-13+2*j}{123-i}$å› ä¸ºæœ€åç®—çš„æ˜¯æœŸæœ›ï¼Œé‚£ä¹ˆåªè¦æŠŠè½®æ•°å’Œæ¯è½®èƒ½è·èƒœçš„æ¦‚ç‡ä¹˜èµ·æ¥ç„¶åæ±‚å’Œå³å¯ã€‚

ä»£ç ï¼š

```c++
#include <bits/stdc++.h>

using ll = long long;
const ll mod = 1e9 + 7;

ll quickPow(ll base, ll fact) {
    ll ans = 1;
    while (fact) {
        if (fact & 1) ans = ans * base % mod;
        base = base * base % mod;
        fact >>= 1;
    }
    return ans;
}

ll ans[7] = {0};

void sol(int n) {
    std::vector<std::vector<ll>> dp(125, std::vector<ll>(15, 0));
    //opt,paircnt
    dp[0][n] = 1;
    for (int j = 0; j <= 6; ++j) {
        for (int i = 0; i <= 123; ++i) {
            int need = (13 - 2 * j) * 3;
            int rem = 123 - i;
            if (rem < need)break;
            dp[i + 1][j + 1] += need * quickPow(rem, mod - 2) % mod * dp[i][j] % mod;
            dp[i + 1][j + 1] %= mod;
            dp[i + 1][j] += (rem - need) * quickPow(rem, mod - 2) % mod * dp[i][j] % mod;
            dp[i + 1][j] %= mod;
        }
    }
    for (int i = 0; i <= 123; ++i) {
        ans[n] += i * dp[i][7] % mod;
        ans[n] %= mod;
    }

}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    for (int i = 0; i <= 6; ++i) {
        sol(i);
    }
    int t;
    std::cin >> t;
    for (int i = 1; i <= t; ++i) {
        std::map<std::pair<int, char>, int> mp;
        for (int j = 1; j <= 13; ++j) {
            char c;
            int x;
            std::cin >> x >> c;
            mp[std::make_pair(x, c)]++;
        }
        std::cout << "Case #" << i << ": " << ans[13 - mp.size()] << std::endl;

    }
    return 0;
}
```

### 14.Jee, You See?(CF1670F)

é¢˜ç›®å¤§æ„ï¼šç»™å®š 4 ä¸ªæ•´æ•° $n,l,r,z$ ($1 \le n \le 1000,1 \le l \le r \le 10^{18},1 \le z \le 10^{18}$

æ±‚æ»¡è¶³ä¸€ä¸‹æ¡ä»¶çš„åºåˆ— $a$ çš„ä¸ªæ•°ï¼š

1. $a_i$ ä¸ºéè´Ÿæ•´æ•°
2. $l \le a_1 + a_2 + \dots a_n \le r $
3. $a_1 \oplus a_2 \oplus \dots \oplus a_n = z$

å…¶ä¸­ $\oplus$ è¡¨ç¤ºäºŒè¿›åˆ¶æŒ‰ä½å¼‚æˆ–è¿ç®—

ç­”æ¡ˆå¯¹ $10^9 + 7$ å–æ¨¡

é¢˜ç›®åˆ†æï¼šç±»ä¼¼äºæ•°ä½dpï¼Œè®¾è®¡ä¸€ä¸‹çŠ¶æ€ï¼Œ$dp[i][j]$ä¸ºi-1ä½æ»¡è¶³è¦æ±‚ï¼Œç¬¬iä½å¯ä»¥é€‰jä¸ª1ï¼ˆåŒ…æ‹¬é€‰0åˆ°jä¸ª1çš„æ‰€æœ‰çŠ¶æ€ï¼‰çš„nå…ƒç»„ç§ç±»ä¸ªæ•°ã€‚é‚£ä¹ˆè€ƒè™‘çŠ¶æ€è½¬ç§»ï¼Œé‚£ä¹ˆå¯¹äºç¬¬i-1ä½ï¼Œå¯¹äºi-1ä½ï¼Œæšä¸¾ kä¸ª1ï¼Œå°±æœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š$dp[i-1][j*2+(r>>i-1)\and 1-k]=dp[i][j]*C_j^k$	ï¼Œåœ¨æšä¸¾i-1ä½çš„æ—¶å€™ï¼Œè€ƒè™‘ç¬¬äºŒä¸ªçº¦æŸæ¡ä»¶ï¼Œå³å¯¹åº”å–kå–å¥‡æ•°è¿˜æ˜¯å¶æ•°ã€‚

ä»£ç ï¼š

```c++
//
// Created by mrx on 2022/7/19.
//

#include <bits/stdc++.h>

using ll = long long;
const ll mod = 1e9 + 7;

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    ll n, l, r, z;
    std::cin >> n >> l >> r >> z;
    std::vector<std::vector<ll>> C(n + 1, std::vector<ll>(n + 1));
    C[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= i; ++j) {
            if (j == 0)C[i][j] = 1;
            else C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
        }
    }

    auto sol = [&](ll x) {
        std::vector<std::vector<ll>> dp(62, std::vector<ll>(n + 1, 0));
        dp[61][0] = 1;
        for (ll i = 60; i >= 0; --i) {
            for (ll j = 0; j <= n; ++j) {
                ll canChoose = 2 * j + (x >> i & 1);
                for (ll k = (z >> i & 1); k <= n && k <= canChoose; k += 2) {
                    dp[i][std::min(canChoose - k, n)] += dp[i + 1][j] * C[n][k] % mod;
                    dp[i][std::min(canChoose - k, n)] %= mod;
                }
            }
        }
        ll ans = 0;
        for (int i = 0; i <= n; ++i)ans = (ans + dp[0][i]) % mod;
        return ans;
    };
    std::cout << (sol(r) - sol(l - 1) + mod) % mod << std::endl;

    return 0;
}
```

### 15.æ ¡å†…èµ› æ¦‚ç‡è®ºä¸æ•°ç†ç»Ÿè®¡

é¢˜ç›®æè¿°ï¼š

è¿™å¤©ç©ºæ´å¤§å¸ˆzzkåœ¨æ•™gyxæ‰“éš”è†œï¼Œè€ƒè™‘åˆ°gyxçš„æ‰‹æ®‹ä½“è´¨ï¼Œå¤§å¸ˆå†³å®šæ•™ä»–åˆ®ç—§æµæ‰“æ³•ã€‚

æ‰€è°“åˆ®ç—§æµå³æ‰“ä¸€æ¬¡å°±è·‘ï¼Œå…·ä½“çš„,gyxæ¯æ¬¡æ”»å‡»å¯ä»¥ä½¿é€‰å®šçš„ç›®æ ‡ç”Ÿå‘½å€¼-1ï¼Œå¯ä»¥æ”»å‡»mæ¬¡ã€‚

æ•™ç¨‹å…³ä¸€å…±æœ‰nä¸ªæ€ªç‰©ï¼Œç¬¬iä¸ªç”Ÿå‘½å€¼ä¸º$a_i$ï¼Œéƒ½æ²¡æœ‰æ”»å‡»åŠ›ï¼Œæ’æˆä¸€æ’ç­‰ç€æŒ¨æ‰“ã€‚

ä½†æ˜¯ç”±äºä¸ä¼šæ“ä½œ,gyxè¿˜æ˜¯åªä¼šä¹±ç ï¼Œæ‰€ä»¥æ¯æ¬¡è¡ŒåŠ¨ä»–ä¼šéšæœºé€‰ä¸€ä¸ªå½“å‰ç”Ÿå‘½å€¼ä¸ºæ­£æ•°çš„æ€ªç‰©æ”»å‡»ã€‚

ä½œä¸ºæ¦‚ç‡è®ºå¤§å¸ˆçš„æŸ´è€å¸ˆè§‰å¾—è¿™ä¸ªè¿‡ç¨‹å¾ˆæœ‰è¶£ï¼Œäºæ˜¯æƒ³äº†ä¸€é“é¢˜ï¼šç»è¿‡mæ¬¡æ”»å‡»å,gyxèƒ½å‡»è´¥çš„æ€ªç‰©æœŸæœ›æ•°ã€‚

ç§°ä¸€ä¸ªæ€ªç‰©è¢«å‡»è´¥ï¼Œå½“ä¸”ä»…å½“æŸä¸€æ—¶åˆ»å…¶ç”Ÿå‘½å€¼=0ã€‚

é¢˜ç›®åˆ†æï¼š

ä¹ä¸€çœ‹å¥½åƒæ¯ä¸€æ¬¡è®©ä¸€ä¸ªæ€ªç‰©æ‰£è¡€çš„æ¦‚ç‡éƒ½å’Œåœºä¸Šå­˜æ´»çš„æ€ªç‰©æ•°é‡æœ‰å…³ç³»ï¼Œåˆæ³¨æ„åˆ°nå¾ˆå°ï¼Œå®¹æ˜“æƒ³åˆ°ä½¿ç”¨çŠ¶æ€å‹ç¼©ã€‚è®°$dp[s][i]$ä¸ºæ”»å‡»äº† $i$æ¬¡ï¼Œæœ‰$s$è¿™ä¸ªçŠ¶æ€çš„æ€ªç‰©æ­»äº†çš„æ¦‚ç‡ã€‚é‚£ä¹ˆæœ€åçš„ç­”æ¡ˆå°±æ˜¯æ”»å‡»mæ¬¡ä¹‹åæ¯ä¸ªçŠ¶æ€çš„popcountä¹˜ä»¥æ¦‚ç‡ä¹˜ä»¥å…¶ä½™æ€ªç‰©æ´»ç€çš„æ–¹æ¡ˆã€‚è®°$g[s][i]$ä¸ºç äº†$i$æ¬¡ï¼Œæœ‰$s$è¿™äº›æ€ªç‰©æ´»ç€çš„æ–¹æ¡ˆæ•°ã€‚é‚£ä¹ˆå¯ä»¥åˆ†åˆ«å¾—åˆ°$dp$å’Œ$g$çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š

å¦‚æœç¬¬$i+1$åˆ€ç æ­»äº†ä¸€ä¸ªæ€ªç‰©ï¼Œé‚£ä¹ˆ$dp[s][i]->dp[s|(1<<j)][i+1]$ï¼Œå…¶æ¦‚ç‡ä¸º${{a[j]-1}\choose {i - sum[s]}}/ popcount(s)$ã€‚å› ä¸ºè¦ç¡®ä¿åœ¨i+1æ€æ­»è¿™ä¸ªæ€ªç‰©ï¼Œé‚£ä¹ˆç¬¬iåˆ€å·²ç»æ€äº† $a[j]-1$ åˆ€äº†ã€‚å¦‚æœæ²¡ç æ­»ï¼Œé‚£ä¹ˆå°±ç›´æ¥è½¬ç§»åˆ°$dp[s][i+1]$

è€ƒè™‘å¦‚ä½•è®¡ç®— $g[s][i]$ ,è¿™ä¸ªå°±æ ¹èƒŒåŒ…ç±»ä¼¼ã€‚

ä»£ç 

```c++
//
// Created by mrx on 2022/10/4.
//
#include <vector>
#include <algorithm>
#include <iostream>
#include <array>
#include <cmath>
#include <iomanip>


int lowbit(int x) {
	return x & -x;
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n, m;
	std::cin >> n >> m;

	std::vector<std::vector<long double>> C(105, std::vector<long double>(105));
	C[0][0] = 1;
	for (int i = 1; i <= 100; ++i) {
		C[i][0] = 1;
		for (int j = 1; j <= 100; ++j) {
			C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
		}
	}

	std::vector<int> a(n);
	for (int i = 0; i < n; ++i)std::cin >> a[i];

	std::vector<int> sum(1 << n);
	for (int s = 0; s < 1 << n; ++s) for (int i = 0; i < n; ++i) if (s >> i & 1)sum[s] += a[i];

	std::vector<std::vector<long double>> g(m + 1, std::vector<long double>(1 << n));
	//å™¶iåˆ€ï¼Œå­˜æ´»çŠ¶æ€ä¸ºsçš„æ–¹æ¡ˆæ•°é‡ã€‚
	g[0][0] = 1;
	for (int s = 0; s < 1 << n; ++s) {
		for (int k = 0; k < n; ++k) {
			if ((s >> k) & 1) {
				int s0 = s ^ (1 << k);
				for (int i = 0; i <= m; ++i) {
					for (int j = 0; j <= std::min(a[k] - 1, i); ++j) {
						g[i][s] += g[i - j][s0] * C[i][j];
					}
				}
				break;
			}
		}
	}


	std::vector<std::vector<long double>> dp(m + 1, std::vector<long double>(1 << n));
	//å™¶iåˆ€ï¼ŒçŠ¶æ€ä¸ºsçš„æŒ‚äº†çš„æ¦‚ç‡
	dp[0][0] = 1;
	for (int s = 0; s < 1 << n; ++s) {
		int cur = __builtin_popcount(s);
		int cnt = n - cur;
		for (int now = sum[s]; now < m; ++now) {
			int rem = ((1 << n) - 1) ^ s;
			for (int j = 0; j < n; ++j) {
				if (!((s >> j) & 1)) {
					if (a[j] - 1 <= now - sum[s])dp[now + 1][s | (1 << j)] += dp[now][s] * C[now - sum[s]][a[j] - 1] / cnt;
				}
			}
			dp[now + 1][s] += dp[now][s] / cnt;
		}
	}

	for (int s = 0; s < 1 << n; ++s) {
		for (int i = 0; i <= m; ++i) {
			if (i < sum[s])continue;
			int rem = ((1 << n) - 1) ^ s;
			dp[i][s] *= g[i - sum[s]][rem];
		}
	}

	long double ans = 0;
	for (int s = 0; s < 1 << n; ++s) {
		if (m < sum[s])continue;
		int cnt = __builtin_popcount(s);
		ans += dp[m][s] * cnt;
	}
	std::cout << std::fixed << std::setprecision(5) << ans << '\n';
	return 0;
}
```

### 16.Damaged Bicycle 2021Harbin

**é¢˜æ„**

ç»™å®šä¸€ä¸ªæ— å‘å›¾ï¼Œä½ è¦ä»1å·ç‚¹å‡ºå‘å»å¾€nå·ç‚¹ï¼Œè¿™å¼ å›¾ä¸­æœ‰kä¸ªè‡ªè¡Œè½¦ï¼Œåˆ†åˆ«æœ‰$p_i$çš„æ¦‚ç‡æ˜¯å¥½çš„ï¼Œæ­¥è¡Œçš„é€Ÿåº¦ä¸º$t$,éª‘è½¦çš„é€Ÿåº¦ä¸º$r$,æ±‚å…¶æ‰€æ¶ˆè€—æ—¶é—´ æœŸæœ›å€¼ï¼Œå¦‚æœåˆ°ä¸äº†ï¼Œè¾“å‡º-1.

**åˆ†æ**

å¯¹äºæ¯ä¸ªç‚¹ï¼Œä¸‹ä¸€æ­¥çš„é€‰æ‹©è‚¯å®šæ˜¯é€‰æ‹©æ¥ä¸‹æ¥çŠ¶æ€ä¸­æœŸæœ›ç”¨æ—¶æœ€å°çš„ã€‚ç„¶åä¼šå‘ç°å¾ˆå¤šç‚¹éƒ½æ˜¯æ²¡ç”¨çš„ï¼Œæœ€ç»ˆæœ‰ç”¨çš„ç‚¹éƒ½æ˜¯æœ‰è‡ªè¡Œè½¦çš„ç‚¹å’Œèµ·ç‚¹ç»ˆç‚¹ã€‚ç„¶åå°±èƒ½å˜æˆkä¸ªç‚¹ï¼Œè®¾$dp[s][i]$ä¸ºsè¿™ä¸ªçš„è‡ªè¡Œè½¦ç‚¹çŠ¶æ€æ²¡æœ‰å»è¿‡ï¼Œåœç•™åœ¨$i$ç‚¹åˆ°è¾¾$n$æœŸæœ›æ¶ˆè€—æ—¶é—´ã€‚çŠ¶æ€è½¬ç§»å°±æ˜¯å¦‚æœè¿™ä¸ªåœ°æ–¹æ²¡è‡ªè¡Œè½¦ï¼Œä¸ºç›´æ¥èµ°åˆ°ç»ˆç‚¹æ¶ˆè€—çš„æ—¶é—´å’Œå»å¾€å…¶ä»–æœ‰è½¦ç‚¹çš„æœŸæœ›æœ€å°å€¼ï¼Œå¦åˆ™ä¸ºéª‘è½¦åˆ°ç»ˆç‚¹çš„æœŸæœ›æ—¶é—´ã€‚è¿™ä¸ªè¿‡ç¨‹å¯ä»¥ç”¨dfsæ¥åšã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/10/28.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

#include <iomanip>

using i64 = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int t, r;
	std::cin >> t >> r;
	int n, m;
	std::cin >> n >> m;
	std::vector<std::vector<std::pair<int, int>>> adj(n + 1);
	for (int i = 0; i < m; ++i) {
		int u, v, w;
		std::cin >> u >> v >> w;
		adj[u].emplace_back(v, w);
		adj[v].emplace_back(u, w);
	}

	int k;
	std::cin >> k;
	std::vector<std::vector<std::pair<int, int>>> adj2(k + 2);
	std::vector<int> prob(k + 2);
	std::vector<int> gra_2(k + 2);
	gra_2[0] = 1;
	gra_2[k + 1] = n;
	prob[0] = 100;
	for (int i = 1; i <= k; ++i) {
		std::cin >> gra_2[i] >> prob[i];
	}

	std::vector mp(k + 2, std::vector<int>(k + 2, 0));

	for (int i = 0; i <= k + 1; ++i) {
		std::vector<int> dis(n + 1, 0x3f3f3f3f);
		auto dij = [&](int start) {
			std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<>> q;
			dis[start] = 0;
			q.emplace(0, start);
			while (!q.empty()) {
				auto [dist, u] = q.top();
				q.pop();
				if (dis[u] != dist)continue;
				for (auto [v, w]: adj[u]) {
					if (dis[v] > dis[u] + w) {
						dis[v] = dis[u] + w;
						q.emplace(dis[v], v);
					}
				}
			}
		};

		dij(gra_2[i]);
		for (int j = 0; j <= k + 1; ++j)mp[i][j] = dis[gra_2[j]];
	}

//	for (int i = 0; i <= k + 1; ++i) {
//		for (int j = 0; j <= k + 1; ++j)std::cout << mp[i][j] << ' ';
//		std::cout << '\n';
//	}
	if (mp[0][k + 1] == 0x3f3f3f3f)std::cout << -1 << '\n';
	else {

		std::vector dp(1 << (k + 2), std::vector<double>(k + 2, -1));
		std::function<double(int, int)> dfs = [&](int s, int x) {
			if (dp[s][x] >= 0)return dp[s][x];
			if (!s) {
				return dp[s][x] = 0.01 * (100 - prob[x]) * mp[x][k + 1] / r + 0.01 * prob[x] * mp[x][k + 1] / t;
			}
			double cur = 1.0 * mp[x][k + 1] / t;
			for (int i = 0; i <= k; ++i) {
				if ((s >> i & 1) && mp[x][gra_2[i + 1]] < 0x3f3f3f3f) {
					cur = std::min(cur, 1.0 * mp[x][i + 1] / t + dfs(s ^ 1 << i, i + 1));
				}
			}
			return dp[s][x] = 0.01 * (100 - prob[x]) * mp[x][k + 1] / r + 0.01 * prob[x] * cur;
		};
		double ans = dfs((1 << (k + 1)) - 1, 0);
		std::cout << std::fixed << std::setprecision(6) << ans << '\n';
	}

	return 0;
}
```



### 17.Race to 1 UVA11762

**é¢˜ç›®å¤§æ„**

ç»™å®šä¸€ä¸ªæ•´æ•°Nï¼Œæ¯æ¬¡ä»ä¸è¶…è¿‡Nçš„ç´ æ•°ä¸­ç­‰æ¦‚ç‡éšæœºé€‰ä¸€ä¸ªp è‹¥p|Nï¼Œåˆ™ä»¤N /= p, å¦åˆ™ä¸å˜ï¼Œé—®æœŸæœ›å‡ æ¬¡èƒ½å¤ŸæŠŠ N å˜æˆ1

**é¢˜ç›®åˆ†æ**

å¯¹äºä¸€ä¸ªæ•°å­—$x$å¾ˆå®¹æ˜“å¾—åˆ°å…¶çŠ¶æ€è½¬ç§»ï¼Œå…ˆç­›å‡ºæ¥æ‰€æœ‰çš„è´¨æ•°ï¼Œç„¶åè®°å¿†åŒ–æœç´¢å³å¯ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/10/30.
//


#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <iomanip>
#include <map>

using i64 = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	std::vector<int> prime;
	{
		std::vector<int> vis(1000006);
		for (int i = 2; i <= 1e6; ++i) {
			if (!vis[i])prime.push_back(i);
			for (int j = 0; j < prime.size() && i * prime[j] <= 1e6; ++j) {
				vis[i * prime[j]] = 1;
				if (i % prime[j] == 0)break;
			}
		}
	}

	std::vector<double> dp(1000006);
	std::vector<bool> vis(1000006, false);
	dp[1] = 0;
	vis[1] = true;

	int t;
	std::cin >> t;
	for (int cas = 1; cas <= t; ++cas) {
		int n;
		std::cin >> n;
		std::function<double(int)> dfs = [&](int x) {
			if (vis[x])return dp[x];

			vis[x] = true;

			auto& ans = dp[x];
			ans = 0;
			int useful = 0;
			int cnt = 0;
			for (int i = 0; i < prime.size() && prime[i] <= x; ++i) {
				cnt++;
				if (x % prime[i] == 0) {
					useful++;
					ans += dfs(x / prime[i]);
				}
			}
			ans = (ans + cnt) / useful;
			return ans;

		};
		double ans = dfs(n);
		std::cout << "Case " << cas << ": " << std::fixed << std::setprecision(10) << ans << '\n';
	}
	return 0;
}
```



### 18.2021æ˜†æ˜G

é¢˜æ„ï¼šç»™ä¸€ä¸ªåºåˆ—ï¼Œæ¯ä¸ªæ•°å­—éƒ½æœ‰$p_i$çš„æ¦‚ç‡è¢«é€‰ä¸­ï¼Œé€‰ä¸­åæŠŠå®ƒæ’åˆ°ç¬¬ä¸€ä½ï¼Œå¹¶å®šä¹‰è´¡çŒ®ä¸ºä½ç§»å¤šå°‘ä½ã€‚æ±‚ç¬¬$1145^{141919}$æ¬¡æ“ä½œæ—¶äº§ç”Ÿè´¡çŒ®çš„æœŸæœ›ã€‚

å› ä¸ºæ˜¯æ— é™è½®ï¼Œé‚£ä¹ˆç­”æ¡ˆå¯ä»¥è½¬åŒ–ä¸ºæ¯ä¸€ä¸ªæ•°å­—æ‰€åœ¨ä½ç½®çš„æœŸæœ›-1ä¹˜ä»¥å…¶è¢«é€‰ä¸­çš„æ¦‚ç‡ç„¶åæ±‚å’Œã€‚

å¾ˆå¤šé¢˜éƒ½æœ‰è¿™æ ·çš„æ€è·¯ï¼Œç°åœ¨æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªå…ƒç´ çš„ä½ç½®ï¼Œé‚£ä¹ˆå®ƒå’Œå¦å¤–çš„æŸä¸€ä¸ªå…ƒç´ ä¹‹é—´çš„å…³ç³»ï¼Œå¦‚æœä¸€ä¸ªå…ƒç´ åœ¨å¦ä¸€ä¸ªå…ƒç´ ä¹‹åè¢«é€‰ä¸­ï¼Œé‚£ä¹ˆå…¶ä»–çš„å…ƒç´ æ˜¯æ— å…³ç´§è¦çš„ï¼Œé‚£å°±å¯ä»¥çœ‹ä½œæ˜¯å¦ä¸€ä¸ªå…ƒç´ å¯¹è¿™ä¸ªå…ƒç´ ä½ç½®çš„è´¡çŒ®äº†ã€‚æ˜¾ç„¶å¦‚æœå…ƒç´ aåœ¨å…ƒç´ bå‰é¢è¢«é€‰ä¸­ï¼Œå…¶æ¦‚ç‡ä¸º$p_a/(p_a+p_b)$ã€‚ç„¶åå°±èƒ½æ±‚å‡ºæ¥æ‰€æœ‰å…ƒç´ çš„ä½ç½®äº†ã€‚è¿™æ˜¯ä¸ªå¾ˆç‰›é€¼çš„trickï¼

## å¤šé¡¹å¼

### 1.p3338åŠ›

é¢˜ç›®æè¿°

ç»™å‡º $n$ ä¸ªæ•° $q_1,q_2, \dots q_n$ï¼Œå®šä¹‰

$$F_j~=~\sum_{i = 1}^{j - 1} \frac{q_i \times q_j}{(i - j)^2}~-~\sum_{i = j + 1}^{n} \frac{q_i \times q_j}{(i - j)^2}$$

$$E_i~=~\frac{F_i}{q_i}$$

å¯¹ $1 \leq i \leq n$ï¼Œæ±‚ $E_i$ çš„å€¼ã€‚

è¾“å…¥æ ¼å¼

ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•° $n$ã€‚

ä»¥ä¸‹ $n$ è¡Œï¼Œæ¯è¡Œæœ‰ä¸€ä¸ªå®æ•°ã€‚ç¬¬ $i+1$ è¡Œçš„æ•°ä»£è¡¨ $q_i$ã€‚

è¾“å‡ºæ ¼å¼

è¾“å‡º $n$ è¡Œæ¯è¡Œä¸€ä¸ªå®æ•°ï¼Œç¬¬ $i$ è¡Œçš„æ•°å­—ä»£è¡¨ $E_i$ã€‚

å½“ä½ çš„è¾“å‡ºä¸æ ‡å‡†ç­”æ¡ˆç›¸å·®ä¸è¶…è¿‡ $10^{-2}$ æ—¶å³è¢«è®¤ä¸ºæ­£ç¡®ã€‚

é¢˜ç›®åˆ†æ

å¯¹ç»™å®šçš„æŸ¿å­è¿›è¡ŒåŒ–ç®€$F_j~=~\sum_{i = 1}^{j - 1} \frac{q_i \times q_j}{(i - j)^2}~-~\sum_{i = j + 1}^{n} \frac{q_i \times q_j}{(i - j)^2}$

å†åè½¬ä¸€ä¸‹å°±å¯ä»¥å˜æˆä¸¤ä¸ªå¤šé¡¹çš„å·é¸¡ï¼Œç„¶åè¾“å‡ºç­”æ¡ˆ

ä»£ç :

```c++
//
// Created by mrx on 2022/7/13.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

inline void FFT(vector<complex<long double>> &a, vector<long long> &inv, long long limit, int type) {
    if (limit == 1)return;
    for (int i = 0; i < limit; ++i) {
        if (i < inv[i])swap(a[i], a[inv[i]]);
    }
    for (long long mid = 1; mid < limit; mid <<= 1) {
        long long r = mid << 1;
        complex<long double> wn(cos(acos(-1) / mid), type * sin(acos(-1) / mid));
        for (long long i = 0; i < limit; i += r) {
            complex<long double> w(1, 0);
            for (long long k = i; k < i + mid; ++k) {
                complex<long double> u = a[k];
                complex<long double> t = w * a[k + mid];
                a[k] = u + t;
                a[k + mid] = u - t;
                w = w * wn;
            }
        }
    }
}

void sol() {
    int n;
    cin >> n;
    long long limit = 1;
    while (limit <= (n << 1))limit <<= 1;
    vector<complex<long double>> F(limit + 10), F2(limit + 10), Q(limit + 10);
    vector<long long> inv(limit + 10);
    for (int i = 0; i < limit; ++i) {
        inv[i] = (inv[i >> 1] >> 1) | ((i & 1) ? limit >> 1 : 0);
    }
    for (int i = 1; i <= n; ++i) {
        long double tmp;
        cin >> tmp;
        F[i].real(tmp);
        F2[n - i].real(tmp);
        Q[i].real((long double) (1.0 / i / i));
    }
    FFT(F, inv, limit, 1);
    FFT(F2, inv, limit, 1);
    FFT(Q, inv, limit, 1);
    for (int i = 0; i < limit; ++i) {
        F[i] = F[i] * Q[i];
        F2[i] = F2[i] * Q[i];
    }
    FFT(F, inv, limit, -1);
    FFT(F2, inv, limit, -1);
    for (int i = 1; i <= n; ++i) {
        long double ans1 = F[i].real() / limit;
        long double ans2 = F2[n - i].real() / limit;
        cout << fixed << setprecision(3) << ans1 - ans2 << endl;
    }
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int n;
    n = 1;
    while (n--)sol();
    return 0;
}
```

### 2.P5488å·®åˆ†å’Œå‰ç¼€å’Œ

é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªé•¿ä¸º $n$ çš„åºåˆ— $a$ï¼Œæ±‚å‡ºå…¶ $k$ é˜¶å·®åˆ†æˆ–å‰ç¼€å’Œã€‚    
ç»“æœçš„æ¯ä¸€é¡¹éƒ½éœ€è¦å¯¹ $1004535809$ å–æ¨¡ã€‚

è¾“å…¥æ ¼å¼

ç¬¬ä¸€è¡Œä¸‰ä¸ªæ•´æ•° $n,k,t$ï¼Œè‹¥ $t=0$ è¡¨ç¤ºæ±‚å‰ç¼€å’Œï¼Œ$t=1$ è¡¨ç¤ºæ±‚å·®åˆ†ã€‚  
ç¬¬äºŒè¡Œ $n$ ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºåºåˆ— $a$ã€‚

è¾“å‡ºæ ¼å¼

è¾“å‡ºä¸€è¡Œ $n$ ä¸ªæ•´æ•°ï¼Œè¡¨ç¤º $a$ çš„ $k$ é˜¶å·®åˆ†æˆ–å‰ç¼€å’Œã€‚

é¢˜ç›®åˆ†æ

æ±‚å‰ç¼€å’Œç›¸å½“äº$f(x)*(1+x+x^2+x^3...x^{n})$,æ±‚å·®åˆ†ç›¸å½“äº$f(x)*(1-x+x^2-x^3...(-x)^{n})$	ké˜¶å‰ç¼€å’Œå’Œå·®åˆ†ç›¸å½“åŸå¤šé¡¹å¼ä¹˜ä»¥è¿™ä¸¤ä¸ªçš„kæ¬¡æ–¹ï¼Œé€šè¿‡ä¸€ç‚¹ç®€å•çš„å¹‚çº§æ•°å’Œå‡½æ•°ä»¥åŠå±•å¼€çŸ¥è¯†å¯ä»¥å¾—åˆ°å…¶kè§£å·®åˆ†å¯¹åº”è½¬ç§»å¤šé¡¹å¼ï¼Œç„¶åå°±å¯ä»¥$O(nlogn)$ç®—å‡ºå…¶ké˜¶å‰ç¼€å’Œæ•°ç»„å’Œå·®åˆ†ã€‚

```c++
//
// Created by mrx on 2022/8/5.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, int b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    int val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

constexpr int mod = 1004535809;
using Z = Modular<mod>;
std::vector<int> rev;
std::vector<Z> roots{0, 1};

void dft(std::vector<Z> &a) {
    int n = a.size();

    if (int(rev.size()) != n) {
        rev.resize(n);
        for (int i = 0; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? n >> 1 : 0);
        }
    }

    for (int i = 0; i < n; ++i) {
        if (rev[i] < i)std::swap(a[i], a[rev[i]]);
    }
    if (int(roots.size() < n)) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
            Z e = power(Z(3), (mod - 1) >> (k + 1));
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[i << 1] = roots[i];
                roots[i << 1 | 1] = roots[i] * e;
            }
            k++;
        }
    }

    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}

void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
}

struct Poly {
    std::vector<Z> a;

    Poly() {}

    Poly(const std::vector<Z> &a) : a(a) {}

    Poly(const std::initializer_list<Z> &a) : a(a) {}

    int size() const {
        return a.size();
    }

    void resize(int n) {
        a.resize(n);
    }

    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }

    Z &operator[](int idx) {
        return a[idx];
    }

    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }

    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }

    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }

    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }

    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }

    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        Z inv = Z(sz).inv();
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i] * inv;
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }

    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < int(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }

    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }

    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }

    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }

    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }

    Poly deriv() const {
        if (a.empty()) {
            return Poly();
        }
        std::vector<Z> res(size() - 1);
        for (int i = 0; i < size() - 1; ++i) {
            res[i] = (i + 1) * a[i + 1];
        }
        return Poly(res);
    }

    Poly integr() const {
        std::vector<Z> res(size() + 1);
        for (int i = 0; i < size(); ++i) {
            res[i + 1] = a[i] / (i + 1);
        }
        return Poly(res);
    }

    Poly inv(int m) const {
        Poly x{a[0].inv()};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{2} - modxk(k) * x)).modxk(k);
        }
        return x.modxk(m);
    }

    Poly log(int m) const {
        return (deriv() * inv(m)).integr().modxk(m);
    }

    Poly exp(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{1} - x.log(k) + modxk(k))).modxk(k);
        }
        return x.modxk(m);
    }

    Poly pow(int k, int m) const {
        int i = 0;
        while (i < size() && a[i].val() == 0) {
            i++;
        }
        if (i == size() || 1LL * i * k >= m) {
            return Poly(std::vector<Z>(m));
        }
        Z v = a[i];
        auto f = divxk(i) * v.inv();
        return (f.log(m - i * k) * k).exp(m - i * k).mulxk(i * k) * power(v, k);
    }

    Poly sqrt(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((mod + 1) / 2);
        }
        return x.modxk(m);
    }

    Poly mulT(Poly b) const {
        if (b.size() == 0) {
            return Poly();
        }
        int n = b.size();
        std::reverse(b.a.begin(), b.a.end());
        return ((*this) * b).divxk(n - 1);
    }

    std::vector<Z> eval(std::vector<Z> x) const {
        if (size() == 0) {
            return std::vector<Z>(x.size(), 0);
        }
        const int n = std::max(int(x.size()), size());
        std::vector<Poly> q(4 * n);
        std::vector<Z> ans(x.size());
        x.resize(n);
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                q[p] = Poly{1, -x[l]};
            } else {
                int m = (l + r) / 2;
                build(2 * p, l, m);
                build(2 * p + 1, m, r);
                q[p] = q[2 * p] * q[2 * p + 1];
            }
        };
        build(1, 0, n);
        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {
            if (r - l == 1) {
                if (l < int(ans.size())) {
                    ans[l] = num[0];
                }
            } else {
                int m = (l + r) / 2;
                work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l));
                work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m));
            }
        };
        work(1, 0, n, mulT(q[1].inv(n)));
        return ans;
    }
};

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    freopen("o.txt", "w", stderr);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int n, opt;
    Z k;
    std::cin >> n;
    char cc = std::cin.get();
    ll cn = 0, flus = 1;
    while (cc < '0' || cc > '9') {
        if (cc == '-') flus = -flus;
        cc = std::cin.get();
    }
    while (cc >= '0' && cc <= '9') {
        cn = (cn * 10 + cc - '0') % (mod), cc = std::cin.get();
    }
    k = cn * flus;

    std::cin >> opt;
    std::vector<Z> a(n);
    for (int i = 0; i < n; ++i)std::cin >> a[i];
    Poly A(a);
    std::vector<Z> B(n);
    B[0] = 1;
    if (opt == 0) {
        for (int i = 1; i < n; ++i)B[i] = B[i - 1] * Z(k + i - 1) * power(Z(i), mod - 2);
    } else {
        for (int i = 1; i < n; ++i)B[i] = Z(-B[i - 1] * Z(k - i + 1) * power(Z(i), mod - 2));
    }
    Poly rhs(B);
    for (int i = 0; i < n; ++i)std::cerr << B[i] << ' ';
    Poly ans = A * rhs;
    for (int i = 0; i < n; ++i) std::cout << ans[i] << ' ';
    return 0;
}
```

### 3.CF755G PolandBall and Many Other Balls

é¢˜ç›®æè¿°

æœ‰ä¸€æ’ $n$ ä¸ªçƒï¼Œå®šä¹‰ä¸€ä¸ªç»„å¯ä»¥åªåŒ…å«ä¸€ä¸ªçƒæˆ–è€…åŒ…å«ä¸¤ä¸ªç›¸é‚»çš„çƒã€‚ç°åœ¨ä¸€ä¸ªçƒåªèƒ½åˆ†åˆ°ä¸€ä¸ªç»„ä¸­ï¼Œæ±‚ä»è¿™äº›çƒä¸­å–å‡º 1- $k$ ç»„çš„æ–¹æ¡ˆæ•°ã€‚

$n\le 10^9$ï¼Œ$k<2^{15}$ã€‚

é¢˜ç›®åˆ†æ

å¾ˆå®¹æ˜“å¯ä»¥æ¨å‡ºæ¥ä¸€ä¸ª$O(n*k)$çš„ç®€å•çš„dpï¼Œä¸”çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯$dp_{i,j}=dp_{i-1,j-1}+dp_{i-1,j}+dp_{i-2,j-1}$å°†ç¬¬äºŒç»´çš„dpè®¡ä¸ºç”Ÿæˆå‡½æ•°ï¼Œé‚£ä¹ˆå°±æœ‰$dp_{i}=(1+x)dp_{i-1}+x\cdot dp_{i-2}$è¿™æ ·å°±å¯ä»¥é€šè¿‡$dp_0,dp_1$å’Œå¤šé¡¹å¼æ„æˆçš„çŸ©é˜µå¿«é€Ÿèœœæ±‚å‡ºæ¥$dp_n$ç„¶åè¾“å‡ºç­”æ¡ˆå³å¯ã€‚è¿˜æœ‰ä¸€ç§æ–¹æ³•æ˜¯æ±‚å‡ºæ¥ç‰¹å¾æ–¹ç¨‹ï¼Œç„¶åç›´æ¥ç®—å‡ºæ¥ã€‚

```c++
//
// Created by mrx on 2022/8/5.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, int b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    int val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

constexpr int mod = 998244353;
using Z = Modular<mod>;

std::vector<int> rev;
std::vector<Z> roots{0, 1};

void dft(std::vector<Z> &a) {
    int n = a.size();

    if (int(rev.size()) != n) {
        rev.resize(n);
        for (int i = 0; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? n >> 1 : 0);
        }
    }

    for (int i = 0; i < n; ++i) {
        if (rev[i] < i)std::swap(a[i], a[rev[i]]);
    }
    if (int(roots.size() < n)) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
            Z e = power(Z(3), (mod - 1) >> (k + 1));
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[i << 1] = roots[i];
                roots[i << 1 | 1] = roots[i] * e;
            }
            k++;
        }
    }

    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}

void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
}

struct Poly {
    std::vector<Z> a;

    Poly() {}

    Poly(const std::vector<Z> &a) : a(a) {}

    Poly(const std::initializer_list<Z> &a) : a(a) {}

    int size() const {
        return a.size();
    }

    void resize(int n) {
        a.resize(n);
    }

    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }

    Z &operator[](int idx) {
        return a[idx];
    }

    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }

    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }

    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }

    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }

    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }

    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        Z inv = Z(sz).inv();
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i] * inv;
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }

    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < int(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }

    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }

    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }

    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }

    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }

    Poly deriv() const {
        if (a.empty()) {
            return Poly();
        }
        std::vector<Z> res(size() - 1);
        for (int i = 0; i < size() - 1; ++i) {
            res[i] = (i + 1) * a[i + 1];
        }
        return Poly(res);
    }

    Poly integr() const {
        std::vector<Z> res(size() + 1);
        for (int i = 0; i < size(); ++i) {
            res[i + 1] = a[i] / (i + 1);
        }
        return Poly(res);
    }

    Poly inv(int m) const {
        Poly x{a[0].inv()};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{2} - modxk(k) * x)).modxk(k);
        }
        return x.modxk(m);
    }

    Poly log(int m) const {
        return (deriv() * inv(m)).integr().modxk(m);
    }

    Poly exp(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{1} - x.log(k) + modxk(k))).modxk(k);
        }
        return x.modxk(m);
    }

    Poly pow(int k, int m) const {
        int i = 0;
        while (i < size() && a[i].val() == 0) {
            i++;
        }
        if (i == size() || 1LL * i * k >= m) {
            return Poly(std::vector<Z>(m));
        }
        Z v = a[i];
        auto f = divxk(i) * v.inv();
        return (f.log(m - i * k) * k).exp(m - i * k).mulxk(i * k) * power(v, k);
    }

    Poly sqrt(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((mod + 1) / 2);
        }
        return x.modxk(m);
    }

    Poly mulT(Poly b) const {
        if (b.size() == 0) {
            return Poly();
        }
        int n = b.size();
        std::reverse(b.a.begin(), b.a.end());
        return ((*this) * b).divxk(n - 1);
    }

    std::vector<Z> eval(std::vector<Z> x) const {
        if (size() == 0) {
            return std::vector<Z>(x.size(), 0);
        }
        const int n = std::max(int(x.size()), size());
        std::vector<Poly> q(4 * n);
        std::vector<Z> ans(x.size());
        x.resize(n);
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                q[p] = Poly{1, -x[l]};
            } else {
                int m = (l + r) / 2;
                build(2 * p, l, m);
                build(2 * p + 1, m, r);
                q[p] = q[2 * p] * q[2 * p + 1];
            }
        };
        build(1, 0, n);
        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {
            if (r - l == 1) {
                if (l < int(ans.size())) {
                    ans[l] = num[0];
                }
            } else {
                int m = (l + r) / 2;
                work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l));
                work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m));
            }
        };
        work(1, 0, n, mulT(q[1].inv(n)));
        return ans;
    }
};

int k;

struct matrix {
    std::vector<std::vector<Poly>> mat;
    ll n, m;

    matrix(ll a, ll b) {
        n = a, m = b;
        mat.resize(n);
        for (auto &x: mat)x.resize(m);
    }


    void E() {
        for (ll i = 0; i < std::min(n, m); ++i) {
            mat[i][i] = Poly({1});
        }
    }

    void show() {
        for (auto x: mat) {
            for (auto y: x) {
                for (auto &z: y.a)std::cout << z << ' ';
                std::cout << '*';
            }
            std::cout << std::endl;
        }
    }

    matrix operator*(const matrix &rhs) {
        matrix ans(n, rhs.m);
        if (m != rhs.n) {
            std::cerr << "Matrix not matching!";
        }
        for (ll i = 0; i < n; ++i) {
            for (ll j = 0; j < m; ++j) {
                for (ll k = 0; k < rhs.m; ++k) {
                    ans.mat[i][k] = (ans.mat[i][k] + mat[i][j] * rhs.mat[j][k]).modxk(::k + 1);
                }
            }
        }
        return ans;
    }

    friend matrix operator^(matrix bas, long long x) {
        matrix ans(bas.n, bas.n);
        ans.E();
        while (x) {
            if (x & 1) {
                ans = ans * bas;
            }
            bas = bas * bas;
            x >>= 1;
        }
        return ans;
    }

};

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int n;
    std::cin >> n >> k;
    //dp[i][j]=dp[i-1][j]+d[i-1][j-1]+dp[i-2][j-1]
    //f_n(x)ä¸ºnä¸ªçƒçš„ç”Ÿæˆå‡½æ•°ï¼Œ->f_n(x)=(x+1)f_n-1(x)+xf_n-2(x)
    //->ç»´æŠ¤çŸ©é˜µ(,,,)
    matrix a(2, 2);
    a.mat[0][0] = Poly{1, 1};
    a.mat[0][1] = Poly{0, 1};
    a.mat[1][0] = Poly{1};
    a.mat[1][1] = Poly{0};
    a = a ^ n;
    Poly a0 = {0};
    Poly a1 = {0, 1};
    Poly ans = a.mat[0][0] * a1 + a.mat[0][1] * a0;
    ans = ans.divxk(2);
    ans.a.resize(k);
    for (int i = 0; i < k; ++i)std::cout << ans[i] << ' ';
    return 0;
}
```

### 4.HDU7057Buying Snacks

**é¢˜ç›®å¤§æ„**

ç»™ n ç§é›¶é£Ÿï¼Œæ¯ä¸ªé›¶é£Ÿæœ‰å¤§å°åŒ…è£…ä¹‹åˆ†ï¼Œæœ‰ä¸‰ç§è´­ä¹°æ–¹æ¡ˆï¼Œä»·é’±åˆ†åˆ«å¦‚ä¸‹ï¼š

åªè´­ä¹°ä¸€ä¸ªå°çš„ï¼ŒèŠ±è´¹ä¸€å—é’±
åªç‹¬è´­ä¹°ä¸€ä¸ªå¤§çš„ï¼ŒèŠ±è´¹ä¸¤å—é’±
$ \forall i>1 $ï¼Œå¯ä»¥å’Œ ç¬¬$i-1$ç§é›¶é£Ÿæ†ç»‘è´­ä¹°ï¼Œå¯ä»¥ä¾¿å®œä¸€å—é’±
å¥¹æœ‰må…ƒé’±ï¼Œé—®å¥¹çš„ä¸åŒè´­ä¹°æ–¹æ¡ˆæ•°åˆ†åˆ«æ˜¯å¤šå°‘

**é¢˜ç›®åˆ†æ**

å¯ä»¥è€ƒè™‘å‡ºæ¥çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œ$dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+dp[i-1][j-2]+dp[i-2][j-1]+2dp[i-2][j-2]+dp[i-2][j-3]$

è½¬åŒ–ä¸ºç”Ÿæˆå‡½æ•°,$f_i=(1+x+x^2)f_{i-1}+(x+2x+x^3)f_i-2$,ç„¶ååˆ—å‡ºç‰¹å¾æ–¹ç¨‹ï¼Œ$Z^2=(1+X+X^2)Z+(X+2X^2+X^3)$æ±‚è§£å‡ºæ¥å¾—åˆ°$z_1=x^2+2x+1,z_2=-x$é€šè¿‡å·²çŸ¥æ¡ä»¶$f_0=1,f_1=1+x+x^2$è¿›è¡Œå¾…å®šç³»æ•°æ³•è§£æ–¹ç¨‹ï¼Œå¾—åˆ°é€šé¡¹å…¬å¼ï¼š$f_n=\frac{(x^2+2x+1)^{n+1}+(-1)^nx^{n+1}}{x^2+3x+1}$

```c++
//
// Created by mrx on 2022/8/6.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, int b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    int val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

constexpr int mod = 998244353;
using Z = Modular<mod>;

std::vector<int> rev;
std::vector<Z> roots{0, 1};

void dft(std::vector<Z> &a) {
    int n = a.size();

    if (int(rev.size()) != n) {
        rev.resize(n);
        for (int i = 0; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? n >> 1 : 0);
        }
    }

    for (int i = 0; i < n; ++i) {
        if (rev[i] < i)std::swap(a[i], a[rev[i]]);
    }
    if (int(roots.size() < n)) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
            Z e = power(Z(3), (mod - 1) >> (k + 1));
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[i << 1] = roots[i];
                roots[i << 1 | 1] = roots[i] * e;
            }
            k++;
        }
    }

    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}

void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
}

struct Poly {
    std::vector<Z> a;

    Poly() {}

    Poly(const std::vector<Z> &a) : a(a) {}

    Poly(const std::initializer_list<Z> &a) : a(a) {}

    int size() const {
        return a.size();
    }

    void resize(int n) {
        a.resize(n);
    }

    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }

    Z &operator[](int idx) {
        return a[idx];
    }

    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }

    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }

    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }

    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }

    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }

    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        Z inv = Z(sz).inv();
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i] * inv;
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }

    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < int(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }

    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }

    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }

    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }

    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }

    Poly deriv() const {
        if (a.empty()) {
            return Poly();
        }
        std::vector<Z> res(size() - 1);
        for (int i = 0; i < size() - 1; ++i) {
            res[i] = (i + 1) * a[i + 1];
        }
        return Poly(res);
    }

    Poly integr() const {
        std::vector<Z> res(size() + 1);
        for (int i = 0; i < size(); ++i) {
            res[i + 1] = a[i] / (i + 1);
        }
        return Poly(res);
    }

    Poly inv(int m) const {
        Poly x{a[0].inv()};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{2} - modxk(k) * x)).modxk(k);
        }
        return x.modxk(m);
    }

    Poly log(int m) const {
        return (deriv() * inv(m)).integr().modxk(m);
    }

    Poly exp(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{1} - x.log(k) + modxk(k))).modxk(k);
        }
        return x.modxk(m);
    }

    Poly pow(int k, int m) const {
        int i = 0;
        while (i < size() && a[i].val() == 0) {
            i++;
        }
        if (i == size() || 1LL * i * k >= m) {
            return Poly(std::vector<Z>(m));
        }
        Z v = a[i];
        auto f = divxk(i) * v.inv();
        return (f.log(m - i * k) * k).exp(m - i * k).mulxk(i * k) * power(v, k);
    }

    Poly sqrt(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((mod + 1) / 2);
        }
        return x.modxk(m);
    }

    Poly mulT(Poly b) const {
        if (b.size() == 0) {
            return Poly();
        }
        int n = b.size();
        std::reverse(b.a.begin(), b.a.end());
        return ((*this) * b).divxk(n - 1);
    }

    std::vector<Z> eval(std::vector<Z> x) const {
        if (size() == 0) {
            return std::vector<Z>(x.size(), 0);
        }
        const int n = std::max(int(x.size()), size());
        std::vector<Poly> q(4 * n);
        std::vector<Z> ans(x.size());
        x.resize(n);
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                q[p] = Poly{1, -x[l]};
            } else {
                int m = (l + r) / 2;
                build(2 * p, l, m);
                build(2 * p + 1, m, r);
                q[p] = q[2 * p] * q[2 * p + 1];
            }
        };
        build(1, 0, n);
        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {
            if (r - l == 1) {
                if (l < int(ans.size())) {
                    ans[l] = num[0];
                }
            } else {
                int m = (l + r) / 2;
                work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l));
                work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m));
            }
        };
        work(1, 0, n, mulT(q[1].inv(n)));
        return ans;
    }
};

void sol() {
    int n, k;
    std::cin >> n >> k;
    Poly inv = Poly{1, 3, 1}.inv(k + 1);
    Poly z1 = Poly{1, 2, 1}.pow(n + 1, k + 1);
    if (k >= n + 1) {
        if (n & 1) {
            z1[n + 1]--;
        } else {
            z1[n + 1]++;
        }
    }
    z1 *= inv;
    for (int i = 1; i <= k; ++i)std::cout << z1[i] << ' ';
    std::cout << '\n';
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int testcase;
    std::cin >> testcase;
    while (testcase--)sol();
    return 0;
}
```

### 5.CF623E Transforming Sequence

å¯¹äºä¸€ä¸ªæ•´æ•°åºåˆ— $\{a_1, a_2, \ldots, a_n\}$ï¼Œæˆ‘ä»¬å®šä¹‰å®ƒçš„å˜æ¢ä¸º $\{b_1, b_2, \ldots, b_n\}$ï¼Œå…¶ä¸­ $b_i = a_1 | a_2 | \ldots | a_i$ï¼Œå…¶ä¸­ $|$ è¡¨ç¤ºäºŒè¿›åˆ¶æŒ‰ä½æˆ–è¿ç®—ã€‚

ç°åœ¨æ±‚æœ‰å¤šå°‘ä¸ªé•¿ä¸º $n$ çš„åºåˆ— $a$ï¼Œæ»¡è¶³ $1\leq a_i \leq 2^k - 1$ï¼Œä½¿å¾—å®ƒçš„å˜æ¢ $b$ æ˜¯**ä¸¥æ ¼å•è°ƒé€’å¢**çš„ï¼Œå¯¹ $10^9+7$ å–æ¨¡ã€‚

$1\leq n \leq 10^{18}$ï¼Œ$1\leq k \leq 3 \times 10^4$ã€‚

è®¾$dp[i][j]$ä¸ºå‰iä¸ªæ•°å­—ä¸­æœ‰jä¸ªäºŒè¿›åˆ¶ä½æœ‰1ã€‚

æ˜“å¾—çŠ¶æ€è½¬ç§»æ–¹ç¨‹:$dp[i][j]=\sum dp[i-1][k]C_j^k2^k$ç„¶åè®¨è®ºä¸‹å¦‚ä½•åŠ å€å’ŒåŠ ä¸€ï¼Œç„¶åå°±èƒ½è¿›è¡Œå€å¢fftäº†ã€‚

```c++
//
// Created by mrx on 2022/8/4.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, ll b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<typename T>
T power(T a, ll b, ll mod) {
    T ans = 1;
    for (; b; a = 1ll * a * a % mod, b >>= 1) {
        if (b & 1)ans = 1ll * ans * a % mod;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    ll val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

const ll mod1 = 998244353;
const ll mod2 = 1004535809;
const ll mod3 = 469762049;
const ll mod = 1e9 + 7;

struct Z {
    Modular<mod1> A;
    Modular<mod2> B;
    Modular<mod3> C;

    Z() {}

    Z(int x) : A(x), B(x), C(x) {}

    Z operator*(const Z &rhs) {
        Z ans(*this);
        ans.A *= rhs.A;
        ans.B *= rhs.B;
        ans.C *= rhs.C;
        return ans;
    }

    Z operator+(const Z &rhs) {
        Z ans(*this);
        ans.A += rhs.A;
        ans.B += rhs.B;
        ans.C += rhs.C;
        return ans;
    }

    Z operator-(const Z &rhs) {
        Z ans(*this);
        ans.A -= rhs.A;
        ans.B -= rhs.B;
        ans.C -= rhs.C;
        return ans;
    }

    Z operator/(const Z &rhs) {
        Z ans(*this);
        ans.A /= rhs.A;
        ans.B /= rhs.B;
        ans.C /= rhs.C;
        return ans;
    }

    Z &operator/=(const Z &rhs) {
        A /= rhs.A;
        B /= rhs.B;
        C /= rhs.C;
        return *this;
    }

    Z &operator*=(const Z &rhs) {
        A *= rhs.A;
        B *= rhs.B;
        C *= rhs.C;
        return *this;
    }

    Z &operator+=(const Z &rhs) {
        A += rhs.A;
        B += rhs.B;
        C += rhs.C;
        return *this;
    }

    Z &operator-=(const Z &rhs) {
        A -= rhs.A;
        B -= rhs.B;
        C -= rhs.C;
        return *this;
    }

    Z inv() const {
        Z ans;
        ans.A = A.inv();
        ans.B = B.inv();
        ans.C = C.inv();
        return ans;
    }
};

Z gete(int k) {
    Z ans;
    ans.A = power(Modular<998244353>(3), (998244352) >> (k + 1));
    ans.B = power(Modular<1004535809>(3), (1004535808) >> (k + 1));
    ans.C = power(Modular<469762049>(3), (469762048) >> (k + 1));
    return ans;
}

long long getint(const Z &z) {
    ll mod_1_2 = 1ll * mod1 * mod2;
    int inv1 = power(mod1, mod2 - 2, mod2), inv2 = power(mod_1_2 % mod3, mod3 - 2, mod3);
    ll x = 1ll * (z.B.val() - z.A.val() + mod2) % mod2 * inv1 % mod2 * mod1 + z.A.val();
    return (1ll * (z.C.val() - x % mod3 + mod3) % mod3 * inv2 % mod3 * (mod_1_2 % mod) % mod + x) % mod;
}

std::vector<int> rev;
std::vector<Z> roots{0, 1};

void dft(std::vector<Z> &a) {
    int n = a.size();

    if (int(rev.size()) != n) {
        rev.resize(n);
        for (int i = 0; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? n >> 1 : 0);
        }
    }

    for (int i = 0; i < n; ++i) {
        if (rev[i] < i)std::swap(a[i], a[rev[i]]);
    }
    if (int(roots.size() < n)) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
//            Z e = power(Z(3), (mod - 1) >> (k + 1));
            Z e = gete(k);
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[i << 1] = roots[i];
                roots[i << 1 | 1] = roots[i] * e;
            }
            k++;
        }
    }

    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}

void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
}

struct Poly {
    std::vector<Z> a;

    Poly() {}

    Poly(const std::vector<Z> &a) : a(a) {}

    Poly(const std::initializer_list<Z> &a) : a(a) {}

    int size() const {
        return a.size();
    }

    void resize(int n) {
        a.resize(n);
    }

    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }

    Z &operator[](int idx) {
        return a[idx];
    }

    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }

    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }

    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }

    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }

    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }

    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        Z inv = Z(sz).inv();
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i] * inv;
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }

    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < int(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }

    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }

    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }

    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }

    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }


};

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    ll n;
    int k;
    std::cin >> n >> k;

    std::vector<Modular<mod>> fact(k + 2), inv(k + 2);
    fact[0] = inv[0] = 1;
    for (int i = 1; i <= k + 1; ++i) {
        fact[i] = fact[i - 1] * i;
        inv[i] = fact[i].inv();
    }
    if (n > k)std::cout << 0 << '\n';
    else {
        Poly tmp;
        Poly ans;
        tmp.resize(k + 1), ans.resize(k + 1);
        std::function<void(ll, int)> quick_pow = [&](ll n, int k) {
            if (n == 1) {
                ans[0] = 0;
                for (int i = 1; i < k; i++) ans[i] = Z(inv[i].val());
                return;
            }
            quick_pow(n >> 1, k);
            tmp[0] = 0;
            for (int i = 1; i < k; i++) {
                tmp[i] = Z(1ll * getint(ans[i]) * power(2, 1ll * (n >> 1) * i % (mod - 1), mod) % mod);
//                std::cout << (n >> 1) * i << ' ' << power(2, 1ll * (n >> 1) * i % (mod - 1), mod) << '\n';
            }
//            for (int i = 0; i < k; ++i)std::cerr << getint(ans[i]) << '#' << getint(tmp[i]) << '*';
//            std::cerr << '\n';
            ans = ans * tmp;
            ans.modxk(k);
            if (n & 1) {
                tmp[0] = 0;
                for (int i = 1; i < k; i++) ans[i] = Z(1ll * getint(ans[i]) * power(2, i, mod) % mod);
                for (int i = 1; i < k; i++) tmp[i] = Z(inv[i].val());
//                for (int i = 0; i < k; ++i)std::cerr << getint(ans[i]) << '&' << getint(tmp[i]) << '%';
//                std::cerr << '\n';
                ans = ans * tmp;
                ans.modxk(k);
            }
            for (int i = 1; i <= k; ++i)ans[i] = Z(getint(ans[i]) % mod);
            return;
        };
        quick_pow(n, k + 1);
        Modular<mod> res = 0;
        for (int i = 1; i <= k; ++i)res += getint(ans[i]) * fact[k] * inv[k - i];
//        for (int i = 1; i <= k; ++i)std::cerr << getint(ans[i]) << ' ';
        std::cout << res << '\n';
    }
    return 0;
}

```

### 6.HDU4609 3-idiots

é¢˜æ„ï¼šç»™næ ¹æœ¨æ£’ï¼ŒéšæœºæŒ‘é€‰ä¸‰æ ¹ä¸ä¸€æ ·çš„æœ¨æ£é—®èƒ½ç»„æˆä¸‰è§’å½¢çš„æ¦‚ç‡æ˜¯å¤šå°‘ã€‚

é¢˜ç›®åˆ†æï¼šç›´æ¥æ„é€ ç”Ÿæˆå‡½æ•°ï¼Œç„¶åè¿›è¡Œå·ç§¯ï¼Œå†å‡æ‰é‡å¤çš„å’Œé€‰ç›¸åŒçš„æƒ…å†µå°±èƒ½å¾—åˆ°ä¸¤æ ¹ä¸åŒçš„æœ¨æ£æ‰€èƒ½æ»¡è¶³çš„é•¿åº¦ï¼Œä½†æ˜¯è¿™æ ·ä¹‹åè¿˜æ˜¯ä¸å¥½ç®—ï¼Œé‚£ä¹ˆè€ƒè™‘å®¹æ–¥ï¼Œåˆæ³•çš„æ–¹æ¡ˆå°±æ˜¯æ‰€æœ‰çš„æ–¹æ¡ˆå‡å»ä¸åˆæ³•çš„ï¼Œå¯¹äºä¸¤æ ¹æœ¨æ£ç»„æˆçš„é•¿åº¦ï¼Œå¯ä»¥é€šè¿‡åç¼€å’Œç®—å‡ºæ¥ä¸åˆæ³•çš„æƒ…å†µï¼Œç„¶åå°±ç»“æŸäº†ã€‚

```c++
//
// Created by mrx on 2022/8/26.
//
#include <bits/stdc++.h>

using ll = long long;
using Z = std::complex<double>;
const double pi = std::acos(-1);
std::vector<int> rev;
std::vector<Z> roots{(0, 1), (0, 1)};

void dft(std::vector<Z> &a) {
    int n = a.size();

    if (int(rev.size()) != n) {
        rev.resize(n);
        for (int i = 0; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? n >> 1 : 0);
        }
    }

    for (int i = 0; i < n; ++i) {
        if (rev[i] < i)std::swap(a[i], a[rev[i]]);
    }
    if (int(roots.size() < n)) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
            Z e(cos(acos(-1) / (1 << k)), sin(acos(-1) / (1 << k)));
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[i << 1] = roots[i];
                roots[i << 1 | 1] = roots[i] * e;
            }
            k++;
        }
    }

    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}

void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
}

struct Poly {
    std::vector<Z> a;

    Poly() {}

    Poly(const std::vector<Z> &a) : a(a) {}

    Poly(const std::initializer_list<Z> &a) : a(a) {}

    int size() const {
        return a.size();
    }

    void resize(int n) {
        a.resize(n);
    }

    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }

    Z &operator[](int idx) {
        return a[idx];
    }

    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }

    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }

    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }

    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }

    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }

    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i];
            a.a[i] /= sz;
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }

    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < int(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }

    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }

    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }

    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }

    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }

};

void solve() {
    int n;
    std::cin >> n;
    std::vector<int> a(n);
    int mx = 0;
    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
        mx = std::max(mx, a[i]);
    }

    std::vector<int> cnt(mx + 1), sum(mx + 1);
    for (int i = 0; i < n; ++i)cnt[a[i]]++;
    sum[0] = cnt[0];
    for (int i = 1; i <= mx; ++i)sum[i] = sum[i - 1] + cnt[i];
    int sz = 1;
    while (sz < mx * 2 - 1) {
        sz *= 2;
    }
    std::vector<Z> num;
    num.resize(mx + 1);
    for (int i = 0; i <= mx; ++i) num[i].real(cnt[i]);
    num.resize(sz);
    dft(num);
    for (int i = 0; i < sz; ++i)num[i] = num[i] * num[i];
    for (int i = 0; i < sz; ++i)num[i] /= sz;
    idft(num);

    ll tot = 1ll * n * (n - 1) * (n - 2) / 6, legal = tot;

    for (int i = 2; i <= mx; ++i) {
        ll cur = ll(num[i].real() + 0.5);
        if (i % 2 == 0) cur -= cnt[i / 2];
        cur /= 2;
        legal -= cur * (n - sum[i - 1]);
    }

    std::cout << std::fixed << std::setprecision(7) << (double) legal / tot << std::endl;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int t = 1;
    std::cin >> t;
    while (t--)solve();
    return 0;
}
```

### 7.HDU6397Character Encoding

é¢˜æ„ï¼šç»™å®šmä¸ªå€¼åŸŸåœ¨ï¼ˆ0,nï¼‰çš„æ•°å­—ï¼Œé—®æœ‰å¤šå°‘ç§æ–¹æ¡ˆä½¿å¾—å’Œä¸ºkã€‚

ä¸€çœ¼ï¼š$[x^k](1+x+x^2+x^3+...+x^n)^m$ä½†æ˜¯tmdå¤ªæ…¢äº†ï¼Œé‚£ä¹ˆè€ƒè™‘ç”Ÿæˆå‡½æ•°ï¼Œå…¶æ”¶æ•›å½¢å¼ä¸º$\frac{1}{1-x}$é‚£ä¹ˆå…¶ä¸º$(1-x)^{-m}$é‚£ä¹ˆå¹¿ä¹‰äºŒé¡¹å¼å®šç†ç›´æ¥è½»æ¾ç§’æ€ã€‚

```c++
//
// Created by mrx on 2022/8/27.
//
#include <bits/stdc++.h>

using ll = long long;


template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, int b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    int val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

constexpr int mod = 998244353;
using Z = Modular<mod>;

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    std::vector<Z> fact(1e6 + 10), inv(1e6 + 10);
    fact[0] = inv[0] = 1;
    for (int i = 1; i <= 1e6; ++i) {
        fact[i] = fact[i - 1] * i;
        inv[i] = fact[i].inv();
    }
    auto C = [&](ll i, ll j) {
        if (j < i)return Z(0);
        return fact[j] * inv[i] * inv[j - i];
    };

    int t;
    std::cin >> t;
    while (t--) {
        ll n, m, k;
        std::cin >> n >> m >> k;
        Z tot = C(m - 1, m + k - 1);
        for (int i = 1; i * n <= k; ++i) {
            if (i & 1)tot -= C(i, m) * C(m - 1, m + k - 1 - i * n);
            else tot += C(i, m) * C(m - 1, m + k - 1 - i * n);
        }
        std::cout << tot << '\n';
    }
    return 0;
}
```

### 8.HDU7199 Find the Number of Paths

é¢˜æ„ï¼šç»™n+kä¸ªåŸå¸‚ï¼Œiæœ‰n+k-iç§æ–¹å¼åˆ°i+1ï¼Œå¯¹äºå°äºnçš„åŸå¸‚æ¯ä¸ªiåˆ°i-xéƒ½æœ‰$a_x$ç§æ–¹å¼ï¼Œä»k+1åˆ†åˆ«åˆ°k+1ï¼Œk+2ï¼Œk+3ï¼Œâ€¦.k+nçš„èµ°è¿‡kæ¡è·¯çš„æ–¹æ¡ˆã€‚

é¢˜ç›®åˆ†æï¼š

æ¯ä¸ªç‚¹é‡æ–°æ ‡å·ï¼Œé‚£ä¹ˆiåˆ°i-1æœ‰iæ¡è·¯ã€‚iåˆ°i+xæœ‰$a_x $ç§æ–¹å¼ï¼Œç„¶åè€ƒè™‘$dp[j][i]$ä¸ºåœ¨ä»n-1åˆ°ç¬¬iä¸ªåŸå¸‚ åˆšå¥½ç»è¿‡jæ¡è·¯çš„æ–¹æ¡ˆæ•°ã€‚$dp[i+1][j]=dp[i][j+1]*(j+1)+\sum dp_{x=0}^j[i][j-x]*a[x]$è®°$f_i(x)=\sum _{j=0}^{n+k+1}dp[i][j]x^j$

 $f_{i+1}(x)=f'_i(x)+A(x)*f_i(x)$é‚£ä¹ˆæ„é€ $g(x)=e^{\int A(x)dx}=e^{\sum_{i=0}^{k} \frac{A[i]x^{i+1}}{i+1}}$,$p_i(x)=f(x)*g(x)$åˆå› ä¸º$p(x)'=f'(x)g(x)+f(x)g'(x)=f'(x)g(x)+A(x)*g(x)*f(x)$é‚£ä¹ˆ$p_{i+1}(x)=g(x)f_{i+1}(x)=p'_{i+1}(x)$æ‰€ä»¥$p_k(x)=p_0^{(k)}(x)$åŒæ—¶ï¼Œké˜¶å¯¼æ•°å¯ä»¥onç®—ï¼Œæ‰€ä»¥å°±æŠŠä¸€ä¸ªéå¸¸æ¶å¿ƒçš„åœ°æ¨å¼ç®€åŒ–äº†ã€‚

```c++
//
// Created by mrx on 2022/8/27.
//

#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, int b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    int val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

constexpr int mod = 998244353;
using Z = Modular<mod>;

std::vector<int> rev;
std::vector<Z> roots{0, 1};

void dft(std::vector<Z> &a) {
    int n = a.size();

    if (int(rev.size()) != n) {
        rev.resize(n);
        for (int i = 0; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? n >> 1 : 0);
        }
    }

    for (int i = 0; i < n; ++i) {
        if (rev[i] < i)std::swap(a[i], a[rev[i]]);
    }
    if (int(roots.size() < n)) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
            Z e = power(Z(3), (mod - 1) >> (k + 1));
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[i << 1] = roots[i];
                roots[i << 1 | 1] = roots[i] * e;
            }
            k++;
        }
    }

    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}

void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
}

struct Poly {
    std::vector<Z> a;

    Poly() {}

    Poly(const std::vector<Z> &a) : a(a) {}

    Poly(const std::initializer_list<Z> &a) : a(a) {}

    int size() const {
        return a.size();
    }

    void resize(int n) {
        a.resize(n);
    }

    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }

    Z &operator[](int idx) {
        return a[idx];
    }

    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }

    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }

    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }

    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }

    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }

    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        Z inv = Z(sz).inv();
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i] * inv;
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }

    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < int(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }

    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }

    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }

    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }

    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }

    Poly deriv() const {
        if (a.empty()) {
            return Poly();
        }
        std::vector<Z> res(size() - 1);
        for (int i = 0; i < size() - 1; ++i) {
            res[i] = (i + 1) * a[i + 1];
        }
        return Poly(res);
    }

    Poly integr() const {
        std::vector<Z> res(size() + 1);
        for (int i = 0; i < size(); ++i) {
            res[i + 1] = a[i] / (i + 1);
        }
        return Poly(res);
    }

    Poly inv(int m) const {
        Poly x{a[0].inv()};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{2} - modxk(k) * x)).modxk(k);
        }
        return x.modxk(m);
    }

    Poly log(int m) const {
        return (deriv() * inv(m)).integr().modxk(m);
    }

    Poly exp(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{1} - x.log(k) + modxk(k))).modxk(k);
        }
        return x.modxk(m);
    }

    Poly pow(int k, int m) const {
        int i = 0;
        while (i < size() && a[i].val() == 0) {
            i++;
        }
        if (i == size() || 1LL * i * k >= m) {
            return Poly(std::vector<Z>(m));
        }
        Z v = a[i];
        auto f = divxk(i) * v.inv();
        return (f.log(m - i * k) * k).exp(m - i * k).mulxk(i * k) * power(v, k);
    }

    Poly sqrt(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((mod + 1) / 2);
        }
        return x.modxk(m);
    }

    Poly mulT(Poly b) const {
        if (b.size() == 0) {
            return Poly();
        }
        int n = b.size();
        std::reverse(b.a.begin(), b.a.end());
        return ((*this) * b).divxk(n - 1);
    }

    std::vector<Z> eval(std::vector<Z> x) const {
        if (size() == 0) {
            return std::vector<Z>(x.size(), 0);
        }
        const int n = std::max(int(x.size()), size());
        std::vector<Poly> q(4 * n);
        std::vector<Z> ans(x.size());
        x.resize(n);
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                q[p] = Poly{1, -x[l]};
            } else {
                int m = (l + r) / 2;
                build(2 * p, l, m);
                build(2 * p + 1, m, r);
                q[p] = q[2 * p] * q[2 * p + 1];
            }
        };
        build(1, 0, n);
        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {
            if (r - l == 1) {
                if (l < int(ans.size())) {
                    ans[l] = num[0];
                }
            } else {
                int m = (l + r) / 2;
                work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l));
                work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m));
            }
        };
        work(1, 0, n, mulT(q[1].inv(n)));
        return ans;
    }
};


void solve() {

}

int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    std::vector<Z> fact(4e5 + 10), inv(4e5 + 10);
    fact[0] = inv[0] = 1;
    for (int i = 1; i <= 4e5; ++i) {
        fact[i] = fact[i - 1] * i;
        inv[i] = fact[i].inv();
    }

    int t;
    std::cin >> t;
    while (t--) {
        int n, k;
        std::cin >> n >> k;
        std::vector<Z> a(n);
        for (int i = 1; i < n; ++i)std::cin >> a[i];
        Poly a_integer = Poly(a).integr();
        Poly g = a_integer.exp(k + 1);
        Poly h = g.inv(n);
        g = g.mulxk(n - 1);
        for (int i = k; i < n + k; ++i)g[i - k] = g[i] * fact[i] * inv[i - k];
        g = g.modxk(n);
        g *= h;
        for (int i = n - 1; i >= 0; --i)std::cout << g[i] << " \n"[i == 0];
    }
    return 0;
}
```





## çº¿æ€§é€’æ¨

### [1. Hardcore String Couting] (https://qoj.ac/contest/1356/problem/7187)

æ±‚é•¿åº¦ä¸ºmçš„å­—ç¬¦ä¸²åªæœ‰æœ€ånä½ä¸ºsï¼Œå…¶ä»–å­ä¸²å‡ä¸ä¸ºsçš„æ–¹æ¡ˆæ•°ã€‚

è®°ç­”æ¡ˆä¸º$ g(x) $, æ²¡æœ‰ä»»ä½•å­ä¸²ä¸ºsçš„æ–¹æ¡ˆæ•°ä¸º$ h(x) $, é‚£ä¹ˆæœ‰:


æ ¹æ®å®¹æ–¥å¯å¾—

$ g(n) = h(n - m) -\sum\limits_{p \in border}g(n - m + |p|) $

ä»¥åŠ

$ 26 * h(n - 1) - h(n) = s(n)$

é‚£ä¹ˆè€ƒè™‘æ¶ˆå»h

$ 26 \cdot g(n - 1) = 26 \cdot h(n - m - 1) - 26 \cdot \sum\limits_{p \in border}g(n - m + |p| - 1) $

ä¸

$ g(n) = h(n - m) -\sum\limits_{p \in border}g(n - m + |p|) $

ç›¸å‡å¾—:

$ 26 \cdot g(n-1) - g(n) = 26 \cdot h(n-m-1) - h(n-m)  - 26 \cdot  \sum\limits_{p \in border}g(n - m + |p| - 1) + \sum\limits_{p \in border}g(n - m + |p|)$

$ 26 \cdot g(n-1) - g(n) = g(n - m)  - 26 * \sum\limits_{p \in border}g(n - m + |p| - 1) + \sum\limits_{p \in border}g(n - m + |p|)$

é‚£ä¹ˆ

$ g(n) = 26 \cdot g(n - 1) - g(n - m) - \sum\limits_{p \in border}g(n - m + |p|) + 26 \cdot \sum\limits_{p \in border}g(n - m + |p| - 1)$

é‚£ä¹ˆå°±å¯ä»¥è¿›è¡Œå¸¸ç³»æ•°é½æ¬¡çº¿æ€§é€’æ¨

### [2.Long Grid Covering](https://codeforces.com/gym/103098/problem/L)

ç®€å•å‘ç°é€’æ¨å¼çš„ç³»æ•°ä¸º{1,2,5,2,2,4,2,2,4,2,2,4,2,2,4.....}

åŒ–ç®€æˆå°é—­å½¢å¼ : 

$2x + 2x^2 + 4x^3 + x^3 F(x) =  F(x) $

$2x + 2x^2 + 4x^3 = (1 - x^3) F(x) $

$G(x) = \frac{2x + 2x^2 + 4x^3}{1 - x^3} - x + x^3$
$G(x) = \frac{1x + 2x^2 + 5x^3 + x^4 - x^6}{1 - x^3}$

åŒ–æˆé€’æ¨å¼å¾—åˆ°: $DP(x) = \frac{1} {1 - G(x)}$

$DP(x) = \frac{1} {\frac{1 - 1x - 2x^2 - 6x^3 - x^4 + x^6}{1 - x^3}}$

$DP(x) = \frac{1 - x^3} {1 - 1x - 2x^2 - 6x^3 - x^4 + x^6}$

é‚£ä¹ˆå…¶ä¸ºPä¸º{1,0,0,-1,0,0,0}ï¼ŒQä¸º{1,-1,-2,-6,-1,0,1}çš„çº¿æ€§é€’æ¨ï¼Œå¯ä»¥é€šè¿‡æš´åŠ›å·ç§¯åšå‡º

```cpp

#include <bits/stdc++.h>

using i64 = long long;

constexpr int mod = 1e9 + 7;


using Poly  = std::vector<int>;

Poly operator*(const Poly a, const Poly b) {
    int n = a.size(), m = b.size();
    Poly c(n + m - 1, 0);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            c[i + j] = (c[i + j] + (1ll * a[i] * b[j]) % mod) % mod;
        }
    }
    return c;
}


int linearRecurrence(Poly p, Poly q, i64 n) {
    int m = q.size() - 1;
    while (n > 0) {
        auto newq = q;
        for (int i = 1; i <= m; i += 2) {
            newq[i] = mod - newq[i];
        }
		// å¯ä»¥æ›¿æ¢æˆä¸ºæš´åŠ›å·ç§¯ï¼Œå¤æ‚åº¦å˜ä¸º O(m^2 log(n))
        auto newp = p * newq;
        newq = q * newq;
        for (int i = 0; i < m; i++) {
            p[i] = newp[i * 2 + n % 2];
        }
        for (int i = 0; i <= m; i++) {
            q[i] = newq[i * 2];
        }
        n /= 2;
    }
    return p[0];
}


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);


	std::vector<int> y{1, 0, 0, mod - 1, 0, 0};
	std::vector<int> x{1, mod - 1, mod - 2, mod - 6, mod - 1, 0, 1};

    int t;
    std::cin >> t;
    while (t--) {
        i64 n;
        std::cin >> n;
        std::cout << linearRecurrence(y, x, n) << "\n";
    }

    return 0;
}

```




# æ•°æ®ç»“æ„

## å­—ç¬¦ä¸²

## 01trie

### atc308G Minimum Xor Pair Query

**é¢˜æ„**

ç»™ä¸€ä¸ªå¯é‡é›†åˆ,æ”¯æŒæ’å…¥å’Œåˆ é™¤,è¦æ±‚æŸ¥è¯¢å¯é‡é›†åˆä¸­ä»»æ„ä¸¤ä¸ªå…ƒç´ çš„å¼‚æˆ–æœ€å°å€¼

**åˆ†æ**

ä½¿ç”¨01trie,å¦‚æœä¸€ä¸ªèŠ‚ç‚¹ä¸‹é¢çš„åˆ†æ”¯æœ‰ä¸¤ä¸ªä»¥ä¸Šçš„æ•°å­—,é‚£ä¹ˆè¿™ä¸ªèŠ‚ç‚¹çš„äºŒè¿›åˆ¶è´¡çŒ®è‚¯å®šæ˜¯0,é‚£ä¹ˆæŒ‰ç…§è¿™ä¸ªæ€æƒ³é€’å½’/dpå°±å¯ä»¥ç®—å‡ºæ¥å…¨å±€çš„å¼‚æˆ–æœ€å°å€¼äº†,ç„¶åæ’å…¥å’Œåˆ é™¤çš„æ—¶å€™éƒ½åªä¼šæ”¹å˜ä¸€æ¡é“¾ä¸Šçš„dpå€¼,å¯ä»¥åšåˆ°logæ’å…¥åˆ é™¤,$O(1)$æŸ¥è¯¢

**ä»£ç **

```c++
#include <iostream>
#include <vector>
#include <map>
#include <numeric>
#include <algorithm>
#include <queue>
#include <array>
#include <bitset>
#include <string>

using i64 = long long;

int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};

struct trie {
    std::vector<std::array<int, 2>> nxt;
    std::vector<int> end, times;
    std::vector<int> dp;

    trie() {
        nxt.reserve(1000000);
        end.reserve(1000000);
        times.reserve(1000000);
        dp.reserve(1000000);
        dp.push_back(0);
        nxt.push_back(std::array<int, 2>{});
        end.push_back(0);
        times.push_back(0);
    }

    int NEW() {
        end.push_back(0);
        nxt.push_back(std::array<int, 2>{});
        times.push_back(0);
        dp.push_back(0);
        return end.size() - 1;
    }

    void update(int rt, int dep) {
        if (nxt[rt][0] == 0 && nxt[rt][1] == 0) {
            dp[rt] = 0;
        } else if (nxt[rt][0] == 0) {
            dp[rt] = dp[nxt[rt][1]] ^ (times[nxt[rt][1]] == 1 ? 1 << dep : 0);
        } else if (nxt[rt][1] == 0) {
            dp[rt] = dp[nxt[rt][0]];
        } else {
            if (times[nxt[rt][0]] == 1 && times[nxt[rt][1]] == 1) {
                dp[rt] = dp[nxt[rt][0]] ^ dp[nxt[rt][1]] ^ (1 << dep);
            } else {
                int res = 0x7fffffff;
                if (times[nxt[rt][0]] >= 2) {
                    res = std::min(res, dp[nxt[rt][0]]);
                } 
                if (times[nxt[rt][1]] >= 2){
                    res = std::min(res, dp[nxt[rt][1]]);
                }
                dp[rt] = res;
            }
        }
    }

    void insert(int rt, int idx, const std::string &s) {
        if (idx == s.length()) {
            times[rt]++;
            dp[rt] = 0;
            return;
        }
        int c = s[idx] - '0';
        if (nxt[rt][c] == 0) {
            nxt[rt][c] = NEW();
        }
        times[rt] -= times[nxt[rt][c]];
        insert(nxt[rt][c], idx + 1, s);
        update(rt, 30 - idx);
        times[rt] += times[nxt[rt][c]];
    }

    void erase(int rt, int idx, const std::string &s) {
        if (idx == s.length()) {
            times[rt]--;
            return;
        }

        int c = s[idx] - '0';
        if (nxt[rt][c] != 0) {
            times[rt] -= times[nxt[rt][c]];
            erase(nxt[rt][c], idx + 1, s);
            if (times[nxt[rt][c]] == 0) {
                nxt[rt][c] = 0;
            }
            update(rt, 30 - idx);
            times[rt] += times[nxt[rt][c]];
        }
    }

    int query(int rt){
        return dp[rt];
    }
};


void solve() {
    int q;
    std::cin >> q;

    trie T;
    while (q--) {
        int op;
        std::cin >> op;
        if (op == 1) {
            int x;
            std::cin >> x;
            std::bitset<31> bs(x);
            std::string s = bs.to_string();
            T.insert(0, 0, s);
        } else if (op == 2) {
            int x;
            std::cin >> x;
            std::bitset<31> bs(x);
            std::string s = bs.to_string();
            T.erase(0, 0, s);
        } else {
            std::cout << T.query(0) << "\n";
        }
    }
} 

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    solve();

    return 0;
}

```





# è®¡ç®—å‡ ä½•

## äºŒç»´å‡ ä½•

### é¸¡è„šæ’åº

#### 1.P2924 Largest Fence G

**é¢˜ç›®æè¿°**

Farmer Johnçš„å†œåœºé‡Œæœ‰Nï¼ˆ5<=N<=250ï¼‰ä¸ªç¯±ç¬†æ¡©ï¼Œæ¯ä¸ªéƒ½æœ‰ç‹¬ä¸€æ— äºŒçš„åæ ‡(xi,yi)ï¼ˆ1<=xi,yi<=1000ï¼‰ã€‚ä»–æƒ³é€‰æ‹©å°½é‡å¤šçš„ç¯±ç¬†æ¡©æ¥æ„å»ºä»–çš„å›´æ ã€‚è¿™ä¸ªå›´æ è¦ç¾è§‚ï¼Œæ‰€ä»¥å¿…é¡»æ˜¯å‡¸å¤šè¾¹å½¢çš„ã€‚é‚£ä»–æœ€å¤šèƒ½é€‰å¤šå°‘ä¸ªå‘¢ï¼Ÿ

æ‰€æœ‰çš„ç¯±ç¬†æ¡©ä¸­ä¸å­˜åœ¨ä¸‰ç‚¹å…±çº¿ã€‚

**é¢˜ç›®åˆ†æ**

æ ¹æ®å‡¸åŒ…çš„æ€§è´¨å¯ä»¥çŸ¥é“ï¼Œå‡¸åŒ…çš„æ‰€æœ‰è¾¹æ‹‰å‡ºæ¥éƒ½æ˜¯æŒ‰ç…§æè§’åºæœ‰å•è°ƒæ€§çš„ï¼Œé‚£ä¹ˆæšä¸¾æ‰€æœ‰çš„èµ·ç‚¹ï¼Œè¿›è¡Œä¸€ä¸‹å¯¹äºæ‰€æœ‰å¯èƒ½è¾¹çš„dpå°±è¡Œäº†

**ä»£ç **

```c++
//
// Created by mrx on 2022/11/7.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

using i64 = long long;
constexpr double eps = 1e-6;

int sgn(double x) {
	return x < -eps ? -1 : x > eps;
}

int sgn(i64 x) {
	return x < 0 ? -1 : x > 0;
}

template<typename T>
struct Point {
	T x, y;

	template<class Y>
	Point(const Point<Y>& cp):x(cp.x), y(cp.y) {}

	Point() : x(0), y(0) {}

	Point(T _x, T _y) : x(_x), y(_y) {}

	friend std::istream& operator >>(std::istream& is, Point& rhs) { return is >> rhs.x >> rhs.y; }

	friend std::ostream& operator <<(std::ostream& os, const Point& rhs) { return os << '(' << rhs.x << ',' << rhs.y << ')'; }

	Point operator -(const Point& rhs) const { return {x - rhs.x, y - rhs.y}; }

	Point& operator -=(const Point& rhs) { return (*this) = (*this) - rhs; }

	Point operator +(const Point& rhs) const { return {x + rhs.x, y + rhs.y}; }

	Point& operator +=(const Point& rhs) { return (*this) = (*this) + rhs; }

	template<class Y>
	Point<double> operator *(const Y& rhs) const { return {x * rhs, y * rhs}; }

	template<class Y>
	Point<double> operator /(const Y& rhs) { return {x / rhs, y / rhs}; }

	friend double abs(const Point& lhs) { return std::sqrt(lhs.x * lhs.x + lhs.y * lhs.y); }

	friend i64 abs2(const Point& lhs) { return (lhs.x * lhs.x + lhs.y * lhs.y); }

	friend T cross(const Point& lhs, const Point& rhs) { return lhs.x * rhs.y - lhs.y * rhs.x; }

	friend T dot(const Point& lhs, const Point& rhs) { return lhs.x * rhs.x + lhs.y * rhs.y; }

	friend double angle(const Point& rhs) { return atan2(rhs.x, rhs.y); }

	Point rotate90() const { return {y, x}; }

	Point<double> rotate(double deg) { return {x * cos(deg) - y * sin(deg), x * sin(deg) + y * cos(deg)}; }

	bool operator <(const Point& rhs) const { return sgn(x - rhs.x) == 0 ? sgn(y - rhs.y) < 0 : sgn(x - rhs.x) < 0; }

	bool operator ==(const Point& rhs) const { return sgn(x - rhs.x) == 0 && sgn(y - rhs.y) == 0; }

	bool up() const { return sgn(y) == 0 ? sgn(x) >= 0 : sgn(y) > 0; }
};

using Pl = Point<i64>;

std::vector<Pl> ConvexHull(std::vector<Pl> points) {
	int n = points.size();
	std::sort(points.begin(), points.end());
	for (auto x: points)std::cout << x << '\n';
	std::deque<Pl> dq;

	for (auto& point: points) {
		while (dq.size() > 1 && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], point - dq[dq.size() - 2])) < 0)dq.pop_back();
		dq.push_back(point);
	}
	for (auto x: dq)std::cerr << x << '\n';

	int k = int(dq.size());
	for (int i = n - 1; i >= 0; i--) {
		while (dq.size() > k && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], points[i] - dq[dq.size() - 2])) < 0)dq.pop_back();
		dq.push_back(points[i]);
	}

	std::vector<Pl> ans(dq.begin(), dq.end());
	return ans;
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n;
	std::cin >> n;
	std::vector<Pl> points(n);
	for (int i = 0; i < n; ++i)std::cin >> points[i];

	std::vector<std::pair<int, int>> e;
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			if (i == j)continue;
			e.emplace_back(i, j);
		}
	}

	std::sort(e.begin(), e.end(), [&](auto x, auto y) {
		Pl v1 = points[x.first] - points[x.second];
		Pl v2 = points[y.first] - points[y.second];
		return v1.up() ^ v2.up() ? v1.up() > v2.up() : cross(v1, v2) < 0;
	});
//	for (auto x: e)std::cout << points[x.first] - points[x.second] << '\n';

	int ans = 0;

	for (int i = 0; i < n; ++i) {

		std::vector<int> dp(n, -0x3f3f3f3f);
		dp[i] = 0;
		for (auto [l, r]: e) {
			dp[r] = std::max(dp[r], dp[l] + 1);
//			std::cerr << l << ' ' << r << ' ' << dp[r] << '\n';
		}
//		std::cerr << "!!!!" << dp[i] << '\n';
		ans = std::max(ans, dp[i]);
	}

	std::cout << ans << '\n';

	return 0;
}
```



### ç‚¹çº¿

#### 1.2018CCPC Guilin L Tow Ants

**é¢˜æ„**

ç»™ä¸€æ¡ç™½çº¿å’Œä¸€æ¡é»‘çº¿ï¼Œæ±‚æ— é™å¤§çš„å¹³é¢åŒºåŸŸä¸­ç™½çº¿èƒ½è¢«çœ‹åˆ°çš„èŒƒå›´

**é¢˜è§£**

åˆ†ç±»è®¨è®ºå³å¯

**ä»£ç **

```c++
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>
#include <set>
#include <iomanip>
#include <cassert>

using i64 = long long;

constexpr double eps = 1e-6;

template<typename T>
int sgn(T x) {
	return x < -eps ? -1 : x > eps;
}

int sgn(i64 x) {
	return x < 0 ? -1 : x > 0;
}

template<typename T>
struct Point {
	T x, y;

	template<class Y>
	Point(const Point<Y>& cp):x(cp.x), y(cp.y) {}

	Point() : x(0), y(0) {}

	Point(T _x, T _y) : x(_x), y(_y) {}

	friend std::istream& operator >>(std::istream& is, Point& rhs) { return is >> rhs.x >> rhs.y; }

	friend std::ostream& operator <<(std::ostream& os, const Point& rhs) { return os << '(' << rhs.x << ',' << rhs.y << ')'; }

	Point operator -(const Point& rhs) const { return {x - rhs.x, y - rhs.y}; }

	Point& operator -=(const Point& rhs) { return (*this) = (*this) - rhs; }

	Point operator +(const Point& rhs) const { return {x + rhs.x, y + rhs.y}; }

	Point& operator +=(const Point& rhs) { return (*this) = (*this) + rhs; }

	template<class Y>
	Point<double> operator *(const Y& rhs) const { return {x * rhs, y * rhs}; }

	template<class Y>
	Point<double> operator /(const Y& rhs) { return {x / rhs, y / rhs}; }

	friend double abs(const Point& lhs) { return std::sqrt(lhs.x * lhs.x + lhs.y * lhs.y); }

	friend i64 abs2(const Point& lhs) { return (lhs.x * lhs.x + lhs.y * lhs.y); }

	friend T cross(const Point& lhs, const Point& rhs) { return lhs.x * rhs.y - lhs.y * rhs.x; }

	friend T dot(const Point& lhs, const Point& rhs) { return lhs.x * rhs.x + lhs.y * rhs.y; }

	friend double angle(const Point& rhs) { return atan2(rhs.x, rhs.y); }

	Point rotate90() const { return {y, x}; }

	Point<double> rotate(double deg) { return {x * cos(deg) - y * sin(deg), x * sin(deg) + y * cos(deg)}; }

	bool operator <(const Point& rhs) const { return sgn(x - rhs.x) == 0 ? sgn(y - rhs.y) < 0 : sgn(x - rhs.x) < 0; }

	bool operator ==(const Point& rhs) const { return sgn(x - rhs.x) == 0 && sgn(y - rhs.y) == 0; }

	bool up() const { return sgn(y) == 0 ? sgn(x) >= 0 : sgn(y) > 0; }
};

using Pl = Point<i64>;
using Pd = Point<double>;

template<class T>
struct Line {
	Point<T> a, b;

	Line(Point<T> a, Point<T> b) : a(a), b(b) {}

	Line() {}

	Point<T> vec() const {
		return b - a;
	}
};

using P = Point<int>;
using L = Line<int>;

int toLeft(const P& p, const L& l) {
	return sgn(cross(p - l.a, l.vec()));
}

bool onLine(const P& p, const L& l) {
	return cross(p - l.a, l.vec()) == 0 && dot(p - l.a, p - l.b) <= 0;
}

Point<double> db(P x) {
	return Point<double>(x.x, x.y);
}

Point<double> intersection(const L& l1, const L& l2) {
	Line<double> p1, p2;
	p1.a = db(l1.a);
	p1.b = db(l1.b);
	p2.a = db(l2.a);
	p2.b = db(l2.b);
	return p1.a + p1.vec() * (cross(p2.a - p1.a, p2.vec()) / cross(p1.vec(), p2.vec()));
}

bool work(L w, L b) {
	L r1(w.a, b.a);
	L r2(w.b, b.b);

	if (cross(r1.vec(), r2.vec()) == 0) {
		std::cout << "inf\n";
		return true;
	}

	if (toLeft(r1.a, r2) * toLeft(r1.b, r2) < 0 && toLeft(r2.a, r1) * toLeft(r2.b, r1) < 0) {
		return false;
	}

	auto inter = intersection(r1, r2);

	if (std::abs(inter.x - w.a.x) <= std::abs(inter.x - b.a.x)) {
		std::cout << std::abs(cross(inter - db(w.a), inter - db(w.b))) / 2 << "\n";
	} else {
		std::cout << "inf\n";
	}
	return true;
}

void solve() {
	L w, b;
	std::cin >> w.a >> w.b >> b.a >> b.b;

	if (cross(w.vec(), b.vec()) == 0 && cross(w.vec(), b.a - w.a) == 0) {
		std::cout << "0\n";
		return;
	}

	if (toLeft(w.a, b) * toLeft(w.b, b) < 0 && toLeft(b.a, w) * toLeft(b.b, w) < 0) {
		std::cout << "0\n";
		return;
	}

	if (std::set{w.a, w.b, b.a, b.b}.size() == 3) {
		std::cout << "inf\n";
		return;
	}

	if (onLine(b.a, w) || onLine(b.b, w)) {
		std::cout << "inf\n";
		return;
	}

	if (onLine(w.a, b) || onLine(w.b, b)) {
		std::cout << "0\n";
		return;
	}

	if (toLeft(b.a, w) * toLeft(b.b, w) < 0) {
		std::cout << "0\n";
		return;
	}

	if (toLeft(w.a, b) * toLeft(w.b, b) < 0) {
		std::cout << "inf\n";
		return;
	}

	if (!work(w, b)) {
		std::swap(w.a, w.b);
		assert(work(w, b));
	}
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	int t;
	std::cin >> t;

	std::cout << std::fixed << std::setprecision(12);
	for (int i = 1; i <= t; ++i) {
		std::cout << "Case " << i << ": ";
		solve();
	}

	return 0;
}
```



### å‡¸åŒ…

#### 1.UVA10652 Board Wrapping

**é¢˜ç›®æè¿°**

æœ‰ $n$ ä¸ªçŸ©å½¢æœ¨æ¡ï¼Œä½ éœ€è¦ç”¨ä¸€ä¸ªé¢ç§¯å°½å¯èƒ½å°çš„å‡¸å¤šè¾¹å½¢æŠŠå®ƒä»¬å›´èµ·æ¥ï¼Œå¹¶è®¡ç®—å‡ºæœ¨æ¡å æ•´ä¸ªåŒ…è£…é¢ç§¯çš„ç™¾åˆ†æ¯”ã€‚

**é¢˜ç›®åˆ†æ**

é€šè¿‡æ—‹è½¬å…¬å¼æ±‚å‡ºæ¥æ‰€æœ‰çŸ©å½¢çš„é¡¶ç‚¹ï¼Œç„¶åé€šè¿‡è¿™ä¸ªæ±‚å‡ºæ¥å‡¸åŒ…ï¼Œè¿™ä¸ªå‡¸åŒ…å°±æ˜¯å›´èµ·æ¥çš„æœ€å°å¤šè¾¹å½¢ã€‚ç›´æ¥ç®—ä¸¤ä¸ªçš„é¢ç§¯å°±è¡Œã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/10/30.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>
#include <iomanip>

using i64 = long long;

constexpr double eps = 1e-6;

template<typename T>
int sgn(T x) {
	return std::abs(x) < eps ? 0 : x < 0 ? -1 : 1;
}

template<typename T>
struct Point {
	T x, y;

	Point(T x, T y) : x(x), y(y) {}

	template<class Y>
	Point(const Point<Y>& cp):x(cp.x), y(cp.y) {}

	Point() : x(0), y(0) {}

	friend std::istream& operator >>(std::istream& is, Point& rhs) {
		return is >> rhs.x >> rhs.y;
	}

	friend std::ostream& operator <<(std::ostream& os, const Point& rhs) {
		return os << rhs.x << ' ' << rhs.y;
	}

	Point& operator +=(const Point& rhs) {
		x += rhs.x;
		y += rhs.y;
		return *this;
	}

	Point operator +(const Point& rhs) const {
		Point ans(*this);
		return ans += rhs;
	}

	Point& operator -=(const Point& rhs) {
		x -= rhs.x;
		y -= rhs.y;
		return *this;
	}

	Point operator -(const Point& rhs) const {
		Point ans(*this);
		return ans -= rhs;
	}

	template<class Y>
	Point<Y> operator *(const Y& rhs) const {
		return Point<Y>(x * rhs, y * rhs);
	}

	template<class Y>
	Point<Y> operator /(const Y& rhs) {
		return Point<Y>(x / rhs, y / rhs);
	}

	Point rotate90() const {
		return {y, x};
	}

	Point<double> rotate(double deg) {
		return {x * cos(deg) - y * sin(deg), x * sin(deg) + y * cos(deg)};
	}

	friend double abs(const Point& lhs) {
		return std::sqrt(lhs.x * lhs.x + lhs.y * lhs.y);
	}

	friend T cross(const Point& lhs, const Point& rhs) {
		return lhs.x * rhs.y - lhs.y * rhs.x;
	}

	friend T dot(const Point& lhs, const Point& rhs) {
		return lhs.x * rhs.x + lhs.y * rhs.y;
	}

	bool operator <(const Point& rhs) const {
		return x == rhs.x ? y < rhs.y : x < rhs.x;
	}

	friend double angle(const Point& rhs) {
		return atan2(rhs.x, rhs.y);
	}

	bool operator ==(const Point& rhs) const {
		return std::abs(x - rhs.x) <= eps && std::abs(y - rhs.y) <= eps;
	}
};

template<typename T>
Point<long double> Rotate(Point<T> a, double deg) { return {a.x * cos(deg) - a.y * sin(deg), a.x * sin(deg) + a.y * cos(deg)}; }

using Pl = Point<i64>;
using Pd = Point<double>;

template<typename T>
struct Line {
	Point<T> a, v;

	Line(const Point<T>& a, const Point<T>& b) : a(a), v(b - a) {}

	template<class Y>
	Line(const Point<Y>& cp) : a(cp.a), v(cp.v) {}

	Pd point(double t) {
		return a + v * t;
	}

	friend Point<long double> intersection(const Line<T> lhs, const Line<T> rhs) {
		long double t = (long double) cross(rhs.a - lhs.a, rhs.v) / cross(lhs.v, rhs.v);
		return lhs.v * t + Point<double>(lhs.a);
	}

	double dis(const Point<T>& rhs) {
		return std::abs(cross(rhs - a, v)) / v.abs();
	}

	Line rotate(double deg) {
		Line<long double> ans(*this);
		ans.v = Rotate(v, deg);
		return ans;
	}
};

using Pd = Point<double>;
using Ld = Line<double>;

bool isCross(Pd a, Pd b, Pd i, Pd j) {
	return sgn(cross(i - a, j - i)) * sgn(cross(i - b, j - i)) == -1 && sgn(cross(b - i, a - b)) * sgn(cross(b - j, a - b)) == -1;
}

bool onSeg(Pd a, Pd i, Pd j) {
	return sgn(cross(i - a, j - a)) == 0 && sgn(dot(a - i, a - j)) < 0;
}

int dx[] = {1, 1, -1, -1};
int dy[] = {1, -1, 1, -1};

std::vector<Pd> ConvexHull(std::vector<Pd> points) {
	int n = points.size();
	std::sort(points.begin(), points.end());
	std::deque<Pd> dq;

	for (auto& point: points) {
		while (dq.size() > 1 && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], point - dq[dq.size() - 2])) <= 0)dq.pop_back();
		dq.push_back(point);
	}

	int k = int(dq.size());
	for (int i = n - 1; i >= 0; i--) {
		while (dq.size() > k && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], points[i] - dq[dq.size() - 2])) <= 0)dq.pop_back();
		dq.push_back(points[i]);
	}

	std::vector<Pd> ans(dq.begin(), dq.end());
	return ans;
}

void sol() {
	int n;
	std::cin >> n;

	std::vector<Pd> points;
	double fz = 0;
	for (int i = 0; i < n; ++i) {
		double x, y, w, h, phi;
		std::cin >> x >> y >> w >> h >> phi;
		fz += w * h;
		Pd cent(x, y);
		for (int j = 0; j < 4; ++j) {
			Pd vertex = cent + Pd(w / 2 * dx[j], h / 2 * dy[j]).rotate(-phi / 180 * acos(-1));
			points.push_back(vertex);
		}
	}

//	for (auto x: points)std::cout << x << '\n';
	std::vector<Pd> convexHull = ConvexHull(points);
	int m = convexHull.size();
//	for (auto x: convexHull)std::cout << x << '\n';
	double fm = 0;
	for (int i = 0; i < m; ++i) {
		fm -= cross(convexHull[i] - convexHull[(i + m - 1) % m], convexHull[i] - Pd(0, 0)) / 2;
	}
//	std::cerr << fz << ' ' << fm << '\n';
//	std::cerr << fz / fm << '\n';
	double ans = fz / fm * 100;
	std::cout << std::fixed << std::setprecision(1)<<ans<<" %\n";
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);
	int t;
	std::cin >> t;
	while (t--) {
		sol();
	}
	return 0;
}
```



#### 2.UVA11168 Airport

**é¢˜ç›®æè¿°**

å¹³é¢ä¸Šæœ‰$n$ä¸ªç‚¹ï¼Œæ±‚ä¸€æ¡ç›´çº¿ï¼Œä½¿å¾—è¿™$n$ä¸ªç‚¹éƒ½åœ¨è¿™æ¡ç›´çº¿ä¸Šæˆ–åŒä¾§ï¼Œä¸”æ¯ä¸ªç‚¹åˆ°è¯¥ç›´çº¿çš„è·ç¦»ä¹‹å’Œå°½é‡å°ã€‚

**é¢˜ç›®åˆ†æ**

åœ¨ä¸€æ¡ç›´çº¿åŒä¾§æˆ–è€…åœ¨è¿™æ¡ç›´çº¿ä¸Šï¼Œæ˜¾ç„¶è¿™æ¡ç›´çº¿ä¸èƒ½ç©¿è¿‡å‡¸åŒ…ï¼Œéšä¾¿ä¸€æƒ³ï¼Œéƒ½æ„Ÿè§‰æœ€ä¼˜ç§€çš„ç›´çº¿è‚¯å®šæ˜¯åœ¨è¿™ä¸ªå‡¸åŒ…ä¸Šçš„ã€‚é‚£ä¹ˆç›´æ¥æš´åŠ›æ±‚å‡ºæ¥æ¯ä¸ªç‚¹åˆ°è¿™æ¡ç›´çº¿çš„è·ç¦»å°±è¡Œäº†ã€‚æœ‰ä¸€ç§éå¸¸ç‰›é€¼çš„æ–¹å¼æ¥è®¡ç®—è¿™$n$ä¸ªç‚¹åˆ°ä¸€æ¡ç›´çº¿çš„è·ç¦»ã€‚å¯¹äºæ¯ä¸€ä¸ªç‚¹ï¼Œå®ƒåˆ°$Ax + By + C = 0$è¿™æ¡ç›´çº¿çš„è·ç¦»æ˜¯$\frac{\abs{Ax_0+ By_0+C}}{\sqrt{A^2 + B^2}}$ï¼Œé€šè¿‡åˆ†æè¿™ä¸ªå…¬å¼æ€ä¹ˆå¾—åˆ°çš„ï¼Œ å¯ä»¥å‘ç°ï¼Œå¦‚æœæ‰€æœ‰ç‚¹éƒ½åœ¨ç›´çº¿çš„åŒä¸€ä¾§ï¼Œé‚£ä¹ˆè®¡ç®—æ¯ä¸ªç‚¹è·ç¦»çš„æ—¶å€™è¿™ä¸ªå…¬å¼ä¸­ç»å¯¹å€¼å†…çš„éƒ¨åˆ†éƒ½æ˜¯åŒå·çš„ï¼Œè¿™æ ·å°±å¯ä»¥æŠŠ$x,y$éƒ½æ±‚å’Œï¼Œç›´æ¥$O(1)$è®¡ç®—è¿™$n$ä¸ªç‚¹åˆ°ä¸€æ¡ç›´çº¿çš„è·ç¦»äº†ã€‚æœ€åä¸€ç‚¹å°±æ˜¯å¦‚ä½•æŠŠä¸¤ç‚¹å¼å˜æˆä¸€èˆ¬æŸ¿ï¼Œè¿™ä¸ªåˆä¸­æ•°å­¦ä¸€ä¸‹å°±è¡Œäº†ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/10/31.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>
#include <iomanip>

using i64 = long long;


constexpr double eps = 1e-6;

template<typename T>
int sgn(T x) {
	return std::abs(x) < eps ? 0 : x < 0 ? -1 : 1;
}

template<typename T>
struct Point {
	T x, y;

	Point(T x, T y) : x(x), y(y) {}

	template<class Y>
	Point(const Point<Y>& cp):x(cp.x), y(cp.y) {}

	Point() : x(0), y(0) {}

	friend std::istream& operator >>(std::istream& is, Point& rhs) {
		return is >> rhs.x >> rhs.y;
	}

	friend std::ostream& operator <<(std::ostream& os, const Point& rhs) {
		return os << rhs.x << ' ' << rhs.y;
	}

	Point& operator +=(const Point& rhs) {
		x += rhs.x;
		y += rhs.y;
		return *this;
	}

	Point operator +(const Point& rhs) const {
		Point ans(*this);
		return ans += rhs;
	}

	Point& operator -=(const Point& rhs) {
		x -= rhs.x;
		y -= rhs.y;
		return *this;
	}

	Point operator -(const Point& rhs) const {
		Point ans(*this);
		return ans -= rhs;
	}

	template<class Y>
	Point<Y> operator *(const Y& rhs) const {
		return Point<Y>(x * rhs, y * rhs);
	}

	template<class Y>
	Point<Y> operator /(const Y& rhs) {
		return Point<Y>(x / rhs, y / rhs);
	}

	Point rotate90() const {
		return {y, x};
	}

	Point<double> rotate(double deg) {
		return {x * cos(deg) - y * sin(deg), x * sin(deg) + y * cos(deg)};
	}

	friend double abs(const Point& lhs) {
		return std::sqrt(lhs.x * lhs.x + lhs.y * lhs.y);
	}

	friend T cross(const Point& lhs, const Point& rhs) {
		return lhs.x * rhs.y - lhs.y * rhs.x;
	}

	friend T dot(const Point& lhs, const Point& rhs) {
		return lhs.x * rhs.x + lhs.y * rhs.y;
	}

	bool operator <(const Point& rhs) const {
		return x == rhs.x ? y < rhs.y : x < rhs.x;
	}

	friend double angle(const Point& rhs) {
		return atan2(rhs.x, rhs.y);
	}

	bool operator ==(const Point& rhs) const {
		return std::abs(x - rhs.x) <= eps && std::abs(y - rhs.y) <= eps;
	}
};

template<typename T>
Point<long double> Rotate(Point<T> a, double deg) { return {a.x * cos(deg) - a.y * sin(deg), a.x * sin(deg) + a.y * cos(deg)}; }

using Pl = Point<i64>;
using Pd = Point<double>;

template<typename T>
struct Line {
	Point<T> a, v;

	Line(const Point<T>& a, const Point<T>& b) : a(a), v(b - a) {}

	template<class Y>
	Line(const Point<Y>& cp) : a(cp.a), v(cp.v) {}

	Pd point(double t) {
		return a + v * t;
	}

	friend Point<long double> intersection(const Line<T> lhs, const Line<T> rhs) {
		long double t = (long double) cross(rhs.a - lhs.a, rhs.v) / cross(lhs.v, rhs.v);
		return lhs.v * t + Point<double>(lhs.a);
	}

	double dis(const Point<T>& rhs) {
		return std::abs(cross(rhs - a, v)) / v.abs();
	}

	Line rotate(double deg) {
		Line<long double> ans(*this);
		ans.v = Rotate(v, deg);
		return ans;
	}
};

using Ll = Line<i64>;
using Ld = Line<double>;

bool isCross(Pd a, Pd b, Pd i, Pd j) {
	return sgn(cross(i - a, j - i)) * sgn(cross(i - b, j - i)) == -1 && sgn(cross(b - i, a - b)) * sgn(cross(b - j, a - b)) == -1;
}

bool onSeg(Pd a, Pd i, Pd j) {
	return sgn(cross(i - a, j - a)) == 0 && sgn(dot(a - i, a - j)) < 0;
}

std::vector<Pl> ConvexHull(std::vector<Pl> points) {
	int n = points.size();
	std::sort(points.begin(), points.end());
	std::deque<Pl> dq;

	for (auto& point: points) {
		while (dq.size() > 1 && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], point - dq[dq.size() - 2])) <= 0)dq.pop_back();
		dq.push_back(point);
	}

	int k = int(dq.size());
	for (int i = n - 1; i >= 0; i--) {
		while (dq.size() > k && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], points[i] - dq[dq.size() - 2])) <= 0)dq.pop_back();
		dq.push_back(points[i]);
	}

	std::vector<Pl> ans(dq.begin(), dq.end());
	return ans;
}

std::array<i64, 3> getNorm(Ll l) {
	return {l.v.y, -l.v.x, -l.a.x * l.v.y + l.v.x * l.a.y};
}

void sol() {
	int n;
	std::cin >> n;
	std::vector<Pl> points(n);
	for (int i = 0; i < n; ++i)std::cin >> points[i];
	i64 sumX = 0, sumY = 0;
	for (int i = 0; i < n; ++i) {
		sumX += points[i].x;
		sumY += points[i].y;
	}

	if (n > 1) {
		std::vector<Pl> hull = ConvexHull(points);
//	for (auto x: hull)std::cerr << x << '\n';

		double ans = 2e18;
		int m = hull.size();
		for (int i = 1; i < m; ++i) {
//		std::cerr << hull[i - 1] << ' ' << hull[i] << '\n';
			Ll line(hull[i - 1], hull[i]);
			auto coefficient = getNorm(line);
			double fm = abs(Pl(coefficient[0], coefficient[1]));
//		for (auto x: coefficient)std::cerr << x << ' ';
//		std::cerr << '\n';
			i64 fz = std::abs(coefficient[0] * sumX + coefficient[1] * sumY + n * coefficient[2]);
			ans = std::min(ans, fz / fm);
		}

		std::cout << std::fixed << std::setprecision(3) << ans / n << '\n';
	} else std::cout << "0.000\n";
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);
	int t;
	std::cin >> t;
	for (int cas = 1; cas <= t; ++cas) {
		std::cout << "Case #" << cas << ": ";
		sol();
	}
	return 0;
}
```

#### 3.P3829ä¿¡ç”¨å¡å‡¸åŒ…

**é¢˜ç›®æè¿°**

ç»™è‹¥å¹²ä¸ªä¿¡ç”¨å¡ï¼Œä¿¡ç”¨å¡çš„å››ä¸ªè§’éƒ½æ˜¯åœ†è§’ï¼Œç”¨ä¸€æ ¹çº¿ç»™æ‰€æœ‰ä¿¡ç”¨å¡å›´èµ·æ¥è¦çš„æœ€å°é•¿åº¦

**é¢˜ç›®åˆ†æ**

å› ä¸ºç»™å®šçš„ä¿¡ç”¨å¡åœ†è§’åŠå¾„éƒ½æ˜¯ç›¸åŒçš„ï¼Œé‚£ä¹ˆæ•´ä¸ªå›¾å½¢æœ€ååœ†è½¬è¿‡çš„è§’åº¦è‚¯å®šæ˜¯$360^o$å…¶åªè¦å¼ºåˆ¶æŠŠåœ†è§’åˆ‡é™¤ï¼Œç„¶åæ±‚å‡¸åŒ…ï¼Œæœ€åå†åŠ ä¸Šä¸€ä¸ªåœ†è§’çš„å‘¨é•¿å³å¯ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/11/7.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>
#include <iomanip>

using i64 = long long;
constexpr double eps = 1e-9;

template<typename T>
int sgn(T x) {
	return x < -eps ? -1 : x > eps;
}

//int sgn(i64 x) {
//	return x < 0 ? -1 : x > 0;
//}

template<typename T>
struct Point {
	T x, y;

	template<class Y>
	Point(const Point<Y>& cp):x(cp.x), y(cp.y) {}

	Point() : x(0), y(0) {}

	Point(T _x, T _y) : x(_x), y(_y) {}

	friend std::istream& operator >>(std::istream& is, Point& rhs) { return is >> rhs.x >> rhs.y; }

	friend std::ostream& operator <<(std::ostream& os, const Point& rhs) { return os << '(' << rhs.x << ',' << rhs.y << ')'; }

	Point operator -(const Point& rhs) const { return {x - rhs.x, y - rhs.y}; }

	Point& operator -=(const Point& rhs) { return (*this) = (*this) - rhs; }

	Point operator +(const Point& rhs) const { return {x + rhs.x, y + rhs.y}; }

	Point& operator +=(const Point& rhs) { return (*this) = (*this) + rhs; }

	template<class Y>
	Point<double> operator *(const Y& rhs) const { return {x * rhs, y * rhs}; }

	template<class Y>
	Point<double> operator /(const Y& rhs) { return {x / rhs, y / rhs}; }

	friend double abs(const Point& lhs) { return std::sqrt(lhs.x * lhs.x + lhs.y * lhs.y); }

	friend i64 abs2(const Point& lhs) { return (lhs.x * lhs.x + lhs.y * lhs.y); }

	friend T cross(const Point& lhs, const Point& rhs) { return lhs.x * rhs.y - lhs.y * rhs.x; }

	friend T dot(const Point& lhs, const Point& rhs) { return lhs.x * rhs.x + lhs.y * rhs.y; }

	friend double angle(const Point& rhs) { return atan2(rhs.x, rhs.y); }

	Point rotate90() const { return {y, x}; }

	Point<long double> rotate(double deg) { return {x * cos(deg) - y * sin(deg), x * sin(deg) + y * cos(deg)}; }

	bool operator <(const Point& rhs) const { return sgn(x - rhs.x) == 0 ? sgn(y - rhs.y) < 0 : sgn(x - rhs.x) < 0; }

	bool operator ==(const Point& rhs) const { return sgn(x - rhs.x) == 0 && sgn(y - rhs.y) == 0; }

	bool up() const { return sgn(y) == 0 ? sgn(x) >= 0 : sgn(y) > 0; }
};

using Pl = Point<i64>;
using Pd = Point<long double>;

template<typename T>
struct Line {
	Point<T> a, v;

	Line(const Point<T>& a, const Point<T>& b) : a(a), v(b - a) {}

	template<class Y>
	Line(const Point<Y>& cp) : a(cp.a), v(cp.v) {}

	Pd point(double t) {
		return a + v * t;
	}

	friend Point<long double> intersection(const Line<T> lhs, const Line<T> rhs) {
		long double t = (long double) cross(rhs.a - lhs.a, rhs.v) / cross(lhs.v, rhs.v);
		return lhs.v * t + Point<double>(lhs.a);
	}

	double dis(const Point<T>& rhs) {
		return std::abs(cross(rhs - a, v)) / v.abs();
	}

	Line rotate(double deg) {
		Line<long double> ans(*this);
		ans.v = Rotate(v, deg);
		return ans;
	}
};


bool isCross(Pd a, Pd b, Pd i, Pd j) {
	return sgn(cross(i - a, j - i)) * sgn(cross(i - b, j - i)) == -1 && sgn(cross(b - i, a - b)) * sgn(cross(b - j, a - b)) == -1;
}

bool onSeg(Pd a, Pd i, Pd j) {
	return sgn(cross(i - a, j - a)) == 0 && sgn(dot(a - i, a - j)) < 0;
}

std::vector<Pd> ConvexHull(std::vector<Pd> points) {
	std::sort(points.begin(), points.end());
	points.erase(std::unique(points.begin(), points.end()), points.end());

	int n = points.size();
	std::deque<Pd> dq;

	for (auto& point: points) {
		while (dq.size() > 1 && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], point - dq[dq.size() - 2])) <= 0)dq.pop_back();
		dq.push_back(point);
	}

	int k = int(dq.size());
	for (int i = n - 1; i >= 0; i--) {
		while (dq.size() > k && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], points[i] - dq[dq.size() - 2])) <= 0)dq.pop_back();
		dq.push_back(points[i]);
	}

	std::vector<Pd> ans(dq.begin(), dq.end());
	return ans;
}

int dx[] = {1, 1, -1, -1};
int dy[] = {1, -1, 1, -1};

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n;
	std::cin >> n;
	long double a, b, r;
	std::cin >> b >> a >> r;
	a /= 2, b /= 2;
	a -= r, b -= r;

	std::vector<Pd> points;
	for (int i = 0; i < n; ++i) {
		long double x, y, theta;
		std::cin >> x >> y >> theta;
		Pd center(x, y);
		for (int j = 0; j < 4; ++j) {
			Pd dxy = {a * dx[j], b * dy[j]};
			points.push_back(center + dxy.rotate(theta));
		}
	}

	auto rem = ConvexHull(points);
	long double ans = 0;
	for (int i = 1; i < rem.size(); ++i) {
		ans += abs(rem[i] - rem[i - 1]);
	}

	ans += 2 * r * acos(-1);

	std::cout << std::fixed << std::setprecision(2) << ans << '\n';
	return 0;
}
```





### åŠå¹³é¢äº¤

#### 1.2018wf Panda Preserve

**é¢˜æ„**

ç»™ä¸€ä¸ªå¤šè¾¹å½¢åœ¨æ¯ä¸ªé¡¶ç‚¹ç”»åŠå¾„ä¸ºrçš„åœ†ï¼Œæ±‚è¦†ç›–æ•´ä¸ªå¤šè¾¹å½¢çš„æœ€å°åŠå¾„ã€‚

**åˆ†æ**

ä¸€å¼€å§‹çœ‹åˆ°å¾ˆå®¹æ˜“å»æƒ³åˆ°äºŒåˆ†+åœ†å¹¶ï¼Œè›‹æ„Ÿè§‰ä¸å¥½å†™ï¼Œç„¶åçµæœºä¸€åŠ¨æŠŠé—®é¢˜è½¬åŒ–ä¸ºï¼šè®°å¤šè¾¹å½¢å†…çš„ç‚¹ï¼Œè¿™ä¸ªç‚¹åˆ°æ‰€æœ‰çš„é¡¶ç‚¹ä¸­è·ç¦»çš„æœ€å°å€¼ä¸ºw(p),æ±‚å¯¹äºæ‰€æœ‰pçš„max(w(p))ã€‚é‚£ä¹ˆå¾ˆå®¹æ˜“æƒ³åˆ°ï¼Œè¿™ä¸ªå¤šè¾¹å½¢å¯ä»¥è¢«åˆ’åˆ†ä¸ºè‹¥å¹²ä¸ªåŒºåŸŸï¼Œæ¯ä¸ªåŒºåŸŸä¸­çš„ä»»æ„ä¸€ä¸ªç‚¹påˆ°ä¸€ä¸ªé¡¶ç‚¹qçš„è·ç¦»ä¸º w(p)ã€‚é‚£ä¹ˆæ¨¡æ‹Ÿä¸€ä¸‹é¢˜ç›®å‘ç°ï¼Œå¦‚æœæŸä¸ªç‚¹åˆ°çš„æœ€è¿‘ç‚¹æ˜¯é¡¶ç‚¹eï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹è‚¯å®šåœ¨eåˆ°ä¸æ‰€æœ‰ç‚¹çš„å‚ç›´å¹³åˆ†çº¿åˆ’åˆ†å‡ºæ¥çš„é eè¿™ä¾§çš„åŠå¹³é¢çš„åŠå¹³é¢äº¤ä¸­ã€‚

é‚£ä¹ˆå¯¹äºæ¯ä¸ªé¡¶ç‚¹$E$å»ç®—å…¶å¯¹äºå…¶ä»–é¡¶ç‚¹çš„å‚ç›´å¹³åˆ†çº¿çš„åŠå¹³é¢äº¤ï¼Œè¿™ä¸ªå¤æ‚åº¦æ˜¯ $O(n^2log (n)) $ï¼Œç®—å‡ºåŠå¹³é¢äº¤ä¹‹æ±‚è§£è¿™ä¸ªæ—¢åŠå¹³é¢äº¤ä¹Ÿåœ¨å¤šè¾¹å½¢é‡Œçš„ç‚¹åˆ°è¿™ä¸ªé¡¶ç‚¹$E$çš„æœ€å¤§è·ç¦»ã€‚éšä¾¿ç”»ä¸ªå›¾å¯ä»¥å‘ç°å…¶å¯èƒ½ä¸ºåŠå¹³é¢äº¤çš„é¡¶ç‚¹å’ŒåŠå¹³é¢äº¤çš„è¾¹ä¸å¤šè¾¹å½¢çš„è¾¹çš„äº¤ç‚¹åˆ°è¿™ä¸ªé¡¶ç‚¹$E$çš„è·ç¦»ã€‚

å­¦æœ¯ä¸Šï¼Œè¿™äº›å‚ç›´å¹³åˆ†çº¿æ„æˆçš„å›¾å«Voronoiå›¾ï¼Œè¿™ä¸ªå›¾çš„è¾¹æ•°é‡æ˜¯$O(n)$çš„æ‰€ä»¥æšä¸¾vå›¾å’Œå¤šè¾¹å½¢è¾¹çš„äº¤ç‚¹æ˜¯$O(n^2)$çš„ï¼Œæ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(n^2log(n))$çš„ã€‚

noticeï¼šåˆ¤æ–­ç‚¹åœ¨å¤šè¾¹å½¢å†…çš„æ—¶å€™å¦‚æœé‡‡ç”¨ä»på‡ºå‘çš„ä¸€æ¡ç›´çº¿ç»è¿‡å‡ æ¡è¾¹çš„è¯ä¸€å®šè¦æ³¨æ„è¿™æ¡â€œç›´çº¿â€ è¦è¶³å¤Ÿé•¿ï¼Œæœ¬äººå› ä¸ºè¿™ä¸ªwaäº†åŠå¹´ã€‚

 ```c++
 #include <vector>
 #include <algorithm>
 #include <iostream>
 #include <array>
 #include <numeric>
 #include <cmath>
 #include <functional>
 #include <queue>
 #include <complex>
 #include <iomanip>
 #include <cassert>
 
 using ll = long long;
 using T = double;
 constexpr double eps = 1e-5;
 
 using Point = std::complex<T>;
 #define x real
 #define y imag
 
 T dot(const Point& a, const Point& b) {
 	return (std::conj(a) * b).x();
 }
 
 T cross(const Point& a, const Point& b) {
 	return (std::conj(a) * b).y();
 }
 
 struct Line {
 	Point a;
 	Point b;
 
 	Line(const Point& a, const Point& b) : a(a), b(b) {}
 };
 
 Point rotate(const Point& a) {
 	return Point(-a.y(), a.x());
 }
 
 
 Point Norm(const Point& a) {
 	auto tmp = a / abs(a);
 	tmp *= 10000;
 	return tmp;
 }
 
 int sgn(const Point& a) {
 	return a.y() > 0 || (a.y() == 0 && a.x() > 0) ? 1 : -1;
 }
 
 bool onLeft(const Point& a, const Line& l) {
 	return cross(l.b - l.a, a - l.a) > 0;
 }
 
 Point intersection(const Line& l1, const Line& l2) {
 	return l1.a + (l1.b - l1.a) * (cross(l2.b - l2.a, l1.a - l2.a) / cross(l2.b - l2.a, l1.a - l1.b));
 }
 
 using polygen = std::vector<Point>;
 
 polygen hp(std::vector<Line>& lines) {
 	std::sort(lines.begin(), lines.end(), [&](auto l1, auto l2) {
 		auto d1 = l1.b - l1.a;
 		auto d2 = l2.b - l2.a;
 
 		if (sgn(d1) != sgn(d2)) {
 			return sgn(d1) == 1;
 		}
 
 		return cross(d1, d2) > 0;
 	});
 
 	std::deque<Line> ls;
 	std::deque<Point> ps;
 	for (auto l: lines) {
 		if (ls.empty()) {
 			ls.push_back(l);
 			continue;
 		}
 
 		while (!ps.empty() && !onLeft(ps.back(), l)) {
 			ps.pop_back();
 			ls.pop_back();
 		}
 
 		while (!ps.empty() && !onLeft(ps[0], l)) {
 			ps.pop_front();
 			ls.pop_front();
 		}
 
 		if (cross(l.b - l.a, ls.back().b - ls.back().a) == 0) {
 			if (dot(l.b - l.a, ls.back().b - ls.back().a) > 0) {
 				if (!onLeft(ls.back().a, l)) {
 					assert(ls.size() == 1);
 					ls[0] = l;
 				}
 				continue;
 			}
 			return {};
 		}
 
 		ps.push_back(intersection(ls.back(), l));
 		ls.push_back(l);
 	}
 
 	while (!ps.empty() && !onLeft(ps.back(), ls[0])) {
 		ps.pop_back();
 		ls.pop_back();
 	}
 	if (ls.size() <= 2) {
 		return {};
 	}
 	ps.push_back(intersection(ls[0], ls.back()));
 
 	return {ps.begin(), ps.end()};
 }
 
 
 template<typename T>
 int sign(T rr) {
 	return std::abs(rr) < eps ? 0 : rr < 0 ? -1 : 1;
 }
 
 bool crs(const Line& a, const Line& b) {
 	if (sign(cross(a.a - b.a, b.b - b.a)) * sign(cross(a.b - b.a, b.b - b.a)) >= 0)return false;
 	if (sign(cross(b.a - a.a, a.b - a.a)) * sign(cross(b.b - a.a, a.b - a.a)) >= 0)return false;
 	return true;
 }
 
 int main() {
 	std::ios::sync_with_stdio(false);
 	std::cin.tie(nullptr);
 	std::cout.tie(nullptr);
 
 	int n;
 	//	std::cin >> n;
 	scanf("%d", &n);
 	std::vector<Point> point(n);
 	std::vector<Line> lines_max;
 	lines_max.emplace_back(Point{1e4 + 10, -1e4 - 10}, Point{1e4 + 10, 1e4 + 10});
 	lines_max.emplace_back(Point{1e4 + 10, 1e4 + 10}, Point{-1e4 - 10, 1e4 + 10});
 	lines_max.emplace_back(Point{-1e4 - 10, 1e4 + 10}, Point{-1e4 - 10, -1e4 - 10});
 	lines_max.emplace_back(Point{-1e4 - 10, -1e4 - 10}, Point{1e4 + 10, -1e4 - 10});
 	for (int i = 0; i < n; ++i) {
 		T xx, yy;
 		//		std::cin >> xx >> yy;
 		scanf("%lf%lf", &xx, &yy);
 		point[i] = {xx, yy};
 	}
 	auto on_seg = [&](const Point& P, const Point& a, const Point& b) {
 		return sign(dot((P - a), (P - b))) <= 0 && std::abs(cross(P - a, P - b)) < eps;
 	};
 	auto on_seg_line = [&](const Line& l, const Point& a, const Point& b) -> int {
 		return sign(cross(l.b - l.a, l.a - a)) * sign(cross(l.b - l.a, l.a - b)) < 0 && sign(cross(b - a, a - l.a)) * sign(cross(b - a, a - l.b)) < 0;
 	};
 	auto in = [&](const Point& p) -> bool {
 		for (int i = 0; i < n; ++i) {
 			if (on_seg(p, point[i], point[(i + 1) % n]))return true;
 		}
 		Point dir = {43233.123422346L, 89939.12323486L};
 		int ret = 0;
 		for (int i = 0; i < n; ++i) {
 			ret += on_seg_line(Line(p, p + dir), point[i], point[(i + 1) % n]);
 		}
 		return ret & 1;
 	};
 
 	T ans = -1e18;
 	for (int i = 0; i < n; ++i) {
 		std::vector<Line> lines(lines_max);
 		for (int j = 0; j < n; ++j) {
 			if (i == j)continue;
 			Point mid = (point[i] + point[j]);
 			mid /= 2;
 			Point dir = point[j] - point[i];
 			dir = rotate(dir);
 //			dir = Norm(dir);
 			lines.emplace_back(mid - dir, mid + dir);
 		}
 		auto nearest = hp(lines);
 		int m = nearest.size();
 		for (int j = 0; j < m; ++j) {
 			auto p = nearest[j];
 			if (in(p)) {
 				ans = std::max(ans, abs(p - point[i]));
 			}
 			Line tmp = Line(nearest[(j + 1) % m], nearest[j]);
 			for (int k = 0; k < n; k++) {
 				Line tnp = Line(point[(k + 1) % n], point[k]);
 				if (crs(tmp, tnp)) ans = std::max(ans, abs(intersection(tmp, tnp) - point[i]));
 			}
 		}
 	}
 	printf("%.4lf", ans);
 	return 0;
 }
 
 ```





# å›¾è®º

## è”é€šåˆ†é‡

### è¾¹åŒ

#### 1.2021 ICPC Shenyang H

**é¢˜æ„**

ç»™ä¸€ä¸ªç®€å•è”é€šå›¾ï¼ŒæŠŠè¾¹å˜æˆç‚¹ï¼Œä¸è¿™ä¸ªè¾¹æœ‰åŒä¸€ä¸ªé¡¶ç‚¹çš„è¾¹ä¸æ–°å›¾ä¸­è¿™ä¸ªè¾¹å¯¹åº”çš„ç‚¹é“¾æ¥ã€‚æ¯ä¸ªè¾¹éƒ½æœ‰ä¸€ä¸ªæƒå€¼ï¼Œæ±‚æœ€å¤§åŒ¹é…ã€‚

**é¢˜ç›®åˆ†æ**

è¿™ä¸ªå›¾çš„ç‚¹æœ€å¤§åŒ¹é…å°±æ˜¯åŸå›¾çš„æœ‰å…¬å…±ç‚¹çš„æœ€å¤§è¾¹åŒ¹é…ï¼Œé‚£ä¹ˆå¦‚æœå›¾çš„å¤§å°ä¸ºå¶æ•°ï¼Œé‚£ä¹ˆéå¸¸ç®€å•ï¼Œè‚¯å®šèƒ½å¤Ÿå…¨éƒ¨åŒ¹é…ä¸Šã€‚ä½†æ˜¯å¦‚æœå‡ºç°äº†å¥‡æ•°ï¼Œé‚£ä¹ˆå°±è¦è¿›è¡Œåˆ è¾¹ï¼Œé‚£ä¹ˆè¦æ€ä¹ˆåˆ è¾¹å‘¢ï¼Œåªè¦åˆ æ‰çš„ä¸æ˜¯å‰²è¾¹å°±è¡Œäº†ã€‚

**ä»£ç **

```c++
//
// Created by mrx on 2022/11/4.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <stack>
#include <iomanip>
#include <array>
#include <map>

using i64 = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n, m;
	std::cin >> n >> m;
	std::vector<std::vector<std::pair<int, int>>> adj(n);

	i64 sum = 0;

	for (int i = 0; i < m; ++i) {
		int u, v, w;
		std::cin >> u >> v >> w;
		sum += w;
		u--, v--;
		adj[u].emplace_back(v, w);
		adj[v].emplace_back(u, w);
	}


	std::stack<int> stk;
	std::vector<int> in_stack(n), siz(n), belong(n), dfn(n), low(n);
	int cnt = 0, scc = 0;
	std::function<void(int, int)> tarjan = [&](int u, int fa) {
		low[u] = dfn[u] = ++cnt;
		stk.push(u);
		for (auto [v, w]: adj[u]) {
			if (v == fa)continue;
			if (!dfn[v]) {
				tarjan(v, u);
				siz[u] += siz[v] + 1;
				low[u] = std::min(low[u], low[v]);
			} else if (!belong[v]) {
				low[u] = std::min(low[u], dfn[v]);
				if (dfn[v] > dfn[u])siz[u]++;
			}
		}
		if (dfn[u] == low[u]) {
			int v;
			scc++;
			do {
				v = stk.top();
				stk.pop();
				belong[v] = scc;
			} while (v != u);
		}
	};

	//å¦‚æœæ˜¯å¥‡æ•°çš„è¯å°±æœ‰ä¸€æ¡è¾¹è‚¯å®šåŒ¹é…ä¸ä¸Šï¼Œé‚£ä¹ˆå°±è¦åˆ é™¤æ‰ã€‚
	if (m & 1) {
		for (int i = 0; i < n; ++i) {
			if (!dfn[i])tarjan(i, i);
		}
		i64 ans = 0;
		for (int u = 0; u < n; ++u) {
			for (auto [v, w]: adj[u]) {
				//å¦‚æœsccçš„å¤§å°æ˜¯ä¸€ä¸ªå¥‡æ•°ï¼Œé‚£ä¹ˆå°±è¦è¿›è¡Œåˆ è¾¹ã€‚
				if (belong[u] == belong[v] || (dfn[v] > dfn[u] && (!(siz[v] & 1))))ans = std::max(ans, sum - w);
			}
		}
		sum = ans;
	}

	std::cout << sum << '\n';

	return 0;
}
```





## çŸ©é˜µæ ‘å®šç†

çŸ©é˜µæ ‘å®šç†ä¸€èˆ¬ç”¨äºæ±‚è§£$\sum_{T\in Tree}\prod_{e\in T}w_e$ï¼Œ

trickï¼šé€šè¿‡æŠŠçŸ©é˜µé‡Œçš„å…ƒç´ å˜ä¸º${1+w_ex}$çš„å¤šé¡¹å¼å¯ä»¥æ±‚å‡º$\sum_{T\in Tree}\sum_{e\in T}w_e$

### 1.æ ¡å†…èµ› é«˜ç­‰è¢‹é¼ 

**é¢˜ç›®æè¿°** 

æŸ´è€å¸ˆåœ¨ä¸Šé«˜ç­‰ä»£æ•°ï¼Œä»Šå¤©è€å¸ˆè®²åˆ°äº†çŸ©é˜µæ ‘å®šç†ï¼š

å®šä¹‰ Kirchhoff çŸ©é˜µä¸ºåº¦æ•°çŸ©é˜µå‡å»é‚»æ¥çŸ©é˜µï¼Œé‚£ä¹ˆç”Ÿæˆæ ‘ä¸ªæ•°å°±æ˜¯ Kirchhoff çŸ©é˜µåˆ æ‰ç¬¬ i*i* è¡Œç¬¬ i*i* åˆ—åè¡Œåˆ—å¼çš„å€¼...

ä½œä¸ºä»£æ•°å­¦å®¶çš„æŸ´è€å¸ˆå½“ç„¶ä¼šè¿™äº›å•¦ï¼Œæ‰€ä»¥å¤ªè¿‡æ— èŠå¬ç€å¬ç€å°±è¿›å…¥äº†æ¢¦ä¹¡ã€‚

åœ¨æ¢¦é‡Œï¼Œä¸¤å¹…æ— å‘å›¾çº ç¼ åœ¨ä¸€èµ·ï¼Œç”Ÿæˆæ ‘æ€ä¹ˆä¹Ÿçœ‹ä¸æ¸…...

å…·ä½“çš„ï¼Œä¸¤å¹…æ— å‘å›¾å‡ä¸ºç®€å•è¿é€šå›¾ï¼Œå³æ— é‡è¾¹æ— è‡ªç¯ï¼Œä¸¤å¹…å›¾å…±äº«äº†é¡¶ç‚¹ï¼Œå³ä¸¤å¹…å›¾éƒ½æœ‰ n*n* ä¸ªé¡¶ç‚¹ï¼Œç¼–å·ä¸º$ 1,\cdots,n$ ã€‚

æŸ´è€å¸ˆæ´‹æ´‹æ´’æ´’ä»ç¬¬ä¸€å¹…å›¾ä¸­**éšæœºåœ°**é€‰å‡ºäº†ä¸€æ£µç”Ÿæˆæ ‘ï¼Œä½†è½¬å¤´ä¸€çœ‹ï¼Œå›¾å˜æˆäº†ç¬¬äºŒå¹…å›¾ï¼

ä¹Ÿå°±æ˜¯è¯´ï¼Œ**æ­¤å‰é€‰å‡ºçš„ç”Ÿæˆæ ‘**ä¸­ï¼Œæ‰€æœ‰ä¸åœ¨ç¬¬äºŒå¹…å›¾ä¸­çš„**è¾¹**éƒ½æ¶ˆå¤±äº†ï¼

æŸ´è€å¸ˆéå¸¸æ‚²ä¼¤ï¼Œæƒ³è®©ä½ å¸®ä»–ç®—ä¸€ä¸‹ï¼Œæ‰€æœ‰å¯èƒ½çš„æƒ…å†µä¸‹ä»–é€‰å‡ºçš„ç”Ÿæˆæ ‘æœ€åå‰©ä¸‹çš„è¾¹æ•°çš„å’Œï¼Œç­”æ¡ˆå¯¹ 998244353å–æ¨¡ã€‚

**é¢˜ç›®åˆ†æ**

trickï¼šé€šè¿‡æŠŠçŸ©é˜µé‡Œçš„å…ƒç´ å˜ä¸º${1+w_ex}$çš„å¤šé¡¹å¼å¯ä»¥æ±‚å‡º$\sum_{T\in Tree}\sum_{e\in T}w_e$

æ˜¯trickçš„æ¿å­

```c++
//
// Created by mrx on 2022/10/4.
//
#include <vector>
#include <algorithm>
#include <iostream>
#include <array>
#include <functional>
#include <cassert>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
	T u = 0, v = 1;
	while (a != 0) {
		T t = b / a;
		b -= t * a;
		std::swap(a, b);
		u -= t * v;
		std::swap(u, v);
	}
	assert(b == 1);
	return u;
}

template<typename T>
T power(T a, int b) {
	T ans = 1;
	for (; b; a *= a, b >>= 1) {
		if (b & 1)ans *= a;
	}
	return ans;
}

template<int Mod>
class Modular {
public:
	using Type = int;

	template<typename U>
	static Type norm(U& x) {
		Type v;
		if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
		else v = static_cast<Type>(x % Mod);
		if (v < 0) v += Mod;
		return v;
	}

	constexpr Modular() : value() {}

	int val() const { return value; }

	Modular inv() const {
		return Modular(inverse(value, Mod));
	}

	template<typename U>
	Modular(const U& x) {
		value = norm(x);
	}

	const Type& operator ()() const {
		return value;
	}

	template<typename U>
	explicit operator U() const {
		return static_cast<U>(value);
	}

	Modular& operator +=(const Modular& other) {
		if ((value += other.value) >= Mod) value -= Mod;
		return *this;
	}

	Modular& operator -=(
			const Modular& other) {
		if ((value -= other.value) < 0) value += Mod;
		return *this;
	}

	template<typename U>
	Modular& operator +=(const U& other) { return *this += Modular(other); }

	template<typename U>
	Modular& operator -=(const U& other) { return *this -= Modular(other); }

	Modular& operator ++() { return *this += 1; }

	Modular& operator --() { return *this -= 1; }

	Modular operator ++(int) {
		Modular result(*this);
		*this += 1;
		return result;
	}

	Modular operator --(int) {
		Modular result(*this);
		*this -= 1;
		return result;
	}

	Modular operator -() const { return Modular(-value); }

	template<class ISTREAM_TYPE>
	friend ISTREAM_TYPE& operator >>(ISTREAM_TYPE& is, Modular& rhs) {
		ll v;
		is >> v;
		rhs = Modular(v);
		return is;
	}

	template<class OSTREAM_TYPE>
	friend OSTREAM_TYPE& operator <<(OSTREAM_TYPE& os, const Modular& rhs) {
		return os << rhs.val();
	}

	Modular& operator *=(const Modular& rhs) {
		value = ll(value) * rhs.value % Mod;
		return *this;
	}

	Modular& operator /=(const Modular& other) { return *this *= Modular(inverse(other.value, Mod)); }

	friend const Type& abs(const Modular& x) { return x.value; }

	friend bool operator ==(const Modular& lhs, const Modular& rhs) { return lhs.x == rhs.x; }

	friend bool operator <(const Modular& lhs, const Modular& rhs) { return lhs.x < rhs.x; }


	bool operator ==(const Modular& rhs) { return *this == rhs.value; }

	template<typename U>
	bool operator ==(U rhs) { return *this == Modular(rhs); }

	template<typename U>
	friend bool operator ==(U lhs, const Modular& rhs) { return Modular(lhs) == rhs; }

	bool operator !=(const Modular& rhs) { return *this != rhs; }

	template<typename U>
	bool operator !=(U rhs) { return *this != rhs; }

	template<typename U>
	friend bool operator !=(U lhs, const Modular& rhs) { return lhs != rhs; }

	bool operator <(const Modular& rhs) { return this->value < rhs.value; }

	Modular operator +(const Modular& rhs) { return Modular(*this) += rhs; }

	template<typename U>
	Modular operator +(U rhs) { return Modular(*this) += rhs; }

	template<typename U>
	friend Modular operator +(U lhs, const Modular& rhs) { return Modular(lhs) += rhs; }

	Modular operator -(const Modular& rhs) { return Modular(*this) -= rhs; }

	template<typename U>
	Modular operator -(U rhs) { return Modular(*this) -= rhs; }

	template<typename U>
	friend Modular operator -(U lhs, const Modular& rhs) { return Modular(lhs) -= rhs; }

	Modular operator *(const Modular& rhs) { return Modular(*this) *= rhs; }

	template<typename U>
	Modular operator *(U rhs) { return Modular(*this) *= rhs; }

	template<typename U>
	friend Modular operator *(U lhs, const Modular& rhs) { return Modular(lhs) *= rhs; }

	Modular operator /(const Modular& rhs) { return Modular(*this) /= rhs; }

	template<typename U>
	Modular operator /(U rhs) { return Modular(*this) /= rhs; }

	template<typename U>
	friend Modular operator /(U lhs, const Modular& rhs) { return Modular(lhs) /= rhs; }

private:
	Type value;
};

constexpr int mod = 998244353;
using Z = Modular<mod>;

struct node {
	Z x, y;

	node(Z x, Z y) : x(x), y(y) {}

	node() {}

	friend node operator +(const node& u, const node& v) {
		return node(u.x + v.x, u.y + v.y);
	}

	friend node operator -(const node& u, const node& v) {
		return node(u.x - v.x, u.y - v.y);
	}

	friend node operator *(const node& u, const node& v) {
		return node(u.x * v.y + u.y * v.x, u.y * v.y);
	}

	friend node operator /(const node& u, const node& v) {
		Z inv = v.y.inv();
		return node((u.x * v.y - u.y * v.x) * inv * inv, u.y * inv);
	}
};

struct matrix {
	std::vector<std::vector<node>> mat;

	int n, m;

	matrix(int n, int m) : mat(n, std::vector<node>(m, node(0, 0))), n(n), m(m) {}

	std::vector<node>& operator [](int idx) {
		return mat[idx];
	}

	Z gauss(int nn) {
		node res(0, 1);
		for (int i = 0; i < nn; ++i) {
			int nxt = i;
			for (; nxt < nn - 1; ++nxt)if (mat[nxt][i].y)break;
			if (mat[nxt][i].y) {
				std::swap(mat[nxt], mat[i]);
				if (nxt != i)res = res * node(0, -1);
				res = (res * mat[i][i]);
				node inv = node(0, 1) / mat[i][i];
				for (int j = i + 1; j < nn; ++j) {
					node div = mat[j][i] * inv;
					for (int k = i; k < nn; ++k) mat[j][k] = mat[j][k] - (div * mat[i][k]);
				}
			} else return 0;
		}
		return res.x;
	}
};

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n;
	std::cin >> n;
	std::vector<std::vector<int>> a(n, std::vector<int>(n));
	std::vector<std::vector<int>> b(n, std::vector<int>(n));
	std::vector<int> deg1(n), deg2(n);
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			char x;
			std::cin >> x;
			a[i][j] = x - '0';
		}
	}

	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			char x;
			std::cin >> x;
			b[i][j] = (x - '0');
		}
	}

	matrix mat(n, n);
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			if (a[i][j] == 1 && i >= j) {
				mat[i][i] = mat[i][i] + node(b[i][j] == 1, 1);
				mat[j][j] = mat[j][j] + node(b[i][j] == 1, 1);
				mat[i][j] = mat[i][j] - node(b[i][j] == 1, 1);
				mat[j][i] = mat[j][i] - node(b[i][j] == 1, 1);
			}
		}
	}
	std::cout << mat.gauss(n - 1) << '\n';

	return 0;
}
```





