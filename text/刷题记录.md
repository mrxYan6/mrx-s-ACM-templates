# 思维

## 1.cfgym103931CCoffee Overdose

**题目描述**

我们用体力 S 来表示你的精神状态。在每一秒钟，你为你的项目贡献 S 的完成度，之后你的体力会减 少 1。当你的体力减少到 0 或更少时，你会彻底失控并进入梦乡。 你可以在每秒钟刚好开始时喝下一杯咖啡，效果将会持续 C 秒。在咖啡的持续时间里，你不能再喝 另一杯咖啡，同时你的体力也将被固定在开始喝咖啡时的状态。在效果结束后，你的体力将立刻减少 C + 1，也即咖啡会让你额外感到 1 点体力的疲劳。 你的目标是在你睡着前爆发出生产力。对于给定的 S 和 C，你需要给出一个最优的安排，使总的完成度 最大化。

**题目分析**

假设在精力为u的时候喝咖啡，那么其在$t$到$t+c$的时间精力都保持u，$t+1+c$的时间后集体下降1，那么这个咖啡对整体的贡献值为$\frac{c(c-1)}{2}-(u-c)$所以当$u-v\ge \frac{c(c-1)}{2}$时喝咖啡可以产生贡献。贪心可得，假设其在$t$喝完咖啡之后肯定是接着一直喝咖啡。那么其可以被划分为若干段，且最后一次喝咖啡时的体力处于$x\in[0-c]$。这些值可以对应出来一个最大的$u$使得$u = k(c+1)+x$，而且这个u满足上面的柿子。然后可以发现k是关于x的一个分段函数，当其为x时对答案的贡献是$\frac{(x+k(c+1)+x)*(k+1)}{2}-\frac{(x+k(c+1)+1)*(x+k(c+1))}{2}$.然后通过判断鸡汁点进行$O(1)$计算或者进行三分。

**代码**

```c++
#include <vector>
#include <algorithm>
#include <iostream>
#include <array>

using ll = long long;

void sol() {
	ll s, c;
	std::cin >> s >> c;
	auto cacal = [&](ll x) {
		if (x > s)return 0ll;
		ll rem = x % (c + 1);
		ll len = x / (c + 1) + 1;
		return (x + rem) * len / 2 * c - x * (x + 1) / 2;
	};
	std::cout << 1ll * s * (s + 1) / 2 + std::max({cacal(s), cacal(c / 2 * c), cacal(s / c * c)}) << '\n';
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int t;
	std::cin >> t;
	while (t--) {
		sol();
	}

	return 0;
}
```



## 2.[HAOI2008]糖果传递

**题目描述**

有 $n$ 个小朋友坐成一圈，每人有 $a_i$ 个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为 $1$。

**输入格式**

小朋友个数 $n$，下面 $n$ 行 $a_i$。

对于 $100\%$ 的数据 $n\le 10^6$。

**输出格式**

求使所有人获得均等糖果的最小代价。

**题目分析**

最终所有小朋友的糖果数量都是平均数，那么假设$x_i$为$i$号小朋友给$i-1$号小朋友糖果的个数，正表示给出，负代表被给。那么对于每一个小朋友，可以列出方程：
$$
a_i-x_i+x_{i+1}=ave\\
x_{i+1} = x_i+ave-a_i
$$
带入每一个i可以得到：
$$
\left\{\begin{array}{c}


    x_2 = x_1+ave-a_1 \\

    x_3 = x_2+ave-a_2 \\
		 	...\\
    x_n = x_{n-1}+ave-a_n


\end{array}\right.
$$

消元可得：
$$
\left\{\begin{array}{c}


    x_2 = x_1+ave-a_1 \\

    x_3 = x_1+2*ave-a_1-a_2 \\
		 	...\\
    x_n = x_1+(n-1)*ave-\sum\limits_{i=1}^{n-1}a_i


\end{array}\right.
$$
题目要求的答案为$\sum\limits_{i=1}^{n}\abs{x_i}$那么就转化为了$\sum\limits_{i=1}^n\abs{x_1+(i-1)*ave-\sum\limits_{j=1}^ia_j}$那么问题就转化为了在数轴$x_1$到$i*ave-\sum\limits_{j=1}^ia_j$这些点的距离之和，根据初中数学就能得知$x_1$为$i*ave-\sum\limits_{j=1}^ia_j$的中位数时答案最小，然后就做完啦。

### 代码

```c++
//
// Created by mrx on 2022/9/14.
//
#include <bits/stdc++.h>

using ll = long long;

int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int n;
    while (std::cin >> n) {
        std::vector<ll> c(n);
        for (int i = 0; i < n; ++i) {
            std::cin >> c[i];
            if (i) c[i] += c[i - 1];
        }
        ll ave = c[n - 1] / n;
        for (int i = 0; i < n; ++i) {
            c[i] = (i + 1) * ave - c[i];
        }

        std::nth_element(c.begin(), c.begin() + n / 2, c.end());
        ll x1 = c[n / 2];
        ll ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += std::abs(c[i] - x1);
        }
        std::cout << ans << '\n';
    }
    return 0;
}
```



## 3.CCPC 2021 guangzhou F

An undirected connected graph is called a cactus, if and only if each edge of it belongs to at most one simple cycle. A simple cycle is a cycle that has no repeated vertices.

Now suppose there are 𝑓𝑛fn cactuses of 𝑛n distinct vertices, and the cactuses may have parallel edges and must not have self-loops, you need to calculate$\sum\limits_{i=1}^{n}\prod_{i != j }\frac{1 + f_i -f_i*f_j}{f_i - f_j}$.

The sum of a zero-length sequence is 00, and the product of a zero-length sequence is $1$.

**题意**

设一颗有$n$个点的仙人掌有$f_n$种，求上面的柿子。

**题解**

观察拉格朗日插值的公式：$f_n(x) = \sum\limits_{i=1}^{n} y_i(\prod _{i!=j}\frac{x - x_j}{x_i-x_j})$

发现上面的柿子和拉格朗日插值贼像。

阿巴阿巴不会。

但是发现只要序列长度相同带进去算出来无论取什么值算出来都一样的。

然后看上去就像斐波那契数咧。

## 4.[Tree Constructer](https://ac.nowcoder.com/acm/contest/52185/J)

**题意**

n个点的树，每个点分配$[0,1<<60)$的点权，如果u与v的点权进行按位或之后等于$2^{60}-1$那么有边，否则没边。求合法的点权序列构造出给定的树。

**分析**

黑白染色之后构造分类方式

读题之后发现，如果有某一位两个点都是0那么这两个点必定没有边，通过这个性质，对这个树进行黑白染色。
黑白染色之后，同色点之间必定没有边，那么使用两位二进制就可以把同色点全部分开。然后还剩下一些边为不相邻的黑白点之间的边，因为黑色点和白色点总和为n，那么必定有一种颜色的点的个数$\le \frac{1}{2}$对于点数较小的集合，按照标号依次分配二进制位为0。对于另一个颜色的集合，其在分配的二进制位中只有与其相邻的异色点对应编号的二进制位位1，其他均为0。

**代码**

```c++
//
// Created by mrx on 2023/2/27.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

using i64 = long long;

void solve() {
    int n;

    std::cin >> n;
    std::vector adj(n, std::vector<int>());
    for (int i = 1; i < n; ++i) {
        int u, v;
        std::cin >> u >> v;
        u--, v--;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }

    std::vector<std::vector<int>> cl(2);
    std::vector<int> color(n);
    std::function<void(int, int, int)> dfs = [&](int u, int p, int c) {
        cl[c].emplace_back(u);
        color[u] = c;
        for (auto x: adj[u]) {
            if (x == p)continue;
            dfs(x, u, c ^ 1);
        }
    };
    dfs(0, 0, 0);
    if (cl[0].size() > cl[1].size())std::swap(cl[0], cl[1]);
    std::vector<i64> ans(n, (1ll << 60) - (1ll << cl[0].size()));
    std::vector<int> pos(n, -1);
    for (int i = 0; i < cl[0].size(); ++i)pos[cl[0][i]] = i;
    for (auto x: cl[0])ans[x] ^= 1ll << 59, ans[x] ^= ((1ll << cl[0].size()) - 1) ^ 1ll << pos[x];
    for (auto x: cl[1])ans[x] ^= 1ll << 58;
    for (auto x: cl[1])for (auto v: adj[x])ans[x] ^= 1ll << pos[v];

//    for (int i = 0; i < n; ++i) {
//        for (int j = i + 1; j < n; ++j) {
//            if ((ans[i] | ans[j]) == (1ll << 60) - 1)std::cout << i + 1 << ' ' << j + 1 << '\n';
//        }
//    }
    for (auto x: ans)std::cout << x << ' ';
}


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    solve();
    return 0;
}
```

## 5.CFGYM104017B Drone Photo

**题意**

给一个n*n矩阵，由一个排列构成，取四个点构成一个长方形，使得最小的两个点不在对角线上。

**题解**

观察出来可得一个合法的矩形肯定有两个顺时针/逆时针递增的L形状序列，那么统计这种序列的个数然后除2既是答案。

**代码**

```c++
//
// Created by mrx on 2023/4/9.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

using i64 = long long;

void solve() {
    int n;
    std::cin >> n;
    std::vector mat(n, std::vector<int>(n));
    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j)std::cin >> mat[i][j];
    std::vector order_x(n, std::vector<int>(n)), order_y(n, std::vector<int>(n));
    for (int i = 0; i < n; ++i) {
        std::vector<int> tmp(n);
        std::iota(tmp.begin(), tmp.end(), 0);
        std::sort(tmp.begin(), tmp.end(), [&](int a, int b) { return mat[i][a] < mat[i][b]; });
        for (int j = 0; j < n; ++j) order_x[i][tmp[j]] = n - 1 - j;
        std::sort(tmp.begin(), tmp.end(), [&](int a, int b) { return mat[a][i] < mat[b][i]; });
        for (int j = 0; j < n; ++j) order_y[tmp[j]][i] = n - 1 - j;
    }
    
    i64 ans = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            ans += order_x[i][j] * (n - 1 - order_y[i][j]) + order_y[i][j] * (n - 1 - order_x[i][j]);
        }
    }
    std::cout << ans / 2 << '\n';
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
    solve();
    
    return 0;
}
```





# dp

## 数位dp

### 1.[2020 ICPC Shanghai Site](https://codeforces.com/gym/102900)

Given two non-negative integers $X$ and $Y$, determine the value of 
$$ \sum_{i=0}^{X}\sum_{j=[i=0]}^{Y}[i\&j=0]\lfloor\log_2(i+j)+1\rfloor $$
modulo $10^9+7$ where
$\&$ denotes bitwise AND;
$[A]$ equals 1 if $A$ is true, otherwise $0$;
$\lfloor x\rfloor$ equals the maximum integer whose value is no more than $x$.
The first line contains one integer $T\,(1\le T \le 10^5)$ denoting the number of test cases.

Each of the following $T$ lines contains two integers $X, Y\,(0\le X,Y \le 10^9)$ indicating a test case.

题意化简之后会发现这是一个i和j均有限制的数位dp，先钦定i>j然后进行数位dp，再钦定j>i再数位dp然后把它们加起来就行

trick:如果有两个数字有限制，要加入更多的状态。

```c++
//
// Created by mrx on 2022/11/18.
//
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <array>
#include <functional>
#include <numeric>
#include <cmath>
#include <iomanip>

using i64 = long long;

const long long mod = 1e9 + 7;

void sol() {
	int n, m;
	std::cin >> n >> m;

	std::vector<int> X(33), Y(33);
	int lena = 0;
	int lenb = 0;
	while (n) {
		lena++;
		X[lena] = n % 2;
		n = n >> 1;
	}
	while (m) {
		lenb++;
		Y[lenb] = m % 2;
		m = m >> 1;
	}
	std::vector<std::vector<std::vector<int>>> dp(X.size() + 1, std::vector<std::vector<int>>(2, std::vector<int>(2, -1)));
	std::vector<std::array<std::array<int, 2>, 2>> vis(X.size() + 1);
	std::function<int(int, int, int)> dfs = [&](int pos, int la, int lb) {
		if (vis[pos][la][lb])return dp[pos][la][lb];
		if (pos == 0)return 1;
		int xa = 0, xb = 0;
		xa = la ? X[pos] : 1;
		xb = lb ? Y[pos] : 1;
		int ret = 0;
		for (int i = 0; i <= xa; ++i) {
			for (int j = 0; j <= xb; ++j) {
				if (i & j)continue;
				ret += dfs(pos - 1, la && (i == xa), lb && (j == xb));
				ret %= mod;
			}
		}
		vis[pos][la][lb] = 1;
		dp[pos][la][lb] = ret % mod;
		return dp[pos][la][lb];
	};
	i64 ans = 0;
	for (int i = 1; i <= lena; i++) {
		ans = (ans + 1ll * dfs(i - 1, i == lena, i > lenb) * i % mod) % mod;
	}
	for (int i = 1; i <= lenb; i++) {
		ans = (ans + 1ll * dfs(i - 1, i > lena, i == lenb) * i % mod) % mod;
	}
	std::cout << ans << '\n';
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	int t;
	std::cin >> t;
	while (t--) {
		sol();
	}

	return 0;
}

```

### 2.[The 2022 ICPC Asia Xian Regional Contest](https://codeforces.com/gym/104077)E

题面暂时略，大意是求l和r之间三进制下popcount的大小

代码

也用到了两个数字之间限制的tirck

```c++
#include <bits/stdc++.h>

using i64 = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);


	int t;
	std::cin >> t;
	while (t--) {
		i64 l, r;
		std::cin >> l >> r;
		auto getstr = [&](i64 x) {
			std::vector<int> ret;
			do {
				ret.emplace_back(x % 3);
				x /= 3;
			} while (x);
//			std::reverse(ret.begin(), ret.end());
			return ret;
		};
		auto a = getstr(l), b = getstr(r);
		int n = b.size();
		if (a.size() != b.size())a.resize(b.size());
		std::reverse(a.begin(), a.end());
		std::reverse(b.begin(), b.end());
		std::vector dp(n, std::array<int, 8>{-1, -1, -1, -1, -1, -1, -1, -1});
		std::function<int(int, int)> dfs = [&](int pos, int stat) {
			int qd0 = stat >> 2 & 1;
			int limita = stat >> 1 & 1;
			int limitb = stat & 1;
			if (pos == n) {
				return qd0;
			}
			if (dp[pos][stat] != -1)return dp[pos][stat];
			int l = limita ? a[pos] : 0;
			int r = limitb ? b[pos] : 2;
			int ans = 0;
			for (int i = l; i <= r; ++i) {
				int nxt = 0;
				nxt |= (qd0 && i == 0) << 2;
				nxt |= (limita && i == l) << 1;
				nxt |= (limitb && i == r);
				ans = std::max(ans, (!(qd0 && i == 0)) + i + dfs(pos + 1, nxt));
			}
			return dp[pos][stat] = ans;
		};
		std::cout << dfs(0, 7) << '\n';
	}

	return 0;
}
```

### 3.[ Bit Sequence](https://ac.nowcoder.com/acm/contest/52185/L)

**题目大意**

令f(x)= __builtin_parity(x)求在$[0,L]$的范围中满足$f(x),f(x+1),…,f(x+n-1)$与给定数组a相同的x的个数

**分析**

一开始很容易想到这个序列的性质去，然后发现n只有100，那么$x+n$如果不在第7位二进制位产生高位进位则不会对更高位产生影响，直接暴力计算即可，如果产生进位的话，那在第7位前面连续的1的个数也会对答案产生影响，按照这个进行数位dp即可。

**代码**

```c++
//
// Created by mrx on 2023/2/27.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

using i64 = long long;
std::array<int, 277> f;

void solve() {
    int m;
    i64 L;
    std::cin >> m >> L;
    std::vector<int> a(m);
    for (int i = 0; i < m; ++i)std::cin >> a[i];
    std::vector<int> bits;
    i64 x = L;
    do {
        bits.push_back(x & 1);
        x >>= 1;
    } while (x);
    std::vector dp(bits.size(), std::vector<i64>(8, -1));//pos,status

    auto cacal = [&](int status) -> i64 {
        int lmt = status & 1;
        int cnt1 = (status >> 2) & 1;
        int cnt2 = (status >> 1) & 1;
        i64 hi = lmt ? L % 128 : 127;
        i64 res = 0;
        for (int i = 0; i <= hi; ++i) {
            int ok = 1;
            for (int j = 0; j < m && ok; ++j) {
                if (i + j < 128) ok &= (f[i + j] ^ cnt1) == a[j];
                else ok &= (f[i + j] ^ cnt1 ^ cnt2) == a[j];
            }
            res += ok;
        }
        return res;
    };
    std::function<i64(int, int)> dfs = [&](int pos, int status) -> i64 {
        auto& res = dp[pos][status];
        if (res != -1)return res;
        else if (pos <= 6)return res = cacal(status);
        res = 0;
        int cnt1 = (status >> 2) & 1, cnt2 = (status >> 1) & 1, lmt = status & 1;
        int up = lmt ? bits[pos] : 1;
        for (int i = 0; i <= up; ++i) {
            int nxl = lmt & (i == up), nxc1 = cnt1 ^ i, nxc2 = (!cnt2) & i;
            res += dfs(pos - 1, (nxl) | (nxc1 << 2) | (nxc2 << 1));
        }
        return res;
    };
    std::cout << dfs((int(bits.size())) - 1, 1) << '\n';
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int t;
    std::cin >> t;
    for (int i = 0; i < 277; ++i)f[i] = __builtin_parity(i);
    while (t--) {
        solve();
    }
    return 0;
}
```



## 普通dp






### 1.牛牛多校7-J

Grammy has a favorite number kkk. She thinks that all the numbers divisible by kkk are good. 

 For each array containing only numbers from 000 to k−1k-1k−1, Grammy define its goodness as the number of non-empty consecutive subarrays that sums to a good number. 

 Please count the number of arrays of length nnn such that its goodness is ttt. Since the answer can be enormous, output the answer modulo 998244353
A single line contains three integers n,k,tn,k,tn,k,t (1≤n,k≤64,0≤t≤n(n+1)

Output a single number, denoting the answer modulo 998244353.

**题目分析**

开始的时候苦思冥想想不出来，然后状态设计转变，把原数组改为前缀和数组，可以得知其为一一对应的，然后设计状态i为填前i个数字，j为填了j个位置，k为goodness。考虑状态转移，对于第i个数字，已经填了j个位置，将要填len个，那么$dp[i][j+len][k+(len)*(len-1)/2]+=dp[i-1][j][k]*C_{len+j}^{len}$,然后码代码即可。

```c++
//
// Created by mrx on 2022/8/8.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, int b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    int val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

constexpr int mod = 998244353;
using Z = Modular<mod>;

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int n, k, t;
    std::cin >> n >> k >> t;
    std::vector<std::vector<std::vector<Z>>> dp(k + 1, std::vector<std::vector<Z>>(n + 1, std::vector<Z>(t + 1)));
    std::vector<Z> fact(n + 1, 1), inv(n + 1, 1);
    for (int i = 1; i <= n; ++i) {
        fact[i] = fact[i - 1] * i;
        inv[i] = fact[i].inv();
    }

    auto C = [&](int y, int x) {
        return x < y ? 0 : fact[x] * inv[y] * inv[x - y];
    };

    for (int i = 0; i <= n; ++i) if (i * (i + 1) / 2 <= t)dp[0][i][i * (i + 1) / 2] = 1;

    for (int val = 1; val < k; ++val) {
        for (int len = 0; len <= n; ++len) {
            for (int cnt = 0; cnt <= t; ++cnt) {
                if (!dp[val - 1][len][cnt]) continue;
                for (int choose = 0; choose + len <= n && cnt + choose * (choose - 1) / 2 <= t; ++choose) {
                    dp[val][len + choose][cnt + choose * (choose - 1) / 2] += dp[val - 1][len][cnt] * C(choose, choose + len);
                }
            }
        }
    }

    std::cout << dp[k - 1][n][t] << '\n';
    return 0;
}
```

## 区间dp

### 1.UVA12991 Game Rooms

题意

一个  $N$ 层的大楼，每层只有一个游戏室，可以设置一个乒乓球桌或游泳池。第  $i$ 层有  $T_i$ 个人喜欢乒乓球和  $P_i$ 个人喜欢游泳。

现在要求使每个人到最近的喜欢的类型的活动室的距离的**和**最小，且这栋大楼要有至少一个乒乓球桌和至少一个游泳池。

这里的距离指楼层差的绝对值。例如，如果一个人到他喜欢的类型的游戏室位于同一楼层，则为  $0$；如果所需类型的最接近的游戏室正好在该员工的上方或下方一层，则为  $1$，以此类推。

输入格式

第一行给出数据组数  $T$（ $1\leq T\leq 100$）。接下来对于每组数据，首先一行给出  $N$（ $2\leq N\leq 4000$），代表该大楼一共有多少层；接下来  $N$ 行第  $i$ 行给出两个整数  $T_i, P_i$（ $1\leq T_i, P_i\leq 10^9$），代表第  $i$ 层的人数，意义同题意

题目分析：考虑一层楼，如果其建造了游泳池，那么该层居民不用动，不然要往上找游泳池或者往下找游泳池，假如有连续n层都建造的是游泳池，那么这n层想要打乒乓球的居民就要往下或者往上找乒乓球桌子，考虑每一个居民，他们找的肯定是离他们最近的，那么这n层的居民就被分为了两半，一半下楼一半上楼。容易想出来一种状态：$dp[i][0/1]$表示第i层建造的是游泳池/乒乓球桌子，那么枚举有连续几层游泳池/乒乓球桌子，就可以表示所有状态。可以得到状态转移方程：$dp[i][0]=dp[j][1]+cost(j+1,i,0),dp[i][1]=dp[j][0]+cost(j+1,i,1)(0\le j <i)$然后通过二维前后缀和以及一维前后缀和算出来cost。

代码：

```c++
//
// Created by mrx on 2022/8/10.
//
#include <bits/stdc++.h>

using ll = long long;

void sol() {
    int n;
    std::cin >> n;
    std::vector<std::array<ll, 2>> building(n);
    for (int i = 0; i < n; ++i)std::cin >> building[i][0] >> building[i][1];
    std::vector<std::array<ll, 2>> prefix_sum2(n + 2), suffix_sum2(n + 2);
    std::vector<std::array<ll, 2>> prefix_sum1(n + 2), suffix_sum1(n + 2);

    for (int i = 1; i <= n; ++i) {
        prefix_sum1[i][0] = prefix_sum1[i - 1][0] + building[i - 1][0];
        prefix_sum1[i][1] = prefix_sum1[i - 1][1] + building[i - 1][1];
    }
    for (int i = 1; i <= n; ++i) {
        prefix_sum2[i][0] = prefix_sum2[i - 1][0] + prefix_sum1[i][0];
        prefix_sum2[i][1] = prefix_sum2[i - 1][1] + prefix_sum1[i][1];
    }

    for (int i = n; i > 0; --i) {
        suffix_sum1[i][0] = suffix_sum1[i + 1][0] + building[i - 1][0];
        suffix_sum1[i][1] = suffix_sum1[i + 1][1] + building[i - 1][1];
    }
    for (int i = n; i > 0; --i) {
        suffix_sum2[i][0] = suffix_sum1[i][0] + suffix_sum2[i + 1][0];
        suffix_sum2[i][1] = suffix_sum1[i][1] + suffix_sum2[i + 1][1];
    }

    std::vector<std::vector<ll>> dp(n + 1, std::vector<ll>(2, 0x3f3f3f3f3f3f3f3f));
    auto cacal = [&](int l, int r, int type) {
        return prefix_sum2[r][type] - prefix_sum2[l - 1][type] - (r - l + 1) * prefix_sum1[l - 1][type];
    };
    auto cacal2 = [&](int l, int r, int type) {
        return suffix_sum2[l][type] - suffix_sum2[r + 1][type] - (r - l + 1) * suffix_sum1[r + 1][type];
    };
    auto cost = [&](int l, int r, int type) -> ll {
        if (l == 1 && r == n) {
            return 0x3f3f3f3f3f3f3f3f;
        } else if (l == 1) {
            return cacal(l, r, type);
        } else if (r == n) {
            return cacal2(l, r, type);
        } else {
            int mid = (l + r) >> 1;
            ll ret = 0;
            ret += cacal(mid + 1, r, type);
            ret += cacal2(l, mid, type);
            return ret;
        }
    };

    dp[0][0] = dp[0][1] = 0;
    for (int i = 1; i <= n; ++i) {
        dp[i][0] = dp[i][1] = 0x3f3f3f3f3f3f3f3f;
        for (int j = 0; j < i; ++j) {
            dp[i][0] = std::min(dp[i][0], dp[j][1] + cost(j + 1, i, 0));
            dp[i][1] = std::min(dp[i][1], dp[j][0] + cost(j + 1, i, 1));
        }
    }

    std::cout << std::min(dp[n][0], dp[n][1]) << '\n';
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int t;
    std::cin >> t;
    for (int i = 1; i <= t; ++i) {
        std::cout << "Case #" << i << ": ";
        sol();
    }
    return 0;
}
```

### 2.UVA10891 Game of Sum

**题目描述**

有一个长度为 $n$ 的整数序列，两个游戏者 $A$ 和 $B$ 轮流取数，$A$ 先取。每次玩家只能从左端或者右端取任意数量的数，但不能两边都取。所有数都被取走视为游戏结束，然后统计每个人取走的数之和，作为各自的得分。两个人采取的策略都是让自己得分尽可能高，并且两个人都很机智，求 $A$ 得分 - $B$ 得分后的结果。

输入格式

输入包含多组数据，每组数据第一行为正整数 $n(1\leq n\leq 100)$ ，第二行为给定的整数序列，输入结束标志是 $n=0$ 。

输出格式

对于每组数据，输出 $A$ 和 $B$ 都采取最优策略下，$A$ 的得分$-B$ 的得分。

**题目分析**

因为取数字的操作只能在头和尾进行，那么其在任意时候都是一个连续的序列，记$dp[l][r]$为先手在$l,r$这个子序列中获得的最大分数，那么很容易想到$n^3$暴力区间dp，状态转移方程为$dp[l][r]=sum[l][r]-min(dp[l][l+1],dp[l][l+2]....dp[l][r],dp[r][r],dp[r-1][r],dp[r-2][r]...dp[l][r])$答案为$dp[1][n]+(sum[n]-dp[1][n])$，考虑如何写$n^2$，观察到状态转移方程中有两坨东西，这坨东西可以在状态转移的时候记录在另一个数组里，然后就完成了优化，直接变成$O(n^2)$

**代码**

```c++
//
// Created by mrx on 2022/9/24.
//
#include <iostream>
#include <algorithm>
#include <vector>
#include <array>

using ll = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n;
	while (std::cin >> n && n) {
		std::vector<int> a(n + 1);
		for (int i = 1; i <= n; ++i)std::cin >> a[i];
		std::vector<int> sum(n + 1);
		for (int i = 1; i <= n; ++i)sum[i] = sum[i - 1] + a[i];
		std::vector<std::vector<int>> dp(n + 1, std::vector<int>(n + 1, 0));
		std::vector<int> lmin(n + 1, 0x3f3f3f3f), rmin(n + 1, 0x3f3f3f3f);

		for (int len = 1; len <= n; ++len) {
			for (int l = 1; l + len - 1 <= n; ++l) {
				int r = l + len - 1;
				dp[l][r] = sum[r] - sum[l - 1] - std::min({0, lmin[l], rmin[r]});
				lmin[l] = std::min(lmin[l], dp[l][r]);
				rmin[r] = std::min(rmin[r], dp[l][r]);
			}
		}
		std::cout << 2 * dp[1][n] - sum[n] << '\n';
	}
	return 0;
}
```



## 树形dp

### 1.P1270“访问”美术馆



**题目描述**

经过数月的精心准备，Peer Brelstet，一个出了名的盗画者，准备开始他的下一个行动。艺术馆的结构，每条走廊要么分叉为两条走廊，要么通向一个展览室。Peer知道每个展室里藏画的数量，并且他精确测量了通过每条走廊的时间。由于经验老到，他拿下一幅画需要5秒的时间。你的任务是编一个程序，计算在警察赶来之前，他最多能偷到多少幅画。

![](https://cdn.luogu.com.cn/upload/pic/85.png)

**输入格式**

第1行是警察赶到的时间，以s为单位。第2行描述了艺术馆的结构，是一串非负整数，成对地出现：每一对的第一个数是走过一条走廊的时间，第2个数是它末端的藏画数量；如果第2个数是0，那么说明这条走廊分叉为两条另外的走廊。数据按照深度优先的次序给出，请看样例。

一个展室最多有20幅画。通过每个走廊的时间不超过20s。艺术馆最多有100个展室。警察赶到的时间在10min以内。

**输出格式**

输出偷到的画的数量

**题目分析**

按照题目意思建树，观察可得，偷一幅画要进去出来，那么就把边长乘二，然后直接跑树形dp就好了。

**代码**

```c++
//
// Created by mrx on 2022/9/4.
//
#include <bits/stdc++.h>

using ll = long long;

int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int limit;
    std::cin >> limit;
    std::vector<std::pair<int, int>> s;
    s.emplace_back(0, 0);
    int tot = 0;
    int c, paint;
    while (std::cin >> c >> paint) {
        s.emplace_back(c * 2, paint);
        tot += paint;
    }
    int n = s.size();
    std::vector<std::vector<std::pair<int, int>>> G(n + 1);
    std::vector<int> fa(n + 1);
    std::vector<int> wei(n + 1);
    int cur = 1;
    std::function<void(int)> build = [&](int id) {
        wei[id] = s[id].second;
        if (wei[id] == 0) {
            G[id].emplace_back(cur + 1, s[cur + 1].first);
            build(++cur);//ls
            G[id].emplace_back(cur + 1, s[cur + 1].first);
            build(++cur);//rs
        }
    };
    G[0].emplace_back(1, s[1].first);
    build(1);
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(tot + 1, 0x3f3f3f3f));

    std::function<void(int)> dfs = [&](int u) {
        if (G[u].empty()) {
            for (int i = 0; i <= wei[u]; ++i) {
                dp[u][i] = i * 5;
            }
        }
        dp[u][0] = 0;
        for (auto [v, w]: G[u]) {
            dfs(v);
            wei[u] += wei[v];
            for (int i = std::min(tot, wei[u]); i >= 1; --i) {
                for (int j = std::min(i , wei[v]); j >= 0; --j) {
                    dp[u][i] = std::min(dp[u][i], dp[u][i - j] + dp[v][j] + w);
                }
            }
        }

    };
    dfs(0);
    int ans = 0;
    for (int i = 0; i <= tot; ++i) {
        if (dp[0][i] <limit)ans = i;
    }
    std::cout << ans << '\n';
    return 0;
}
```

### 2.CF461BAppleman and Tree

**题目描述**

给你一棵有 $n$ 个节点的树，下标从 $0$ 开始。

第 $i$ 个节点可以为白色或黑色。

现在你可以从中删去若干条边，使得剩下的每个部分恰有一个黑色节点。

问有多少种符合条件的删边方法，答案对 $10^9+7$ 取模。

输入格式

第一行一个整数 $n(1\leq n\leq 10^5)$，表示节点个数。

接下来一行 $n-1$ 个整数 $(p_0,p_1,\cdots,p_{n-2},0\leq p_i\leq i)$，表示树中有一条连接节点 $p_i$ 和节点 $i+1$ 的边。

接下来一行 $n$ 个整数 $(x_0,x_1,\cdots,x_{n-1},0\leq x_i\leq 1)$，若 $x_i$ 为 $1$，则节点 $i$ 为黑色，否则为白色。

输出格式

第一行一个整数，表示符合条件的删边方法的方案数对 $10^9+7$ 取模后的值。

**题目分析**

考虑树形dp，发现每个节点和其子树的关系有：1.节点所在的连通块没有1。2.节点所在的连通块有1。设$dp[u][0/1]$为u节点所在的连通块没有1的方案，有1的方案。那么可以得到dp的状态转移方程：$dp[u][1]=dp[u][1]*dp[v][0]+dp[u][1]*dp[v][1]+dp[u][0]*dp[v][1]$三个项分别代表1.u合法，v不合法，不切断。2.u合法，v合法，切断。3.u不合法，v合法，不切断。同理，$dp[u][0]=dp[u][0]*dp[v][1]+dp[u][0]*dp[v][0]$代表1.u不合法，v合法，切断。2.u不合法，v也不合法，不切断。每个节点处理一下初始值即可。

**代码**

```c++
//
// Created by mrx on 2022/9/27.
//
#include <vector>
#include <algorithm>
#include <iostream>
#include <array>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
	T u = 0, v = 1;
	while (a != 0) {
		T t = b / a;
		b -= t * a;
		std::swap(a, b);
		u -= t * v;
		std::swap(u, v);
	}
	assert(b == 1);
	return u;
}

template<typename T>
T power(T a, int b) {
	T ans = 1;
	for (; b; a *= a, b >>= 1) {
		if (b & 1)ans *= a;
	}
	return ans;
}

template<int Mod>
class Modular {
public:
	using Type = int;

	template<typename U>
	static Type norm(U& x) {
		Type v;
		if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
		else v = static_cast<Type>(x % Mod);
		if (v < 0) v += Mod;
		return v;
	}

	constexpr Modular() : value() {}

	int val() const { return value; }

	Modular inv() const {
		return Modular(inverse(value, Mod));
	}

	template<typename U>
	Modular(const U& x) {
		value = norm(x);
	}

	const Type& operator ()() const {
		return value;
	}

	template<typename U>
	explicit operator U() const {
		return static_cast<U>(value);
	}

	Modular& operator +=(const Modular& other) {
		if ((value += other.value) >= Mod) value -= Mod;
		return *this;
	}

	Modular& operator -=(
			const Modular& other) {
		if ((value -= other.value) < 0) value += Mod;
		return *this;
	}

	template<typename U>
	Modular& operator +=(const U& other) { return *this += Modular(other); }

	template<typename U>
	Modular& operator -=(const U& other) { return *this -= Modular(other); }

	Modular& operator ++() { return *this += 1; }

	Modular& operator --() { return *this -= 1; }

	Modular operator ++(int) {
		Modular result(*this);
		*this += 1;
		return result;
	}

	Modular operator --(int) {
		Modular result(*this);
		*this -= 1;
		return result;
	}

	Modular operator -() const { return Modular(-value); }

	template<class ISTREAM_TYPE>
	friend ISTREAM_TYPE& operator >>(ISTREAM_TYPE& is, Modular& rhs) {
		ll v;
		is >> v;
		rhs = Modular(v);
		return is;
	}

	template<class OSTREAM_TYPE>
	friend OSTREAM_TYPE& operator <<(OSTREAM_TYPE& os, const Modular& rhs) {
		return os << rhs.val();
	}

	Modular& operator *=(const Modular& rhs) {
		value = ll(value) * rhs.value % Mod;
		return *this;
	}

	Modular& operator /=(const Modular& other) { return *this *= Modular(inverse(other.value, Mod)); }

	friend const Type& abs(const Modular& x) { return x.value; }

	friend bool operator ==(const Modular& lhs, const Modular& rhs) { return lhs.value == rhs.value; }

	friend bool operator <(const Modular& lhs, const Modular& rhs) { return lhs.value < rhs.value; }


	bool operator ==(const Modular& rhs) { return *this == rhs.value; }

	template<typename U>
	bool operator ==(U rhs) { return *this == Modular(rhs); }

	template<typename U>
	friend bool operator ==(U lhs, const Modular& rhs) { return Modular(lhs) == rhs; }

	bool operator !=(const Modular& rhs) { return *this != rhs; }

	template<typename U>
	bool operator !=(U rhs) { return *this != rhs; }

	template<typename U>
	friend bool operator !=(U lhs, const Modular& rhs) { return lhs != rhs; }

	bool operator <(const Modular& rhs) { return this->value < rhs.value; }

	Modular operator +(const Modular& rhs) { return Modular(*this) += rhs; }

	template<typename U>
	Modular operator +(U rhs) { return Modular(*this) += rhs; }

	template<typename U>
	friend Modular operator +(U lhs, const Modular& rhs) { return Modular(lhs) += rhs; }

	Modular operator -(const Modular& rhs) { return Modular(*this) -= rhs; }

	template<typename U>
	Modular operator -(U rhs) { return Modular(*this) -= rhs; }

	template<typename U>
	friend Modular operator -(U lhs, const Modular& rhs) { return Modular(lhs) -= rhs; }

	Modular operator *(const Modular& rhs) { return Modular(*this) *= rhs; }

	template<typename U>
	Modular operator *(U rhs) { return Modular(*this) *= rhs; }

	template<typename U>
	friend Modular operator *(U lhs, const Modular& rhs) { return Modular(lhs) *= rhs; }

	Modular operator /(const Modular& rhs) { return Modular(*this) /= rhs; }

	template<typename U>
	Modular operator /(U rhs) { return Modular(*this) /= rhs; }

	template<typename U>
	friend Modular operator /(U lhs, const Modular& rhs) { return Modular(lhs) /= rhs; }

private:
	Type value;
};

const int mod = 1e9 + 7;
using Z = Modular<mod>;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n;
	std::cin >> n;
	std::vector<std::vector<int>> G(n);
	for (int i = 1; i < n; ++i) {
		int x;
		std::cin >> x;
		G[i].push_back(x);
		G[x].push_back(i);
	}
	std::vector<int> color(n);
	for (int i = 0; i < n; ++i) {
		std::cin >> color[i];
	}

	std::vector<std::array<Z, 2>> dp(n);
	std::function<void(int, int)> dfs = [&](int u, int fa) {
		dp[u][color[u]] = 1;
		for (auto v: G[u]) {
			if (v == fa)continue;
			dfs(v, u);
			dp[u][1] = dp[u][0] * dp[v][1] + dp[u][1] * (dp[v][1] + dp[v][0]);
			dp[u][0] = dp[u][0] * (dp[v][1] + dp[v][0]);
		}
	};


	dfs(0, -1);
//	for (int i = 0; i < n; ++i) {
//		std::cout << dp[i][0] << ' ' << dp[i][1] << '\n';
//	}
	std::cout << dp[0][1] << '\n';
	return 0;
}
```

### 3.树

**题目描述**

给你两棵分别有n个节点和m个节点的树。

刚开始两棵树是不连通的,你需要在两棵树中各选一个节点,连接他们,使得两棵树变联通。

我们用dis(i,j) 来表示从i到达j经过边的最小数量。

对于连接后的联通图,你需要最小化$\frac{(n+m)(n+m-1)}{2}$个点对的dis

**题目分析**

将两棵树的根连接在一起，可以得到这两棵树选出两个点的距离和平方为$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}(dis(i,root1)+dis(j,root2)+1)^2$,记$A_1$为树1的$\sum dis(i,root)$,$A_2$为树2的$\sum dis(i,root)$,$B_1$为树1的$\sum dis(i,root)+dis^2(i,root)$,$B_2$为树2的$\sum dis(i,root)+dis^2(i,root)$,可以把上柿化简为$A_1\cdot A_2+m\cdot B_1+n\cdot B_2+n\cdot m$。然后加上树内的贡献即可。求树内贡献时可以考虑当其位于$u$,其有子树$v$,遍历u的子树，其对答案产生的贡献就是u的子树和v的子树进行合并，同时维护$sumdis$和$sumdis^2$,然后进行换根dp，换根完之后考虑将树1和树2合并，我这里是按$A_1+mB_1$对树1的点进行sort，$A_2+nB_2$对树2的点进行sort然后各取前一万个取min，因为$sumdis$和$sumdis^2$都是正数，所以很难卡掉。

**代码**

```c++
//
// Created by mrx on 2022/10/5.
//
#include <vector>
#include <algorithm>
#include <iostream>
#include <array>
#include <numeric>

using ll = long long;

ll merge(ll sa1, ll sa2, ll nn, ll sb1, ll sb2, ll mm) {
	return mm * sa2 + nn * sb2 + 2 * sa1 * sb1 + nn * mm + 2 * mm * sa1 + 2 * nn * sb1;
}

struct tree {
	std::vector<std::vector<int>> adj;

	std::vector<ll> sumdep, sumdep2, siz;
	ll val = 0;

	tree(int n) : adj(n + 1), sumdep(n + 1), sumdep2(n + 1), siz(n + 1) {}

	void ade(int u, int v) {
		adj[u].push_back(v);
		adj[v].push_back(u);
	}

	void dfs1(int u, int fa) {
		siz[u] = 1;
		sumdep[u] = 0;
		sumdep2[u] = 0;
		for (auto v: adj[u]) {
			if (v == fa)continue;
			dfs1(v, u);
			val += merge(sumdep[u], sumdep2[u], siz[u], sumdep[v], sumdep2[v], siz[v]);
			siz[u] += siz[v];
			sumdep[u] += sumdep[v] + siz[v];
			sumdep2[u] += sumdep2[v] + 2 * sumdep[v] + siz[v];
		}
	}

	void dfs2(int u, int fa) {
		for (auto v: adj[u]) {
			if (v == fa)continue;
			sumdep2[v] = (sumdep2[u] - sumdep2[v] - 2 * sumdep[v] - siz[v]) + 2 * (sumdep[u] - sumdep[v] - siz[v]) + siz[u] - siz[v] + sumdep2[v];
			sumdep[v] = (sumdep[u] - sumdep[v] + siz[u] - siz[v]) + sumdep[v] - siz[v];
			siz[v] = siz[u];
			dfs2(v, u);
		}
	}

	void show() {
		for (int i = 1; i < sumdep.size(); ++i)std::cerr << sumdep[i] << " \n"[i == sumdep.size() - 1];
		for (int i = 1; i < sumdep2.size(); ++i)std::cerr << sumdep2[i] << " \n"[i == sumdep2.size() - 1];
		for (int i = 1; i < siz.size(); ++i)std::cerr << siz[i] << " \n"[i == siz.size() - 1];
	}
};

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n, m;
	std::cin >> n;
	tree t1(n);
	for (int i = 1; i < n; ++i) {
		int u, v;
		std::cin >> u >> v;
		t1.ade(u, v);
	}
	t1.dfs1(1, 1);
	t1.dfs2(1, 1);

	std::cin >> m;
	tree t2(m);
	for (int i = 1; i < m; ++i) {
		int u, v;
		std::cin >> u >> v;
		t2.ade(u, v);
	}
	t2.dfs1(1, 1);
	t2.dfs2(1, 1);
	ll ans = 4e18;
	//令A = sumdep , B = sumdep + sumdep2;
	//ans = min(A1*A2 + mB1 + nB2 + nm);
	std::vector<int> aa(n), bb(m);
	std::iota(aa.begin(), aa.end(), 1);
	std::iota(bb.begin(), bb.end(), 1);
	std::sort(aa.begin(), aa.end(), [&](int i, int j) {
		return t1.sumdep2[i] + m * (t1.sumdep[i] + t1.sumdep2[i]) < t1.sumdep2[j] + m * (t1.sumdep[j] + t1.sumdep2[j]);
	});

	std::sort(bb.begin(), bb.end(), [&](int i, int j) {
		return t2.sumdep2[i] + n * (t2.sumdep[i] + t2.sumdep2[i]) < t2.sumdep2[j] + n * (t2.sumdep[j] + t2.sumdep2[j]);
	});

	for (int i = 0; i < std::min(int(1e4), n); ++i) {
		for (int j = 0; j < std::min(int(1e4), m); ++j) {
			ans = std::min(ans, merge(t1.sumdep[aa[i]], t1.sumdep2[aa[i]], t1.siz[aa[i]], t2.sumdep[bb[j]], t2.sumdep2[bb[j]], t2.siz[bb[j]]));
		}
	}
	std::cout << t1.val + t2.val + ans << '\n';
	return 0;
}
```



## 优化

### 1.CF1715 ELong Way Home

**题目描述**

有 $n$ 座城市，城市间有 $m$ 条双向道路，通过第 $i$ 条道路需要花费 $w_i$ 的时间，任意两个城市之间都有航班，乘坐城市 $u$ 和 $v$ 之间的航班需要花费 $(u-v)^2$ 的时间。

现在请对于任意城市 $i(1 \le i \le n)$，求出从城市 $1$ 出发，到达城市 $i$ 所需要的最短时间，注意从城市 $1$ 到 $i$ 的过程中**最多乘坐 $k$ 次航班**。

**题目分析**

看到平方直接一眼dp，但是发现还有地上的道路，所以要跑一跑dij，然后 由于每个点可以从所有点转移过来，所以先预处理出一个凸壳，然后利用斜率的单调性进行斜率优化，更新一下时间，然后再放缩一遍。因为最多做k次放缩，所以总的时间复杂度为$O(k(n+mlogn))$

```c++
//
// Created by mrx on 2022/9/29.
//
#include <vector>
#include <algorithm>
#include <iostream>
#include <array>
#include <queue>

using ll = long long;

struct line {
	ll k, b;

	line(ll k, ll b) : k(k), b(b) {}

	double intersect(const line& l) const { return 1.0 * (l.b - b) / (k - l.k); }

	bool operator <(const line& rhs) const {
		if (k == rhs.k) return b > rhs.b;
		return k < rhs.k;
	}

	ll operator ()(ll x) const { return k * x + b; }
};

struct ConvexHull {
	std::vector<double> points;
	std::vector<line> lines;

	int size() { return points.size(); }

	void reset() {
		points.clear();
		lines.clear();
	}

	void init(const line& l) {
		points.push_back(-1e9);
		lines.push_back(l);
	}

	void addLine(const line& l) {
		if (points.size() == 0) {
			points.push_back(-1e9);
			lines.push_back(l);
			return;
		}
		while (lines.size() >= 2 && l.intersect(lines[lines.size() - 2]) <= points.back()) {
			points.pop_back();
			lines.pop_back();
		}
		points.push_back(l.intersect(lines.back()));
		lines.push_back(l);
	}

	ll query(int x, int id) { return lines[id](x); }

	ll query(int x) {
		int id = upper_bound(points.begin(), points.end(), x) - points.begin() - 1;
		return lines[id](x);
	}
};

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n, m, k;
	std::cin >> n >> m >> k;

	std::vector<std::vector<std::pair<int, ll>>> adj(n);
	for (int i = 0; i < m; ++i) {
		int u, v;
		ll w;
		std::cin >> u >> v >> w;
		u--, v--;
		adj[u].emplace_back(v, w);
		adj[v].emplace_back(u, w);
	}

	std::vector<ll> dis(n, 0x3f3f3f3f3f3f3f3f);
	std::function<void(const std::vector<int>&)> dijkstra = [&](const std::vector<int>& start) {
		std::priority_queue<std::pair<ll, int>, std::vector<std::pair<ll, int>>, std::greater<>> q;
		for (auto i: start)q.emplace(dis[i], i);
		while (!q.empty()) {
			auto [dist, u] = q.top();
			q.pop();
			if (dis[u] != dist)continue;
			for (auto [v, w]: adj[u]) {
				if (w + dis[u] < dis[v]) {
					dis[v] = w + dis[u];
					q.emplace(dis[v], v);
				}
			}
		}
	};

	dis[0] = 0;
	dijkstra((std::vector<int>(1)));

	for (int i = 0; i < k; ++i) {
		ConvexHull ch;
		std::vector<int> change;
		for (ll j = 0; j < n; ++j) {
			ch.addLine(line(-2 * j, dis[j] + j * j));
		}
		int id = 0;
		for (ll u = 1; u < n; u++) {
			while (id + 1 < ch.size() && ch.query(u, id + 1) < ch.query(u, id)) id++;
			ll cur = ch.query(u, id) + ll(u) * u;
			if (cur < dis[u]) {
				change.push_back(u);
				dis[u] = cur;
			}
		}
		dijkstra(change);
	}
	for (int i = 0; i < n; ++i)std::cout << dis[i] << " \n"[i == n - 1];
	return 0;
}
```

 

### 2.CFGYM104017C  Il Derby della Madonnina

**题意**

裁判在一条直线上，在第$t_i$时，他走到$a_i$点，他获得一分，起始，裁判在0号点，最大速度为v，求其能得几分。

**题解**

$|a_i-a_j|\le v*(t_i-t_j)$时，裁判可以从$j$号点转移到$i$号点。即

$a_i-a_j \le v*(t_i-t_j) $且$a_i-a_j\ge -v*(t_i-t_j)$时可以转移，移项得到：

$a_i-v*t_i\le a_j-v*t_j$且$a_i+v*t_i\ge a_j+v*t_j$时才可转移，记$l_i=a_i-v*t_i$,$r_i= a_i+v*t_i$，那么当

$l_i\le l_j$,$r_i\ge r_j$时可以转移，那么问题转化为了有多少个(l,r)套在一起，用线段树可以维护。

**代码**

```c++
//
// Created by mrx on 2023/4/9.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

using i64 = long long;


struct Nod {
    i64 max;
    
    Nod() : max(0) {}
    
    Nod(int x) {
        max = x;
    }
    
    //根据需要改变
    friend Nod merge(const Nod& lhs, const Nod& rhs) {
        Nod ans;
        ans.max = std::max(lhs.max, rhs.max);
        return ans;
    }
    
};


struct SegmentTree {
    std::vector<Nod> tree;
    int n;
    
    inline void push_up(int rt) {
        tree[rt] = merge(tree[rt << 1], tree[rt << 1 | 1]);
    }
    
    template<typename M>
    void build(int l, int r, int rt, const std::vector<M>& base) {
        if (l == r) {
            tree[rt] = base[l];
            return;
        }
        int m = (l + r) >> 1;
        build(l, m, rt << 1, base);
        build(m + 1, r, rt << 1 | 1, base);
        push_up(rt);
    }
    
    template<typename M>
    void _modify(int l, int r, int L, int R, int rt, const M& v) {
        if (L <= l && r <= R) {
            tree[rt] = v;
            return;
        }
        int m = (l + r) >> 1;
        if (L <= m)_modify(l, m, L, R, rt << 1, v);
        if (R > m)_modify(m + 1, r, L, R, rt << 1 | 1, v);
        push_up(rt);
    }
    
    Nod qry(int l, int r, int L, int R, int rt) {
        if (L <= l && r <= R) {
            return tree[rt];
        }
        int m = (l + r) >> 1;
        Nod res;
        if (R <= m)res = qry(l, m, L, R, rt << 1);
        else if (L > m)res = qry(m + 1, r, L, R, rt << 1 | 1);
        else res = merge(qry(l, m, L, R, rt << 1), qry(m + 1, r, L, R, rt << 1 | 1));
        push_up(rt);
        return res;
    }
    
    template<class Type>
    SegmentTree(const std::vector<Type>& a) {
        n = a.size();
        n--;
        tree.resize((n << 2) + 1);
        build(1, n, 1, a);
    }
    
    template<typename M>
    void modify(int L, int R, const M& v) {
        _modify(1, n, L, R, 1, v);
    }
    
    Nod query(int L, int R) {
        return qry(1, n, L, R, 1);
    }
    
    Nod query(int pos) {
        return qry(1, n, pos, pos, 1);
    }
};


void solve() {
    int n, v;
    std::cin >> n >> v;
    std::vector<i64> a(n), t(n);
    for (int i = 0; i < n; ++i)std::cin >> t[i];
    for (int i = 0; i < n; ++i)std::cin >> a[i];
    std::vector<std::pair<i64, i64>> lr;
    for (int i = 0; i < n; ++i) {
        i64 l = a[i] - v * t[i], r = a[i] + v * t[i];
        if (l <= 0 && r >= 0)lr.emplace_back(l, r);
    }
    lr.emplace_back(0, 0);
    std::vector<i64> lsh;
    for (auto& [l, r]: lr) {
        lsh.push_back(l);
        lsh.push_back(r);
    }
    std::sort(lsh.begin(), lsh.end());
    lsh.erase(std::unique(lsh.begin(), lsh.end()), lsh.end());
    for (auto& [l, r]: lr) {
        l = std::lower_bound(lsh.begin(), lsh.end(), l) - lsh.begin() + 1;
        r = std::lower_bound(lsh.begin(), lsh.end(), r) - lsh.begin() + 1;
    }
    SegmentTree Tree(std::vector<int>(lsh.size() + 2, 0));
    std::sort(lr.begin(), lr.end(), [](const auto& lhs, const auto& rhs) {
        return lhs.second == rhs.second ? lhs.first > rhs.first : lhs.second < rhs.second;
    });
    i64 ans = 0;
    for (auto [l, r]: lr) {
        auto tmp = Tree.query(l, r).max;
        tmp++;
        ans = std::max(ans, tmp);
        Tree.modify(l, l, tmp);
    }
    std::cout << ans - 1 << '\n';
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    solve();
    return 0;
}
```







## 状态压缩

### 1.P2167Bill的挑战

**题目描述**

Sheng_bill 不仅有惊人的心算能力，还可以轻松地完成各种统计。在昨天的比赛中，你凭借优秀的程序与他打成了平局，这导致 Sheng_bill  极度的不满。于是他再次挑战你。这次你可不能输。

这次，比赛规则是这样的：

给出 $N$ 个长度相同的字符串（由小写英文字母和 `?` 组成），$S_1,S_2,\dots,S_N$，求与这 $N$ 个串中的刚好 $K$ 个串匹配的字符串 $T$ 的个数，答案对 $1000003$ 取模。

若字符串 $S_x(1\le x\le N)$ 和 $T$ 匹配，满足以下条件：
1. $|S_x|=|T|$。
2. 对于任意的 $1\le i\le|S_x|$，满足 $S_x[i]= \texttt{?}$ 或者 $S_x[i]=T[i]$。

其中 $T$ 只包含小写英文字母。

**题目分析**

容易想到简单的dp：$dp[i][2][2][2][2]...[2]$表示匹配到第i位，其他维度表示若干个字符串是不是匹配的方案数，namo考虑状态压缩$dp[i][s]$表示匹配到第i位，字符串状态为s的匹配方案数。

考虑状态转移，枚举第i位的字符，对于其中枚举状态，如果$str[j][i](s_0>>j\&1)$可以于枚举的字符匹配，那么状态转移至$dp[i+1][s_0]$,但是每次都这么枚举太慢了，所以对于每一个位置每一个颜色预处理合法字符串的状态。

**代码**

```c++
//
// Created by mrx on 2022/8/7.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, int b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    int val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

constexpr int mod = 1000003;
using Z = Modular<mod>;

void sol() {
    int n, k;
    std::cin >> n >> k;
    std::vector<std::string> str(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> str[i];
    }
    int len = str[0].length();
    std::vector<std::vector<int>> match(26, std::vector<int>(len, 0));//char,pos


    for (int i = 0; i < 26; ++i) {
        for (int j = 0; j < n; ++j) {
            for (int pos = 0; pos < len; ++pos) {
                if (str[j][pos] == '?' || str[j][pos] == 'a' + i) {
                    match[i][pos] |= (1 << j);
                }
            }
        }
    }

    std::vector<std::vector<Z>> dp((1 << n), std::vector<Z>(len + 1, 0));
    dp[(1 << n) - 1][0] = 1;
    for (int pos = 0; pos < len; ++pos) {
        for (int s = 0; s < 1 << n; ++s) {
            for (int i = 0; i < 26; ++i) {
                dp[s & match[i][pos]][pos + 1] += dp[s][pos];
            }
        }
    }
    Z ans = 0;
    for (int s = 0; s < 1 << n; ++s) {
        if (__builtin_popcount(s) == k) {
            ans += dp[s][len];
        }
    }
    std::cout << ans << '\n';
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int t;
    std::cin >> t;
    while (t--)sol();
    return 0;
}
```



### 2.P3959宝藏

**题目描述**

参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 $n$ 个深埋在地下的宝藏屋， 也给出了这 $n$ 个宝藏屋之间可供开发的 $m$ 条道路和它们的长度。

小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远，也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路则相对容易很多。

小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。

在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以 任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏屋之间的道路无需再开发。

新开发一条道路的代价是 $\mathrm{L} \times \mathrm{K}$。其中 $L$ 代表这条道路的长度，$K$ 代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。

请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。

### 3.UVA1099 Sharing Chocolate

**题目描述**

给出一块长为 $x$, 宽为 $y$ 的矩形巧克力，每次操作可以沿一条直线把一块巧克力切割成两块长宽均为整数的巧克力（一次不能同时切割多块巧克力）。 

问：是否可以经过若干次操作得到 $n$ 块面积分别为 $a_1, a_2, ..., a_n$ 的巧克力

**题目分析**

因为一次切割只能横着切或者竖着切，同时考虑到$n$非常小，那么考 $dp[x][y][z]$ 表示长 $x$ ，宽 $y$ 的巧克力能不能分割出状态 $s$ 的巧克力。状态转移时枚举 $s$ 的子集。但是这样进行状态转移的时间复杂度为 $O(x*y*(x+y)*3^n)$ 总的状态数有$x*y*2^n$ 个，这样必然tle，同时仔细一分析，发现如果一块巧克力能恰好分割为若干块，那么他们的面积和必然是一样的。这样可以忽略非常多的状态。同时，知道$x$和$s$之后就能求出来$y$，所以状态变为了$dp[x][s]$。时空复杂度都大幅下降。

**代码**

```c++
//
// Created by mrx on 2022/10/28.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

using i64 = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n;
	int cas = 1;
	while (std::cin >> n && n) {
		int x, y;
		std::cin >> x >> y;
		std::vector<int> a(n);
		for (int i = 0; i < n; ++i)std::cin >> a[i];
		std::vector<int> sum(1 << n);
		for (int s = 0; s < 1 << n; ++s) {
			int tmp = s;
			while (tmp) {
				int lbt = tmp & -tmp;
				int i = __builtin_ctz(lbt);
				sum[s] += a[i];
				tmp -= lbt;
			}
		}

//		std::vector<std::vector<std::vector<bool>>> mp(105, std::vector<std::vector<bool>>(105, std::vector<bool>(1 << n)));
//		std::vector<std::vector<std::vector<bool>>> vis(105, std::vector<std::vector<bool>>(105, std::vector<bool>(1 << n)));
//
//		std::function<bool(int, int, int)> dfs = [&](int c, int r, int s) -> bool {
//			if (vis[c][r][s])return mp[c][r][s];
//			vis[c][r][s] = true;
//
//			if (c == 1) return mp[c][r][s] = r >= sum[s];
//			if (r == 1) return mp[c][r][s] = c >= sum[s];
//
//			for (int s0 = s; s0; s0 = s & (s0 - 1)) {
//				for (int j = 1; j < c; ++j) if (dfs(c - j, r, s0) && dfs(j, r, s ^ s0))return mp[c][r][s] = true;
//				for (int j = 1; j < r; ++j) if (dfs(c, r - j, s0) && dfs(c, j, s ^ s0))return mp[c][r][s] = true;
//			}
//
//			return mp[c][r][s] = false;
//		};

		std::vector<std::vector<bool>> dp(101, std::vector<bool>(1 << n));
		std::vector<std::vector<bool>> vis(101, std::vector<bool>(1 << n));

		std::function<bool(int, int)> dfs = [&dp, &vis, &sum, &dfs](int x, int s) -> bool {
			if (vis[x][s])return dp[x][s];
			vis[x][s] = true;
			if (__builtin_popcount(s) == 1)return dp[x][s] = true;
			int y = sum[s] / x;
			for (int s0 = (s - 1) & s; s0; s0 = (s0 - 1) & s) {
				int x0 = sum[s0] / y;
				int y0 = sum[s0] / x;
				int x1 = sum[s ^ s0] / y;
				int y1 = sum[s ^ s0] / x;
				if (sum[s0] % x == 0 && dfs(std::min(x, y0), s0) && dfs(std::min(x, y1), s0 ^ s))return dp[x][s] = true;
				if (sum[s0] % y == 0 && dfs(std::min(x0, y), s0) && dfs(std::min(x1, y), s ^ s0))return dp[x][s] = true;
			}
			return dp[x][s] = false;
		};

		std::cout << "Case " << cas++ << ": ";
		std::cout << (dfs(std::min(x, y)//
// Created by mrx on 2022/10/28.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

using i64 = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n;
	int cas = 1;
	while (std::cin >> n && n) {
		int x, y;
		std::cin >> x >> y;
		std::vector<int> a(n);
		for (int i = 0; i < n; ++i)std::cin >> a[i];
		std::vector<int> sum(1 << n);
		for (int s = 0; s < 1 << n; ++s) {
			int tmp = s;
			while (tmp) {
				int lbt = tmp & -tmp;
				int i = __builtin_ctz(lbt);
				sum[s] += a[i];
				tmp -= lbt;
			}
		}

//		std::vector<std::vector<std::vector<bool>>> mp(105, std::vector<std::vector<bool>>(105, std::vector<bool>(1 << n)));
//		std::vector<std::vector<std::vector<bool>>> vis(105, std::vector<std::vector<bool>>(105, std::vector<bool>(1 << n)));
//
//		std::function<bool(int, int, int)> dfs = [&](int c, int r, int s) -> bool {
//			if (vis[c][r][s])return mp[c][r][s];
//			vis[c][r][s] = true;
//
//			if (c == 1) return mp[c][r][s] = r >= sum[s];
//			if (r == 1) return mp[c][r][s] = c >= sum[s];
//
//			for (int s0 = s; s0; s0 = s & (s0 - 1)) {
//				for (int j = 1; j < c; ++j) if (dfs(c - j, r, s0) && dfs(j, r, s ^ s0))return mp[c][r][s] = true;
//				for (int j = 1; j < r; ++j) if (dfs(c, r - j, s0) && dfs(c, j, s ^ s0))return mp[c][r][s] = true;
//			}
//
//			return mp[c][r][s] = false;
//		};

		std::vector<std::vector<bool>> dp(101, std::vector<bool>(1 << n));
		std::vector<std::vector<bool>> vis(101, std::vector<bool>(1 << n));

		std::function<bool(int, int)> dfs = [&dp, &vis, &sum, &dfs](int x, int s) -> bool {
			if (vis[x][s])return dp[x][s];
			vis[x][s] = true;
			if (__builtin_popcount(s) == 1)return dp[x][s] = true;
			int y = sum[s] / x;
			for (int s0 = (s - 1) & s; s0; s0 = (s0 - 1) & s) {
				int x0 = sum[s0] / y;
				int y0 = sum[s0] / x;
				int x1 = sum[s ^ s0] / y;
				int y1 = sum[s ^ s0] / x;
				if (sum[s0] % x == 0 && dfs(std::min(x, y0), s0) && dfs(std::min(x, y1), s0 ^ s))return dp[x][s] = true;
				if (sum[s0] % y == 0 && dfs(std::min(x0, y), s0) && dfs(std::min(x1, y), s ^ s0))return dp[x][s] = true;
			}
			return dp[x][s] = false;
		};

		std::cout << "Case " << cas++ << ": ";
		if (sum[(1 << n) - 1] != x * y)std::cout << "No\n";
		else std::cout << (dfs(std::min(x, y), (1 << n) - 1) ? "Yes" : "No") << '\n';
	}
	return 0;
}, (1 << n) - 1) ? "Yes" : "No");
		std::cout << '\n';
	}

	return 0;
}
```





# 数学

## 组合数学

### 卢卡斯定理

#### P5598【XR-4】混乱度

**题目描述**

小 X 有 $n$ 种颜色的球，其中第 $i$ 种颜色的球共有 $a_i$ 个，同色的球无法区分。定义第 $l \sim r$ 种颜色的混乱度 $f(l, r)$ 为：将第 $l \sim r$ 种颜色的所有球排成一排，总共的方案数对 $p$ 取模后的值。小 X 想请你帮忙计算下列式子的值：

$$ \sum_{l=1}^n \sum_{r=l}^n f(l, r) $$

**题目分析**

一眼就看出来f是一个可重集合的排列，而且计算很快，困难的是a的值域太大了，一般的卢卡斯定理还不能通过此题。所以要进行预处理来加快卢卡斯定理的计算速度。

**代码**

```c++
//
// Created by mrx on 2022/10/6.
//

#include <vector>
#include <algorithm>
#include <iostream>
#include <array>

using ll = long long;
int P = 1;

struct digit {
	std::vector<int> d;
	int cnt;

	digit() : d(10), cnt(0) {}

	digit(ll x) : d(10), cnt(0) {
		ll tmp = x;
		while (tmp) {
			d[cnt++] = tmp % P;
			tmp /= P;
		}
	}

	void add(const digit& rhs) {
		for (int i = 0; i < std::max(cnt, rhs.cnt); i++) {
			d[i] += rhs.d[i];
			if (d[i] >= P) {
				d[i] -= P;
				d[i + 1]++;
			}
		}
	}
};


int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);
	int n, p;
	std::cin >> n >> p;
	P = 1;
	while (P < 5000)P *= p;
	P /= p;
	std::vector<std::vector<int>> C(P + 1, std::vector<int>(P + 1));
	C[0][0] = 1;
	for (int i = 1; i <= P; ++i) {
		C[i][0] = C[i][i] = 1;
		for (int j = 1; j < P; ++j) {
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % p;
		}
	}
	auto lucas = [&](const digit& n, const digit& m) {
		int s = 1;
		for (int i = 0; i < m.cnt; ++i) {
			s *= C[n.d[i]][m.d[i]] %= p;
		}
		return s;
	};
	std::vector<digit> a(n + 1);
	for (int i = 0; i < n; ++i) {
		ll x;
		std::cin >> x;
		a[i] = digit(x);
	}

	std::vector<int> r(n + 1);
	a[n].cnt = 1;
	int st = 0;
	for (int i = 0; i <= n; i++) {
		if (a[i].cnt) {
			for (int j = i - 1; j >= st; j--)r[j] = i;
			st = i;
		}
	}

	ll ans = 0;
	for (int i = 0; i < n; ++i) {
		int ptr = i;
		digit tmp = a[ptr];
		int cur = 1;
		while (cur && ptr < n) {
			ans += (r[ptr] - ptr) * cur;
			ptr = r[ptr];
			tmp.add(a[ptr]);
			cur *= lucas(tmp, a[ptr]);
			cur %= p;
		}
	}
	std::cout << ans << '\n';
	return 0;
}
```





## 数论

## 

### 同模关系

#### 1.UVA1069

**题目翻译**

给一个项数小于100的多项式，问其在任意整数下的值模D是否为0 。

**题目分析**

随机取若干个值，如果这些值都令多项式的取值都模D为0，那么这个多项式大概率是在模D意义下为0的。

那么考虑把值(1,2,3,4,….n+1)给带入方程，根据差分数组的性质，$f(n+1)-f(n)$为一个最高次项比f的最高次项小1的多项式，那么对于n阶的多项式计算出来n阶的差分即可变为一个常数，因为取模对于加减法有分配率，那么如果所有的差分值都模D为0，那么整个多项式无论取什么值都模D为0。那么就得出了做法。

**代码**

```c++
//
// Created by mrx on 2022/9/13.
//
#include <bits/stdc++.h>

using ll = long long;

ll power(ll a, ll b, ll mod) {
    ll ans = 1;
    for (; b; b >>= 1, a = a * a % mod) if (b & 1)ans = a * ans % mod;
    return ans;
}

int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    std::string s;
    int n = 0;
    while (std::cin >> s && s != ".") {
        n++;
        std::cout << "Case " << n;

        auto check = [&](std::string &str) -> bool {
            std::vector<int> a, e;
            std::string poly = str.substr(1, str.find('/') - 2);
            int ptr = 0, n = poly.size();
            while (ptr < n) {
                int sig = 1;
                //sign
                if (poly[ptr] == '+') sig = 1, ptr++;
                if (poly[ptr] == '-') sig = -1, ptr++;

                //计算系数
                int digit = 0;
                while (ptr < n && isdigit(poly[ptr])) digit = digit * 10 + poly[ptr++] - '0';
                //常数
                if (ptr == n) {
                    a.push_back(digit);
                    e.push_back(0);
                } else {
                    ptr++;
                    if (digit == 0)digit = 1;
                    digit *= sig;
                    int pw = 0;
                    if (poly[ptr] == '^') {
                        ptr++;
                        //不为1次项k
                        while (ptr < n && isdigit(poly[ptr])) pw = pw * 10 + poly[ptr++] - '0';
                    } else pw = 1;
                    a.push_back(digit);
                    e.push_back(pw);
                }
            }

            int D = stoi(str.substr(str.find('/') + 1));
//            for (int i = 0; i < a.size(); ++i)std::cerr << a[i] << '^' << e[i] << ' ';
            std::cerr << '\n';
            for (int x = 1; x <= e[0] + 1; ++x) {
                ll ans = 0;
                for (int i = 0; i < a.size(); ++i) {
                    ans = (ans + a[i] * power(x, e[i], D) % D) % D;
                }
                if (ans)return false;
            }
            return true;
        };

        if (check(s))std::cout << ": Always an integer\n";
        else std::cout << ": Not always an integer\n";
    }
    return 0;
}
```



### 模方程

#### 1.CF1728ERed-Black Pepper

**题目描述**

Monocarp is going to host a party for his friends. He prepared $ n $ dishes and is about to serve them. First, he has to add some powdered pepper to each of them — otherwise, the dishes will be pretty tasteless.

The $ i $ -th dish has two values $ a_i $ and $ b_i $ — its tastiness with red pepper added or black pepper added, respectively. Monocarp won't add both peppers to any dish, won't add any pepper multiple times, and won't leave any dish without the pepper added.

Before adding the pepper, Monocarp should first purchase the said pepper in some shop. There are $ m $ shops in his local area. The $ j $ -th of them has packages of red pepper sufficient for $ x_j $ servings and packages of black pepper sufficient for $ y_j $ servings.

Monocarp goes to exactly one shop, purchases multiple (possibly, zero) packages of each pepper in such a way that each dish will get the pepper added once, and no pepper is left. More formally, if he purchases $ x $ red pepper packages and $ y $ black pepper packages, then $ x $ and $ y $ should be non-negative and $ x \cdot x_j + y \cdot y_j $ should be equal to $ n $ .

For each shop, determine the maximum total tastiness of the dishes after Monocarp buys pepper packages only in this shop and adds the pepper to the dishes. If it's impossible to purchase the packages in the said way, print -1.

**输入格式**

The first line contains a single integer $ n $ ( $ 1 \le n \le 3 \cdot 10^5 $ ) — the number of dishes.

The $ i $ -th of the next $ n $ lines contains two integers $ a_i $ and $ b_i $ ( $ 1 \le a_i, b_i \le 10^9 $ ) — the tastiness of the $ i $ -th dish with red pepper added or black pepper added, respectively.

The next line contains a single integer $ m $ ( $ 1 \le m \le 3 \cdot 10^5 $ ) — the number of shops.

The $ j $ -th of the next $ m $ lines contains two integers $ x_j $ and $ y_j $ ( $ 1 \le x_j, y_j \le n $ ) — the number of servings the red and the black pepper packages are sufficient for in the $ j $ -th shop, respectively.

**输出格式**

Print $ m $ integers. For each shop, print the maximum total tastiness of the dishes after Monocarp buys pepper packages only in this shop and adds the pepper to the dishes. If it's impossible to purchase the packages so that each dish will get the pepper added once and no pepper is left, print -1.

**题目翻译**

有n道菜， 对于第i道菜加入一份a佐料有$a[i]$的价值，加入一份b有$b[i]$的价值，每道菜只能加入一份佐料。现在有m个商店，每个商店都按瓶售卖佐料，一个瓶中只能有佐料a或者佐料b，一瓶佐料a有x份，一瓶佐料佐料b有y份，购买的佐料必须完全用完。求分别在每个商店购买佐料能获得价值的最大值，如果不能输出-1。

**题目分析**

对每个商店一眼就能列出不定方程组$ax+by=n$,如果有解，有a的通解：$a0+lcm(x,y)*k$,那么可以算出来a的取值在一个范围，而且间隔都是lcm，那么先预处理出来选择i道菜加入佐料a，n-i道菜加入佐料b的最大价值，可以发现，选择i道菜加入佐料a的价值肯定是个单峰函数，而a的取值范围也已知，那么可以通过二分求解，或者直接判断在峰两侧的值和取值范围两端的最大值。

**代码**

```c++
#include <bits/stdc++.h>

using ll = long long;

long long exgcd(long long a, long long b, long long &x, long long &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    ll d = exgcd(b, a % b, x, y);
    ll t = x;
    x = y;
    y = t - a / b * x;
    return d;
}

void sol() {
    int n;
    std::cin >> n;
    std::vector<int> diff(n);
    long long sum = 0;
    for (int i = 0; i < n; ++i) {
        int a, b;
        std::cin >> a >> b;
        diff[i] = a - b;
        sum += b;
    }
    std::sort(diff.begin(), diff.end(), std::greater());
    std::vector<long long> pref(n + 1);
    for (int i = 1; i <= n; ++i)pref[i] = pref[i - 1] + diff[i - 1];
    long long big = std::max_element(pref.begin(), pref.end()) - pref.begin();

    int m;
    std::cin >> m;
    while (m--) {
        int x, y;
        std::cin >> x >> y;

        long long a, b;
        long long g = exgcd(x, y, a, b);
        if (n % g) {
            std::cout << -1 << "\n";
            continue;
        }
        a = a * (n / g) % (y / g);
        if (a < 0) a += y / g;

        if (1LL * x * a > n) {
            std::cout << -1 << "\n";
            continue;
        }

        long long lcm = x * y / g;
        long long lef = x * a;
        long long rig = n - (n - x * a) % lcm;

        long long ans = std::max(pref[lef], pref[rig]);
        if (big >= lef && big <= rig) {
            int l = big - (big - lef) % lcm;
            int r = big + (rig - big) % lcm;
            ans = std::max({ans, pref[l], pref[r]});
        }
        std::cout << ans + sum << "\n";
    }
}

int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    sol();
    return 0;
}
```

#### 2.UVA11754 Code Feat

**题目描述**



![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA11754/32298c9e57055dfda9f1f95dd26a078fe1e03f37.png)

**输入格式**

![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA11754/7116a0bc6bf56a48f9df3e293b782181c6fee335.png)

**输出格式**

![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA11754/264a0de69cadb63313cdf5409291cd6946776de2.png)

**题目分析**

如果对于所有的x只有一个y那么其为一个中国剩余定理板子题，注意到，如果k很小的时候直接进行暴力枚举+中国剩余定理即可，如果k很大的时候，那么如果取一个x取值，分别验证其模意义下其他约束条件的正确性，因为s很小所以可以很快算出来。

**代码**

```c++
//
// Created by mrx on 2022/9/13.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
std::array<T, 3> exgcd(T a, T b) {
    if (b == 0)return {a, 1, 0};
    auto [g, x, y] = exgcd(b, a % b);
    return {g, y, x - a / b * y};
};

void sol(int n, int c) {
    std::vector<ll> m(n), a(n);
    std::vector<ll> solution;
    std::vector<std::vector<int>> g(n);
    ll LCM = 1;

    auto crt = [&](ll n) {
        ll ret = 0;
        for (int i = 0; i < n; ++i) {
            ll w = LCM / m[i];
            auto [g, x, y] = exgcd(w, (ll) m[i]);
            ret = (ret + x * w * a[i]) % LCM;
        }
        return ret;
    };
    std::function<void(int)> dfs = [&](int dep) {
        if (dep == n) {
            solution.push_back(crt(n));
        } else {
            for (int j = 0; j < g[dep].size(); ++j) {
                a[dep] = g[dep][j];
                dfs(dep + 1);
            }
        }
    };
    ll tot = 1, bestc = 0;
    for (int i = 0; i < n; ++i) {
        int k;
        std::cin >> m[i] >> k;
        tot *= k;
        g[i].resize(k);
        for (int j = 0; j < k; ++j) std::cin >> g[i][j];
        std::sort(g[i].begin(), g[i].end());
        if (m[bestc] * g[i].size() <= m[i] * g[bestc].size())bestc = i;
    }
    if (tot > 1e4) {
        std::vector<std::set<ll>> mp(n);
        for (int i = 0; i < n; ++i) {
            if (i != bestc) {
                for (int j = 0; j < g[i].size(); ++j) {
                    mp[i].insert(g[i][j]);
                }
            }
        }

        for (int k = 0;; k++) {
            for (int j = 0; j < g[bestc].size(); ++j) {
                ll cur = k * m[bestc] + g[bestc][j];
                if (cur == 0)continue;
                bool ok = true;
                for (int i = 0; i < n; ++i) {
                    if (i == bestc)continue;
                    if (!mp[i].count(cur % m[i])) {
                        ok = false;
                        break;
                    }
                }
                if (ok) {
                    std::cout << cur << '\n';
                    if (--c == 0)return;
                }
            }
        }
    } else {
        for (int i = 0; i < n; ++i)LCM *= m[i];
        dfs(0);
        std::sort(solution.begin(), solution.end());
        for (int i = 0;; ++i) {
            for (long long X: solution) {
                ll cur = i * LCM + X;
                if (cur > 0) {
                    std::cout << cur << '\n';
                    if (--c == 0)return;
                }
            }
        }
    }
}

int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int n, c;
    while (std::cin >> n >> c && n + c) {
        sol(n, c);
        std::cout << '\n';
    }
}
```



#### Emoogle Grid

**题面翻译**

给一个 $M$ 行 $N$ 列的网格涂上 $K$ 种颜色，其中有 $B$ 个格子不用涂色，其他每个格子涂一种颜色，同一列中的上下两个相邻格子不能涂相同颜色。

给出涂色方案$\mod 100000007$ 的结果$R,N,K,B$ 个格子的位置，求出最小的 $M$ 。

$1\le M,N\le 10^8$

$0\le B\le500$

$2\le K\le10^8$

**输入格式**

输入第一行为数据组数 $T(T\le150)$ 。每组数据第一行为 $4$ 个整数 $N,K,B,R(0\le R\le100000007)$ 。以下 $B$ 行每行为两个整数 $x$ 和 $y(1\le x\le M,1\le y\le N)$ ，即每个不需要涂色的格子的行列编号。这些格子的位置各不相同。

**输出格式**

对于每组数据，输出最小的 $M$ 。输入保证一定有解。

**题目分析**

对于一个网格纸而言，其可以被划分为两块，一块为限制点的区域，另一块为没有任何限制的区域，那么首先算出来有限制的区域的涂色方案，然后没有限制的区域每一行所构成的方案都是$(k-1)^m$，然后就是一个高次同余方程了。

蛋tmd一开始不知道为什么tle了那么多发

**代码**

```c++
//
// Created by mrx on 2022/9/14.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T power(T a, int b) {
	T ans = 1;
	for (; b; a *= a, b >>= 1) {
		if (b & 1)ans *= a;
	}
	return ans;
}

template<typename T>
T inverse(T a, T b) {
	return power(a, b - 2);
}

template<int Mod>
class Modular {
public:
	using Type = int;

	template<typename U>
	static Type norm(U& x) {
		Type v;
		if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
		else v = static_cast<Type>(x % Mod);
		if (v < 0) v += Mod;
		return v;
	}

	constexpr Modular() : value() {}

	int val() const { return value; }

	Modular inv() const {
		return Modular(inverse(value, Mod));
	}

	template<typename U>
	Modular(const U& x) {
		value = norm(x);
	}

	const Type& operator()() const {
		return value;
	}

	template<typename U>
	explicit operator U() const {
		return static_cast<U>(value);
	}

	Modular& operator+=(const Modular& other) {
		if ((value += other.value) >= Mod) value -= Mod;
		return *this;
	}

	Modular& operator-=(
			const Modular& other) {
		if ((value -= other.value) < 0) value += Mod;
		return *this;
	}

	template<typename U>
	Modular& operator+=(const U& other) { return *this += Modular(other); }

	template<typename U>
	Modular& operator-=(const U& other) { return *this -= Modular(other); }

	Modular& operator++() { return *this += 1; }

	Modular& operator--() { return *this -= 1; }

	Modular operator++(int) {
		Modular result(*this);
		*this += 1;
		return result;
	}

	Modular operator--(int) {
		Modular result(*this);
		*this -= 1;
		return result;
	}

	Modular operator-() const { return Modular(-value); }

	template<class ISTREAM_TYPE>
	friend ISTREAM_TYPE& operator>>(ISTREAM_TYPE& is, Modular& rhs) {
		ll v;
		is >> v;
		rhs = Modular(v);
		return is;
	}

	template<class OSTREAM_TYPE>
	friend OSTREAM_TYPE& operator<<(OSTREAM_TYPE& os, const Modular& rhs) {
		return os << rhs.val();
	}

	Modular& operator*=(const Modular& rhs) {
		value = ll(value) * rhs.value % Mod;
		return *this;
	}

	Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, Mod)); }

	friend const Type& abs(const Modular& x) { return x.value; }


	friend bool operator<(const Modular& lhs, const Modular& rhs) { return lhs.value < rhs.value; }


	bool operator==(const Modular& rhs) { return this->value == rhs.value; }

	template<typename U>
	bool operator==(U rhs) const { return *this == Modular(rhs); }

	template<typename U>
	friend bool operator==(U lhs, const Modular& rhs) { return Modular(lhs) == rhs; }

	bool operator!=(const Modular& rhs) { return *this != rhs; }

	template<typename U>
	bool operator!=(U rhs) { return *this != rhs; }

	template<typename U>
	friend bool operator!=(U lhs, const Modular& rhs) { return lhs != rhs; }

	bool operator<(const Modular& rhs) { return this->value < rhs.value; }

	Modular operator+(const Modular& rhs) { return Modular(*this) += rhs; }

	template<typename U>
	Modular operator+(U rhs) { return Modular(*this) += rhs; }

	template<typename U>
	friend Modular operator+(U lhs, const Modular& rhs) { return Modular(lhs) += rhs; }

	Modular operator-(const Modular& rhs) { return Modular(*this) -= rhs; }

	template<typename U>
	Modular operator-(U rhs) { return Modular(*this) -= rhs; }

	template<typename U>
	friend Modular operator-(U lhs, const Modular& rhs) { return Modular(lhs) -= rhs; }

	Modular operator*(const Modular& rhs) { return Modular(*this) *= rhs; }

	template<typename U>
	Modular operator*(U rhs) { return Modular(*this) *= rhs; }

	template<typename U>
	friend Modular operator*(U lhs, const Modular& rhs) { return Modular(lhs) *= rhs; }

	Modular operator/(const Modular& rhs) { return Modular(*this) /= rhs; }

	template<typename U>
	Modular operator/(U rhs) { return Modular(*this) /= rhs; }

	template<typename U>
	friend Modular operator/(U lhs, const Modular& rhs) { return Modular(lhs) /= rhs; }

private:
	Type value;
};

constexpr int mod = 1e8 + 7;
using Z = Modular<mod>;

int bsgs(Z a, Z b) {
	std::map<Z, int> hash;
	int m = std::sqrt(mod) + 0.5;
	Z cur = 1;
	Z inv = 1 / power(a, m);
	hash[cur] = 0;
	for (int i = 1; i < m; ++i) {
		cur *= a;
		if (!hash.count(cur))hash[cur] = i;
	}

	for (int i = 0; i < m; ++i) {
		if (hash.count(b))return i * m + hash[b];
		b *= inv;
	}
	return -1;
}

int main() {
#ifdef LOCAL
	freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);
#endif
	int t;
	std::cin >> t;
	for (int cas = 1; cas <= t; ++cas) {
		std::cout << "Case " << cas << ": ";
		int n, k, b;
		Z r;
		std::cin >> n >> k >> b >> r;
		std::vector<int> x(b), y(b);
		std::set<std::pair<int, int>> ban;
		int m = 1;
		for (int i = 0; i < b; ++i) {
			std::cin >> x[i] >> y[i];
			m = std::max(x[i], m);
			ban.emplace(x[i], y[i]);
		}

		int cnt = n;
		for (int i = 0; i < b; ++i) {
			if (x[i] != m && !ban.count({x[i] + 1, y[i]}))cnt++;
			if (x[i] == 1)cnt--;
		}
		Z p = power(Z(k), cnt);
		p *= power(Z(k - 1), 1ll * n * m - b - cnt);

		if (r == p) {
			std::cout << m << '\n';
		} else {
			cnt = 0;
			for (int i = 0; i < b; ++i) if (x[i] == m)cnt++;
			m++;
			p *= power(Z(k), cnt) * power(Z(k - 1), n - cnt);

			if (p == r) std::cout << m << '\n';
			else {
				std::cout << bsgs(power(Z(k - 1), n), r / p) + m << '\n';
			}
		}
	}
	return 0;
}
```





### 莫反

#### 1.3455 ZAP-Queries

**题目描述**

密码学家正在尝试破解一种叫 BSA 的密码。

他发现，在破解一条消息的同时，他还需要回答这样一种问题：

给出 $a,b,d$，求满足 $1 \leq x \leq a$，$1 \leq y \leq b$，且 元组 $(x,y)$ 的数量。

因为要解决的问题实在太多了，他便过来寻求你的帮助。

**题目分析**

题目即求$\sum\limits^a_{i=1}\sum \limits_{j=1}^bgcd(i,j)=d$

考虑莫比乌斯反演，$[gcd(i,j)=1]=\sum\limits_{ gcd(i,j)\mid d}\mu (d)$那么题目所求值可以变为$\sum\limits_{i=1}^{a/d}\sum\limits_{j=1}^{b/d}\sum\limits_{gcd(i,j)\mid k}\mu (k)$，那么把k提取到前面，得到：$\sum\limits_{k=1}^{\frac{a}{d}}\sum\limits_{i=1}^{\frac{a}{d}}\sum\limits_{j=1}^{\frac {b}{d}}[k\mid gcd(i,j)]*\mu (k)$提取出$\sum\limits_{k=1}^{\frac{a}{d}}\mu (k)\sum\limits_{i=1}^{\frac{a}{d}}\sum\limits_{j=1}^{\frac {b}{d}}[k\mid gcd(i,j)]$,根据gcd的性质，只有当$i,j都是k的倍数的时候[k\mid gcd(i,j)]=1$,那么上式变为$\sum\limits_{k=1}^{\frac{a}{d}}\mu (k)\sum\limits_{i=1}^{\frac{a}{kd}}\sum\limits_{j=1}^{\frac {b}{kd}}1=\sum\limits_{k=1}^{\frac{a}{d}}\mu (k)\frac{a}{kd}\frac {b}{kd}$要球这个式子，就可以进行整除分块。

**代码**

```c++
//
// Created by mrx on 2022/9/8.
//
#include <bits/stdc++.h>

using ll = long long;


int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif

    std::vector<int> prime, vis(1e6 + 10), mu(1e6 + 10);
    mu[1] = 1;
    for (int i = 2; i <= 1e6; ++i) {
        if (!vis[i]) {
            mu[i] = -1;
            prime.push_back(i);
        }
        for (int j = 0; j < prime.size() && i * prime[j] <= 1e6; ++j) {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            } else {
                mu[i * prime[j]] = -mu[i];
            }
        }
    }
    std::vector<int> sum(1e6 + 10, 0);
    for (int i = 1; i <= 1e6; ++i) {
        sum[i] = sum[i - 1] + mu[i];
    }

    int t;
    std::cin >> t;
    while (t--) {
    long long a, b, d;
    std::cin >> a >> b >> d;
    long long ans = 0;
    a /= d, b /= d;
    for (long long l = 1, r; l <= std::min(a, b); l = r + 1) {
        r = std::min(b / (b / l), a / (a / l));
        ans += (a / l) * (b / l) * (sum[r] - sum[l - 1]);

    }
    std::cout << ans << '\n';
    }

    return 0;
}
```

#### 2.2522Problem b

**题目描述**

对于给出的 $n$ 个询问，每次求有多少个数对 $(x,y)$，满足 $a \le x \le b$，$c \le y \le d$，且 $\gcd(x,y) = k$，$\gcd(x,y)$ 函数为 $x$ 和 $y$ 的最大公约数。

**输入格式**

第一行一个整数 $n$，接下来 $n$ 行每行五个整数，分别表示 $a,b,c,d,k$。

**输出格式**

共 $n$ 行，每行一个整数表示满足要求的数对 $(x,y)$ 的个数。

**题目分析**

通过莫反可以求出来$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}gcd(i,j)=k$，那么考虑容斥，其答案为大集合减去含有一段的再加上含两段的。

**代码**

```c++
//
// Created by mrx on 2022/9/8.
//
#include <bits/stdc++.h>

using ll = long long;


int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif

    std::vector<int> prime, vis(1e6 + 10), mu(1e6 + 10);
    mu[1] = 1;
    for (int i = 2; i <= 1e6; ++i) {
        if (!vis[i]) {
            mu[i] = -1;
            prime.push_back(i);
        }
        for (int j = 0; j < prime.size() && i * prime[j] <= 1e6; ++j) {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            } else {
                mu[i * prime[j]] = -mu[i];
            }
        }
    }
    std::vector<int> sum(1e6 + 10, 0);
    for (int i = 1; i <= 1e6; ++i) {
        sum[i] = sum[i - 1] + mu[i];
    }

    int t;
    std::cin >> t;
    while (t--) {
    long long a, b, d;
    std::cin >> a >> b >> d;
    long long ans = 0;
    a /= d, b /= d;
    for (long long l = 1, r; l <= std::min(a, b); l = r + 1) {
        r = std::min(b / (b / l), a / (a / l));
        ans += (a / l) * (b / l) * (sum[r] - sum[l - 1]);

    }
    std::cout << ans << '\n';
    }

    return 0;
}
```

#### 3.1829 [国家集训队]Crash的数字表格 / JZPTAB

**题目描述**

今天的数学课上，Crash 小朋友学习了最小公倍数（Least Common Multiple）。对于两个正整数 $a$ 和 $b$，$\text{lcm}(a,b)$ 表示能同时整除 $a$ 和 $b$ 的最小正整数。例如，$\text{lcm}(6, 8) = 24$。

回到家后，Crash 还在想着课上学的东西，为了研究最小公倍数，他画了一张 $ n \times m$ 的表格。每个格子里写了一个数字，其中第 $i$ 行第 $j$ 列的那个格子里写着数为 $\text{lcm}(i, j)$。

看着这个表格，Crash 想到了很多可以思考的问题。不过他最想解决的问题却是一个十分简单的问题：这个表格中所有数的和是多少。当 $n$ 和 $m$ 很大时，Crash 就束手无策了，因此他找到了聪明的你用程序帮他解决这个问题。由于最终结果可能会很大，Crash 只想知道表格里所有数的和 $\bmod 20101009$ 的值。

输入格式

输入包含一行两个整数，分别表示 $n$ 和 $m$。

输出格式

输出一个正整数，表示表格中所有数的和 $\bmod 20101009$的值。

**题目分析**

原式可以表示为$\sum\limits_{i=1}^n\sum\limits_{j=1}^mlcm(i,j)$，进行推式子，$\sum\limits_{i=1}^n\sum\limits_{j=1}^m \frac{i*j}{gcd(i,j)}$转换为枚举公共因子,为$\sum\limits_{d=1}^{min(n,m)}\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d} d*i*j[gcd(i,j)=1]$ 然后就能进行莫比乌斯反演，变为$\sum\limits_{d=1}^{min(n,m)}d\cdot \sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d} i*j[gcd(i,j)=1]$

#### 4.HDU4746 Mophues

**题目描述**

给$Q(1\le Q\le 5000)$个询问，每个询问给出$n,m,p$求$\sum\limits_{i=1}^N\sum\limits_{j=1}^M[h(gcd(i,j))<=p]$。

**题目分析**

因为把数据范围内的数字分解，p最多为19，那么$18\le p$时直接输出$n*m$，对于另一种情况，令$f(x)=\sum\limits_{i=1}^N\sum\limits_{j=1}^M[gcd(i,j)=x]$,那么答案就是$\sum\limits_{1\le x\le n,h(x)\le p}f(x)$,要求$f(x)$，考虑莫比乌斯反演，定义$g(x)=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^m[x|gcd(i,j)]$，易得所有的$i,j$为x的倍数，那就很容易求出来$g(x)=\frac{n}{x}\frac{m}{x}$，同时有$g(x)=\sum\limits_{x|y}f(y)$,通过倍数形式的莫反得到$f(x)=\sum\limits_{x|y}\mu(y/x)*g(y)=\sum\limits_{x|y}\mu(y/x)(n/y)*(m/y)$.那么答案为
$$
\sum\limits_{1\le x\le n,h(x)\le p}\sum\limits_{x|y}\mu(y/x)(n/y)(m/y)
\\=\sum\limits_{1\le x\le n,h(x)\le p}\ \sum\limits_{1\le k\le n/x}\mu(k)(n/xk)(m/xk)
\\=\sum\limits_{1\le x\le n,h(x)\le p}\  \sum\limits_{1\le  k\le n/x}\mu(k)(n/xk)(m/xk)
\\交换求和顺序
\\=\sum\limits_{1\le T\le n}(n/T)(m/T) \sum\limits_{x|T}\mu(T/x)[h(x)\le p]
$$
然后通过一些妙哇的筛法求出来后面的一坨东西。

**代码**

```c++
//
// Created by mrx on 2022/9/24.
//

#include <vector>
#include <algorithm>
#include <iostream>
#include <array>

using ll = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	std::vector<int> prime, vis(5e5 + 10), mu(5e5 + 10), h(5e5 + 10);
	mu[1] = 1, h[1] = 0;
	for (int i = 2; i <= 5e5; ++i) {
		if (!vis[i])prime.push_back(i), mu[i] = -1, h[i] = 1;
		for (int j = 0; j < prime.size() && i * prime[j] <= 5e5; ++j) {
			vis[i * prime[j]] = 1;
			h[prime[j] * i] = h[i] + 1;
			if (i % prime[j]) {
				mu[i * prime[j]] = -mu[i];
			} else {
				mu[i * prime[j]] = 0;
				break;
			}
		}
	}

	std::vector<std::array<ll, 20>> pref(5e5 + 10);
	for (int i = 1; i <= 5e5; ++i) {
		for (int k = 1; i * k <= 5e5; k++) {
			pref[i * k][h[i]] += mu[k];
		}
	}

	for (int i = 0; i <= 5e5; ++i) for (int j = 1; j < 20; ++j)pref[i][j] += pref[i][j - 1];
	for (int i = 1; i < 5e5; ++i)for (int j = 0; j < 20; ++j)pref[i][j] += pref[i - 1][j];

	int q;
	std::cin >> q;
	while (q--) {
		ll n, m, p;
		std::cin >> n >> m >> p;
		if (p >= 18) {
			std::cout << n * m << '\n';
		} else {
			if (n > m)std::swap(n, m);
			ll ans = 0;
			for (ll l = 1, r; l <= n; l = r + 1) {
				r = std::min(n / (n / l), m / (m / l));
				ans += (pref[r][p] - pref[l - 1][p]) * (n / l) * (m / l);
			}
			std::cout << ans << '\n';

		}
	}
	return 0;
}
```



#### 5.SP7001VLATTICE - Visible Lattice Points

**题面翻译**

给定一个  $N \times N \times N$ 的立方体，点的编号分别从  $(0,0,0)$ 到  $(N,N,N)$。

求有多少个点从点  $(0,0,0)$ 处能看见或不被遮挡。

**题目描述**

Consider a N\*N\*N lattice. One corner is at (0,0,0) and the opposite one is at (N,N,N). How many lattice points are visible from corner at (0,0,0) ? A point X is visible from point Y iff no other lattice point lies on the segment joining X and Y.   

Input :

The first line contains the number of test cases T. The next T lines contain an interger N   

Output :

Output T lines, one corresponding to each test case.   

Sample Input : 
3 
1 
2 
5   

Sample Output : 
7 
19 
175   

Constraints : 
T <= 50 
1 <= N <= 1000000

**题目分析**

类似于二维平面的等价问题，可以得到除了三个坐标平面内的合法点答案为$\sum\limits_{i=1}^{N}\sum\limits_{k=1}^{N}\sum\limits_{k=1}^{N}[gcd(i,j,k)=1]$记$f(d)$为$\sum\limits_{i=1}^{N}\sum\limits_{k=1}^{N}\sum\limits_{k=1}^{N}[gcd(i,j,k)=d]$,$g(n)$为$\sum\limits_{i=1}^{N}\sum\limits_{k=1}^{N}\sum\limits_{k=1}^{N}[n|gcd(i,j,k)]$易得， $g(n)=(N/n)^3$，且$g(n)=\sum\limits_{n|d}f(d)$。通过倍数形式的莫比乌斯反演，可以得到$f(n)=\sum\limits_{n|d}\mu(d/n)*g(d)$,然后就能得到答案$f(1)=\sum\limits_{d=1}^{N}\mu(d)*(N/d)^3$,同理，二维的点数为$3*\sum\limits_{d=1}^{N}\mu(d)*(N/d)^2$，一维的点数为3，那么就算出来了答案，线性求一下$\mu$就行了。

**代码**

```c++
//
// Created by meiru on 2022/9/22.
//

#include <bits/stdc++.h>

using ll = long long;


int main() {
#ifdef LOCAL
	freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);
#endif
	std::vector<int> prime, vis(1e6 + 10), mu(1e6 + 10);
	mu[1] = 1;
	for (int i = 2; i <= 1e6; ++i) {
		if (!vis[i]) {
			mu[i] = -1;
			prime.push_back(i);
		}
		for (int j = 0; j < prime.size() && i * prime[j] <= 1e6; ++j) {
			vis[i * prime[j]] = 1;
			if (i % prime[j] == 0) {
				mu[i * prime[j]] = 0;
				break;
			} else mu[i * prime[j]] = mu[i] * -1;
		}
	}

	int t;
	std::cin >> t;
	while (t--) {
		int n;
		std::cin >> n;
		ll ans = 3;
		for (int d = 1; d <= n; ++d) {
			ll k = n / d;
			ans += mu[d] * (k * k * (k + 3));
		}
		std::cout << ans << '\n';
	}
	return 0;
}
```



#### 5.HDU5528Count a * b

**题目描述**

定义$f(m)$为满足$a*b \nmid m$的二元组$(a,b)$的个数，求$g(n)=\sum\limits_{m\mid n}f(m)$。

**题目分析**

直接求发现非常的不好求，那么我们考虑迂回战术，可以发现$ m\nmid ab$的个数根$m^2-m\mid ab$的个数一样，那么就把问题转化成了$g(n) = \sum\limits_{m|n}m^2-h(m)$，$h(m)$为$m \mid ab$的个数。因为$x^2$是一个典型的鸡性函数，$\sum\limits_{m\mid  n}m^2 = (1+p_1^2+p_1^4+...p_1^{2k_1})*(1+p_2^2+p_2^4+...p_2^{2k_2})...(1+p_t^2+p_t^4+...p_t^{2k_t})$，
考虑h(x)，对于$d = gcd(a,m)$而言，$\frac{m}{d} \mid \frac{a}{d} b = \frac{m}{d} \mid b$,因为a满足上述条件的个数为$\varphi(m/d)$那么$h(m)=\sum\limits_{d\mid m}d\cdot \varphi(m/d)$，要求的答案就是$\sum \limits_{m \mid n}\sum\limits_{d\mid m}d\cdot \varphi(m/d)=\sum\limits_{d \mid n}d\sum\limits_{\frac{m}{d} \mid \frac{n}{d}}\varphi(m/d)$根据莫反其为$\sum\limits_{d \mid n}d \cdot \frac{n}{d}=\sum\limits_{d \mid n} n$ ，这些东西都可以通过质因数分解进行求。

**代码**

```c++
//
// Created by mrx on 2022/9/24.
//
#include <vector>
#include <algorithm>
#include <iostream>
#include <array>

using ll = long long;
using ull = unsigned long long;


int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	std::vector<bool> vis(4e4 + 10);
	std::vector<int> prime;
	for (int i = 2; i <= 4e4; ++i) {
		if (!vis[i])prime.push_back(i);
		for (int j = 0; j < prime.size() && i * prime[j] <= 4e4; ++j) {
			vis[i * prime[j]] = true;
			if (i % prime[j] == 0)break;
		}
	}

	int t;
	std::cin >> t;
	while (t--) {
		int n;
		std::cin >> n;
		ull ans1 = 1, ans2 = n;
		int tmp = n;
		for (int i = 0; i < prime.size() && prime[i] * prime[i] <= tmp; ++i) {
			if (tmp % prime[i] == 0) {
				int cnt = 0;
				while (tmp % prime[i] == 0)tmp /= prime[i], cnt++;
				ull cur = 1, base = prime[i] * prime[i];
				for (int j = 0; j < cnt; ++j) {
					cur += base;
					base *= (ull) prime[i] * (ull) prime[i];
				}
				ans1 *= cur;
				ans2 *= cnt + 1;
			}
		}
		if (tmp != 1)ans1 *= (1ull + (ull) tmp * (ull) tmp), ans2 *= 2ull;
		ull ans = ans1 - ans2;
		std::cout << ans << '\n';
	}
	return 0;
}
```

## 筛法

### 线性筛

#### 1.P5435 基于值域预处理的快速 GCD

**思路**

分块trick，感觉跟光速幂差不多

大题思路是把每个数拆成3个小于根号的数字之乘积，然后通过预处理根号值域的gcd然后通过这三个数字来O(1)求gcd

总复杂度：$O(值域)$预处理，$O(1)$查询

**代码**

```c++
#include <iostream>
#include <numeric>
#include <vector>
#include <array>
#include <algorithm>
#include <cmath>

const int mod = 998244353;

std::vector<int> minp, primes;
std::vector<std::array<int,3>> factors;
void sieve(int n) {
    minp.resize(n + 1);
    factors.resize(n + 1, {1, 1, 1});
    for (int i = 2; i <= n; ++i) {
        if (!minp[i]) {
            minp[i] = i;
            primes.push_back(i);
            factors[i][2] = i;
        }
        for (auto p: primes) {
            if (p * i > n)break;
            minp[i * p] = p;
            factors[i * p] = factors[i];
            factors[i * p][0] *= p;
            std::sort(factors[i * p].begin(), factors[i * p].end());
            if (p == minp[i]) {
                break;
            }
        }
    }
}
void solve() {
    int n;
    std::cin >> n;
    std::vector<int> a(n), b(n);

    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
    }
    
    for (int i = 0; i < n; ++i) {
        std::cin >> b[i];
    }

    int v = std::max(*std::max_element(a.begin(), a.end()), *std::max_element(b.begin(), b.end()));
    int vv = std::sqrt(v) + 1;

    sieve(v);

    std::vector<std::vector<int>> gcd(vv + 1, std::vector<int> (vv + 1));
    for (int i = 1; i <= vv; ++i) gcd[i][0] = gcd[0][i] = i;
    for (int i = 1; i <= vv; ++i) {
        for (int j = 1; j <= i; ++j) {
            gcd[i][j] = gcd[j][i] = gcd[i % j][j];
        }
    }

    auto calc = [&] (int x, int y) {
        int g = 1;
        for (int tmp, i = 0; i < 3; ++i) {
            if (factors[x][i] > vv) {
                if (y % factors[x][i] == 0) {
                    tmp = factors[x][i];
                } else tmp = 1;
            } else {
                tmp = gcd[factors[x][i]][y % factors[x][i]];
            }
            y /= tmp;
            g *= tmp;
        }
        return g;
    };

    for (int i = 0; i < n; ++i) {
        int base = 1, ans = 0;
        for (int j = 0; j < n; ++j) {
            base = 1ll * base * (i + 1) % mod;
            ans = (ans + 1ll * base * calc(a[i], b[j])) % mod;
        }
        std::cout << ans << '\n';
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    solve();
    return 0;
}
```



### 杜教筛

证明由狄利克雷卷积入手

要求$S(x) = \sum\limits_{i = 1}^{x}f(i)$

寻找一个积性函数g

$$\sum\limits_{i= 1}^{n}(f*g)(i) \\ = \sum\limits_{i=1}^{n}\sum\limits_{d|i}f(d)g(\frac{i}{d})\\ = \sum\limits_{d=1}^{n}g(d)s(\lfloor\frac{n}{d}\rfloor)$$

$g(1)s(n)=\sum\limits_{d=1}^{n}g(d)s(\lfloor\frac{n}{d}\rfloor)-\sum\limits_{d=2}^{n}g(d)s(\lfloor\frac{n}{d}\rfloor)\\=\sum\limits_{i= 1}^{n}（f*g)(i)-\sum\limits_{d=2}^{n}g(d)s(\lfloor\frac{n}{d}\rfloor)$

然后如果能构造出来一种积性函数使得$f*g$的前缀和以及g的前缀和很好算，那么整个式子就可以使用整除分块和递归进行求解。



```c++
i64 GetSum(int n) {
    i64 ans = f_g_sum(n);
    for(i64 l = 2, r; l <= n; l = r + 1) {
        r = (n / (n / l)); 
        ans -= (g_sum(r) - g_sum(l - 1)) * GetSum(n / l);
    } 
    return ans; 
}
```

这样的复杂度为$T(n)= \sum\limits_{i=1}^{\sqrt n}O(\sqrt i)+O(\sqrt{\frac{n}{i}}) = n^{0.75}$

#### 1. HDU7325 GCD Magic

求$\sum\limits_{i = 1}^n\sum\limits_{j = 1}^n[gcd(2^i-1, 2^j -1)] ^K$

期中$1\le n \le 10^9$,$0\le K \le 10$

使用辗转相减可以发现式子变成$\sum\limits_{i = 1}^n\sum\limits_{j = 1}^n[2^{gcd(i,j) }-1] ^K$，下面进行推式子
$$
\sum\limits_{t = 1}^{n}\sum\limits_{i = 1} ^ {n}\sum\limits_{j = 1} ^ {n}[2^{t}-1]^K[gcd(i, j) = t]
\\
 \sum\limits_{t = 1}^{n}\sum\limits_{i = 1} ^ {\lfloor\frac{n}{t}\rfloor}\sum\limits_{j = 1} ^ {\lfloor\frac{n}{t}\rfloor}[2^{t}-1]^K[gcd(i, j) = 1]
 \\
 
 \sum\limits_{t = 1}^{n}[2^{t}-1]^K\sum\limits_{i = 1} ^ {\lfloor\frac{n}{t}\rfloor}\sum\limits_{j = 1} ^ {\lfloor\frac{n}{t}\rfloor}\sum\limits_{g|gcd(i,j)}\mu(g)
$$


令 $f(x)= (2^x - 1) ^ K$, $T = t\cdot g$有：
$$
\sum\limits_{T = 1}^{n}{\lfloor\frac{n}{t}\rfloor}^2\sum\limits_{t|T}f(t)\mu(\frac{T}{d})
$$
然后考虑杜教筛，计 $g =f * \mu$，要快速求出前缀和，在$g$右边卷上一个1可以把这个很恶心的$\mu$变成$\varepsilon$，得$g*1=f$。



根据杜教筛的公式：
$$
\sum\limits_{i=1}^{n}(f*g)(i)
\\=\sum\limits_{i=1}^{n}\sum\limits_{d|i}f(d)g(\frac{i}{d})
\\=\sum\limits_{d=1}^{n}g(d)F(\lfloor\frac{n}{d}\rfloor)

\\
g(1)F(n)=\sum\limits_{d=1}^{n}g(d)F(\lfloor\frac{n}{d}\rfloor)-\sum\limits_{d=2}^{n}g(d)F(\lfloor\frac{n}{d}\rfloor)
\\=\sum\limits_{i=1}^{n}(f*g)(i)-\sum\limits_{d=2}^{n}g(d)F(\lfloor\frac{n}{d}\rfloor)
$$
套进杜教筛式子则有：
$$
1\cdot S(n)=\sum\limits_{i=1}^{n}(f*\mu*1)(i)-\sum\limits_{d=2}^{n}d\cdot S(\lfloor\frac{n}{d}\rfloor)
\\
S(n)=\sum\limits_{i=1}^{n}f(i)-\sum\limits_{d=2}^{n}d\cdot S(\lfloor\frac{n}{d}\rfloor)
$$
然后只要快速求出$\sum\limits_{i=1}^nf(i)$,观察这个式子，发现其K很小，那么暴力二项式展开后发现其为k个等比数列求和，然后就可以$O(Kn^{\frac{2}{3}})$求出原公式后半部分的前缀和，然后前面使用整除分块就行，因为n的上界一样，所以每个前缀和最多算一次，记忆化后保证求前缀和的复杂度为$O(Kn^{\frac{2}{3}})$。



## 概率

### 1.P5104发红包

题目大意：有w元的红包，n个人来抢，第k个人抢到钱的概率是多少。

题目分析：期望的线性性

代码：

```c++
//
// Created by mrx on 2022/6/26.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

const int mod = 1e9 + 7;

ll quickPow(ll base, ll fact) {
    ll ans = 1;
    while (fact) {
        if (fact & 1) ans = ans * base % mod;
        base = base * base % mod;
        fact >>= 1;
    }
    return ans;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    ll w, n, k;
    cin >> w >> n >> k;
    cout << w * quickPow(quickPow(2, k), mod - 2) % mod << endl;
    return 0;
}
```

### 2.P1850换教室

题目大意：有n节课，牛牛被安排在ci上课，他可以申请换教室，每一节课都可以申请，分别有bi的几率申请通过，教室形成了一个联通图，牛牛最多申请m次换课，从一个教室到另一个教室要消耗vij点体力，牛牛想知道他的期望消耗体力。

题目分析：容易想到$dp[i][j]$表示到第i节课前申请换了j节课。但是如果只有这两个维度，发现状态转移还是非常困难，所以多加一维k，表示在i这个地方牛牛有没有选择换课，然后就能轻松得到状态转移方程，其为从i-1转移到i消耗的体力乘以概率求和。

代码：

```c++
//
// Created by mrx on 2022/6/26.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int n, m, v, e;
    cin >> n >> m >> v >> e;
    vector<int> pri(n), swp(n);
    vector<double> prob(n);
    vector<vector<int>> cost(v, vector<int>(v, 0x3f3f3f3f));
    for (int i = 0; i < n; ++i) {
        cin >> pri[i];
        pri[i]--;
    }
    for (int i = 0; i < n; ++i) {
        cin >> swp[i];
        swp[i]--;
    }
    for (int i = 0; i < n; ++i) {
        cin >> prob[i];
    }
    for (int i = 0; i < e; ++i) {
        int x, y, w;
        cin >> x >> y >> w;
        x--, y--;
        cost[x][y] = cost[y][x] = min(cost[x][y], w);
    }
    for (int k = 0; k < v; ++k) {
        for (int i = 0; i < v; ++i) {
            for (int j = 0; j < v; ++j) {
                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);
            }
        }
    }
    vector<vector<array<double, 2>>> dp(n, vector<array<double, 2>>(m + 2));//dp[i][j][0/1]表示到第i个换了j个点0表示已经换成功点，1表示没有换成功点
    for (int i = 0; i < v; i++)cost[i][i] = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= m; j++)dp[i][j][0] = dp[i][j][1] = 1e18;
    }
    dp[0][0][0] = dp[0][1][1] = 0;
    for (int i = 1; i < n; ++i) {
        dp[i][0][0] = dp[i - 1][0][0] + cost[pri[i - 1]][pri[i]];
        for (int j = 1; j <= min(i + 1, m); ++j) {
            dp[i][j][0] = min({dp[i][j][0], dp[i - 1][j][0] + cost[pri[i - 1]][pri[i]],
                               dp[i - 1][j][1] + prob[i - 1] * cost[swp[i - 1]][pri[i]] + (1 - prob[i - 1]) * cost[pri[i - 1]][pri[i]]});
            dp[i][j][1] = min({dp[i][j][1],
                               dp[i - 1][j - 1][0] + prob[i] * cost[pri[i - 1]][swp[i]] + (1 - prob[i]) * cost[pri[i - 1]][pri[i]],
                               dp[i - 1][j - 1][1]
                               + prob[i - 1] * prob[i] * cost[swp[i - 1]][swp[i]]
                               + prob[i - 1] * (1 - prob[i]) * cost[swp[i - 1]][pri[i]]
                               + (1 - prob[i - 1]) * prob[i] * cost[pri[i - 1]][swp[i]]
                               + (1 - prob[i - 1]) * (1 - prob[i]) * cost[pri[i - 1]][pri[i]]});
        }
    }
    double ans = 1e18;
    for (int i = 0; i <= m; ++i) {
        ans = min({ans, dp[n - 1][i][0], dp[n - 1][i][1]});
    }
    cout << fixed << setprecision(2) << ans << endl;
    return 0;
}
```





### 3.P3830随机树

题目大意：给一个只有根节点的二叉树，随机选择一个叶子结点，把它变成一个根节点，然后给使其底下多2个叶子结点。

题目分析：设计$dp[i]$表示有i个叶子结点的平均深度，进行设计状态转移方程，它有两个query，一个是查询树的深度期望，另一个是查询叶子结点的深度期望。只考虑叶子结点的深度期望的时候，有$f[n]=f[n-1]+\frac {2}{n}$，对于第二种查询，就比较麻烦了假设$dp[i][j]$为i个叶子结点，树高度大于等于j的概率，那么对于任意一颗树，它的深度大于j的概率$P[j]=dp[k][j-1]+dp[i-k][j-1]+dp[k][j-1]*dp[i-k][j-1]$，那么假设左子树的结点树为k，操作i-1次，$P=\sum_{k=1}^{i-1}P_k*P'_k$,$P'_k$为左子树有k个结点的概率。考虑操作，每一次操作要么放左边，要么放右边，对于左子树，每一次在左子树的扩展操作都有i中可能性，那么，形成左子树有k个节点的树的个数为$(k-1)!*(i-k-1)!$。而操作顺序有$C_{i-2}^{k-1}$种，乘起来就是所有操作可能性中生成左子树有k个节点的个数。即为$(i-2)!$那么$P'_k=\frac{1}{i-1}$从而得到状态转移方程。$dp[i][j]=\sum_{k=1}^{i-1}\frac{dp[k][j-1]+dp[i-k][j-1]-dp[k][j-1]*dp[i-k][j-1]}{i-1}$。进行一下dp就行

代码：

```c++
//
// Created by mrx on 2022/6/27.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int q, n;
    cin >> q >> n;
    if (q == 1) {
        double ans = 0;
        for (int i = 2; i <= n; ++i)ans += 2.0 / i;
        cout << fixed << setprecision(6) << ans << endl;
    } else {

        vector<vector<double  >> dp(n + 1, vector<double>(n + 1, 0));
        for (int i = 1; i <= n; ++i)dp[i][0] = 1;
        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j < i; ++j) {
                for (int k = 1; k < i; ++k) {
                    dp[i][j] += (dp[k][j - 1] + dp[i - k][j - 1] - dp[k][j - 1] * dp[i - k][j - 1]) / (i - 1);
                }
            }
        }
        double ans = 0;
        for (int i = 1; i <= n; ++i)ans += dp[n][i];
        cout << fixed << setprecision(6) << ans << endl;
    }
    return 0;
}
```



### 4.P3193 GT考试

题目大意：有一个n位数，不能出现字串m，求这个n位数字有多少个

题目分析：一眼丁真，感觉像个dp，设计状态转移方程$dp[i][j]$，i，j为两个字符串匹配位。但是复杂度要寄，所以考虑优化，根据字符串匹配，使用kmp算法。然后可以通过kmp的nxt数组得到$dp[i]和dp[i+1]$的状态转移矩阵。然后进行矩阵快速蜜。

代码：

```c++
//
// Created by mrx on 2022/6/27.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;
int mod;

vector<int> nxt(string &s) {
    int n = s.length();
    vector<int> nxt(n + 1, 0);
    for (int i = 2, j = 0; i <= n && j <= n; ++i) {
        while (j && s[j + 1] != s[i])j = nxt[j];
        if (s[j + 1] == s[i])j++;
        nxt[i] = j;
    }
    return nxt;
}

struct matrix {
    vector<vector<int>> mat;
    int n, m;

    matrix(int n, int m) : n(n), m(m), mat(n, vector<int>(m, 0)) {}

    void E() {
        m = n;
        mat.clear();
        mat.resize(n);
        for (auto &x: mat)x.resize(m, 0);
        for (int i = 0; i < n; ++i)mat[i][i] = 1;
    }

    friend matrix operator*(const matrix &lhs, const matrix &rhs) {
        if (lhs.m != rhs.n) {
            throw (runtime_error("matrix multiply not matching"));
        }
        matrix ans(lhs.n, rhs.m);
        for (int i = 0; i < lhs.n; ++i) {
            for (int j = 0; j < rhs.m; ++j) {
                for (int k = 0; k < lhs.m; ++k) {
                    ans.mat[i][j] = (ans.mat[i][j] + lhs.mat[i][k] * rhs.mat[k][j] % mod) % mod;
                }
            }
        }
        return ans;
    }

    friend matrix operator^(matrix a, long long b) {
        if (a.n != a.m) {
            throw (runtime_error("matrix pow not matching"));
        }
        matrix ans(a.n, a.n);
        ans.E();
        while (b) {
            if (b & 1) {
                ans = ans * a;
            }
            a = a * a;
            b >>= 1;
        }
        return ans;
    }
};

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int n, m;
    string s;
    cin >> n >> m >> mod;
    cin >> s;
    s = '*' + s;
    vector<int> kmp = nxt(s);
    matrix xs(m, m);
    for (int i = 0; i < m; ++i) {
        for (int j = '0'; j <= '9'; ++j) {
            int temp = i;
            while (s[temp + 1] != j && temp > 0) temp = kmp[temp];
            if (s[temp + 1] == j) temp++;
            if (temp < m) xs.mat[i][temp]++;
        }
    }
    matrix dp(1, m);
    dp.mat[0][0] = 1;
    long long ans = 0;
    matrix ansm = dp * (xs ^ n);
    for (int i = 0; i < m; ++i) {
        ans = (ansm.mat[0][i] + ans) % mod;
    }
    cout << ans << endl;
    return 0;
}
```



### 5.P4564假面

题目大意：假面有两个技能，第一个技能对每个敌人有p的概率造成一点伤害，第二个技能可以从选定的活着目标里面等概率得锁定一人，求每次第二个技能释放之后每个敌人被击中的概率，以及技能全部释放完成之后每个敌人血量的期望。

题目分析：第二个技能不会影响血量，第二个技能取决于场上存活的敌人，那么对于问题一，可以很容易得想到直接递推出结果。对于第二个技能，就比较复杂了，容易推到出柿子，然后发现下标并没有非常的限制，那么就可以进行移项。移项完成之后，我们就可以算出来一个中间值$G[i]$，通过这个中间值可以在$o(n^2)$的复杂度内算出来每一个点存活的概率值，然后通过期望的定义算出来期望就行了。

代码：

```c++
//
// Created by mrx on 2022/6/27.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;
const long long mod = 998244353;

template<typename T>
T quickPow(T base, T fact) {
    T ans = 1;
    while (fact) {
        if (fact & 1) ans = ans * base % mod;
        base = base * base % mod;
        fact >>= 1;
    }
    return ans;
}

template<typename T>
T normal(T a) {
    return a < 0 ? a + mod : a >= mod ? a - mod : a;
}

template<typename T>
struct ModInt {
    T base;

    ModInt() : base(0) {}

    ModInt(T a) : base(normal(a % mod)) {}

    ModInt(int a) : base(normal(a % mod)) {}

    ModInt(const ModInt &rhs) {
        base = rhs.base;
    }

    ModInt inv() const {
        return quickPow(base, mod - 2);
    }

    ModInt &operator=(const ModInt &rhs) {
        base = rhs.base;
        return *this;
    }

    ModInt operator-() const { return ModInt(normal(mod - base)); }

    ModInt &operator*=(const ModInt &rhs) {
        base = 1ll * base * rhs.base % mod;
        return *this;
    }

    ModInt &operator+=(const ModInt &rhs) {
        base = normal(base + rhs.base);
        return *this;
    }

    ModInt &operator-=(const ModInt &rhs) {
        base = normal(base - rhs.base);
        return *this;
    }

    ModInt &operator/=(const ModInt &rhs) { return *this *= rhs.inv(); }

    ModInt &operator++() { return *this += 1; }

    ModInt &operator--() { return *this -= 1; }

    ModInt operator++(int) {
        ModInt res = *this;
        ++*this;
        return res;
    }

    ModInt operator--(int) {
        ModInt res = *this;
        --*this;
        return res;
    }

    friend ModInt operator*(const ModInt &lhs, const ModInt &rhs) {
        ModInt res = lhs;
        res *= rhs;
        return res;
    }

    friend ModInt operator+(const ModInt &lhs, const ModInt &rhs) {
        ModInt res = lhs;
        res += rhs;
        return res;
    }

    friend ModInt operator-(const ModInt &lhs, const ModInt &rhs) {
        ModInt res = lhs;
        res -= rhs;
        return res;
    }

    friend ModInt operator/(const ModInt &lhs, const ModInt &rhs) {
        ModInt res = lhs;
        res /= rhs;
        return res;
    }

    template<class stream>
    friend stream &operator>>(stream &is, ModInt &rhs) {
        T x;
        is >> x;
        rhs = ModInt(x);
        return is;
    }

    operator T() {
        return base;
    }

    template<class stream>
    friend stream &operator<<(stream &os, const ModInt &rhs) {
        return os << rhs.base;
    }

    friend bool operator==(const ModInt &lhs, const ModInt &rhs) {
        return lhs.base == rhs.base;
    }

    friend bool operator!=(const ModInt &lhs, const ModInt &rhs) {
        return lhs.base != rhs.base;
    }
};

using Mint = ModInt<long long>;

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    int q;
    cin >> q;
    vector<vector<Mint>> prob(n + 1, vector<Mint>(211, 0));
    vector<Mint> g(211), inv(211), tmp(211);
    for (int i = 1; i <= 203; ++i)inv[i] = Mint(i).inv();
    for (int i = 1; i <= n; ++i)prob[i][a[i]] = 1;
    while (q--) {
        int opt;
        cin >> opt;
        if (opt == 0) {
            Mint id, u, v;
            cin >> id >> u >> v;
            Mint p = u * v.inv();
            Mint mp = Mint(1) - p;
            prob[id][0] = prob[id][0] + prob[id][1] * p;
            for (int i = 1; i <= a[id]; ++i) {
                prob[id][i] = prob[id][i + 1] * p + prob[id][i] * mp;
            }
        } else {
            int cnt, tot = 0;
            cin >> cnt;
            vector<int> atkid(cnt + 2);
            for (int i = 1; i <= cnt; ++i) {
                cin >> atkid[i];
            }
            g[0] = 1;
            for (int i = 1; i <= cnt; ++i) {
                Mint id = atkid[i], p = Mint(1) - prob[id][0];
                Mint invp = prob[id][0];
                if (invp == Mint(0)) {
                    tot++;
                    continue;
                }
                for (int j = cnt; j >= 1; --j) {
                    g[j] = g[j - 1] * p + g[j] * invp;
                }
                g[0] = g[0] * invp;
            }
            for (int i = 1; i <= cnt; ++i) {
                Mint id = atkid[i], p = Mint(1) - prob[id][0];
                Mint invp = prob[id][0], invp_inv = invp.inv();
                Mint ans = 0;
                if (invp == Mint(0)) {
                    for (int j = 0; j <= cnt; ++j) {
                        ans = ans + inv[j + tot] * g[j];
                    }
                    cout << ans << ' ';
                } else {
                    for (int j = 0; j <= cnt; ++j) {
                        tmp[j] = g[j];
                    }
                    tmp[0] = tmp[0] * invp_inv;
                    for (int j = 1; j <= cnt; ++j) {
                        tmp[j] = (tmp[j] - tmp[j - 1] * p) * invp_inv;
                    }
                    for (int j = 0; j <= cnt; ++j)ans = ans + inv[j + tot + 1] * tmp[j] * p;
                    cout << ans << ' ';
                }
            }
            cout << endl;
            for (int j = 0; j <= cnt; ++j)g[j] = 0;
        }
    }
    for (int i = 1; i <= n; ++i) {
        Mint ans = 0;
        for (int j = 0; j <= a[i]; ++j)ans += Mint(j) * prob[i][j];
        cout << ans << ' ';
    }
    cout << endl;
    return 0;
}
```



### 6.3426 SZA-Template

题目大意：制作一个印章，使得印章重复印若干次可以变成给定的字符串，求印章的字符串长度最小值。

题目分析：容易知道，印章肯定是一个border，对于这个border如果其的长度比这个i到$nxt[i]$到长度一定要大，然后进行dp，然后要维护每一个border能覆盖到的最远点，这个可以通过一个桶来维护。

代码：

```c++
//
// Created by mrx on 2022/6/27.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

vector<int> nxt(string &s) {
    int n = s.length() - 1;
    vector<int> nxt(n + 1);
    for (int i = 2, j = 0; i <= n; ++i) {
        while (j && s[i] != s[j + 1])j = nxt[j];
        if (s[i] == s[j + 1])j++;
        nxt[i] = j;
    }
    return nxt;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    string s;
    cin >> s;
    int n = s.length();
    s = '*' + s;
    vector<int> kmp = nxt(s), pre(n + 1), len(n + 1);
    for (int i = 1; i <= n; ++i) {
        len[i] = i;
        if (pre[len[kmp[i]]] >= i - kmp[i]) len[i] = len[kmp[i]];
        pre[len[i]] = i;
    }
    cout << len[n] << endl;
    return 0;
}
```



### 7.P3232游走

题目大意：给定一个无向图，你需要从1号点走到n号点，在每个点等概率地选择一条边走，每一条边有一个编号，从1到m，自己确定哪条边是什么编号，求走过边的编号和的期望。

题目分析：因为是求编号和的期望，但是编号是你自己编的，那么算出来每条边期望走过的次数然后排序，最后就可以求出来题目要求的期望了。而走过边的次数期望又和走过点的期望有关系，对于$e_{u,v}$这个边，这条边走过的期望就是$\frac{E(u)}{deg(u)}+\frac{E(v)}{deg(v)}$,那问题转化成了求每个点的期望经过次数，对于$E(U)$来讲，$E(u)=\sum \frac{E(v)}{deg(v)}(u,v邻接)$特别的，对于$E（1）=1+\sum \frac{E(v)}{deg(v)}(u,v邻接)$，根据E（n）=0可以进行高斯消元，从而解出方程组，从而得出每个点的期望经过次数，然后就能得到每个边的期望经过次数。最后按照边的期望经过次数排序，然后就能出答案了。

代码：

```c++
//
// Created by mrx on 2022/6/27.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;
double eps = 1e-8;

struct matrix {
    vector<vector<double>> mat;
    int n, m;

    matrix(int n, int m) : n(n), m(m), mat(n, vector<double>(m + 1, 0.0)) {}

    void gauss() {
        for (int col = 0, row = 0; col <= m && row < n; ++col) {
            int nxt = row;
            for (; nxt < n - 1; nxt++) if (abs(mat[nxt][col]) > eps)break;
            if (abs(mat[nxt][col]) > eps) {
                swap(mat[row], mat[nxt]);
                double div = mat[row][col];
                for (int i = 0; i <= m; ++i) mat[row][i] /= div;
                for (int i = 0; i < n; ++i) {
                    if (i != row && abs(mat[row][col]) > eps) {
                        div = mat[i][col];
                        for (int j = 0; j <= m; ++j) {
                            mat[i][j] -= div * mat[row][j];
                        }
                    }
                }
            }
            row++;
        }
    }

    void show() {
        for (auto &x: mat) {
            for (auto y: x) { cout << y << ' '; }
            cout << endl;
        }
    }
};

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int n, m;
    cin >> n >> m;
    vector<int> E[n + 1];
    vector<pair<double, pair<int, int>>> e;
    vector<int> d(n + 1, 0);
    for (int i = 1; i <= m; ++i) {
        int x, y;
        cin >> x >> y;
        E[x].push_back(y), E[y].push_back(x);
        e.emplace_back(0, make_pair(x, y));
        d[x]++, d[y]++;
    }
    matrix M(n, n);
    M.mat[0][n] = 1;
    M.mat[n - 1][n - 1] = 1;
    for (int u = 1; u < n; ++u) {
        M.mat[u - 1][u - 1] = 1;
        for (auto v: E[u]) {
            if (v != n)
                M.mat[u - 1][v - 1] -= 1.0 / d[v];
        }
    }
    M.gauss();
    for (auto &x: e) {
        x.first += M.mat[x.second.first - 1][n] / d[x.second.first] + M.mat[x.second.second - 1][n] / d[x.second.second];
    }
    std::sort(e.begin(), e.end());
    std::reverse(e.begin(), e.end());
    double ans = 0;
    for (int i = 1; i <= m; ++i) {
        ans += i * e[i - 1].first;
    }
    cout << fixed << setprecision(3) << ans << endl;
    return 0;
}
```

### 8.Potion(Hubei CPC)

题目大意：给一个容积为a+b有刻度为a的量筒，给两种液体，这两种液体可以互融，求制取给定的液体配比需要进行几次加液体的操作。

题目分析：对于原有浓度为$f[i]$的液体来讲，如果加入b毫升水，那么浓度变成$\frac{a*f[i]+0*(a+b)}{a+b}$,如果加入的是溶质，那么浓度变成$\frac {a*f[i]+b*(a+b)}{a+b}$的浓度，考虑$f[0]$，$f[0]$必定为1或者0。假设灌水了n+1次，那第一次灌入的液体是a+b，其余的都是灌入b的液体，计每一次灌的液体为g[i]，灌入溶质时$g[i]=1$,灌入水时$g[i]=0$，考虑每一次灌液体对于答案的贡献，那么$f[0]$对于答案的贡献就是$g[0]*\frac{a^n}{(a+b)^n}$。$f[i](i>0)$	对答案的贡献为：$\frac{g[i]*b*(a+b)^{i-1}*a^{n-i}}{(a+b)^{n}}$，所以总的贡献是$\sum\frac{a^n*g[0]+b*g[i]*(a+b)^{i-1}*a^{n-i}}{(a+b)^{n}}$。那么，如果有姐，$x+y$为a+b的蜜次，x可以被$a^n*g[0]+g[i]*(a+b)^{i-1}*a^{n-i}$表示。那么分类讨论有无第0项。然后用循环或者递归判断有没有解即可。

代码：

```c++
//
// Created by mrx on 2022/7/8.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

long long gcd(long long a, long long b) {
    return a % b == 0 ? b : gcd(b, a % b);
}


ll quickPow(ll base, ll fact) {
    ll ans = 1;
    while (fact) {
        if (fact & 1) ans = ans * base;
        base = base * base;
        fact >>= 1;
    }
    return ans;
}

void sol() {
    long long a, b, x, y;
    cin >> x >> y >> a >> b;
    long long g = gcd(x, y);
    x /= g, y /= g;
    g = gcd(a, b);
    a /= g, b /= g;
    long long c = a + b;
    long long n = 0;
    long long tmp = x + y;
    while (tmp % c == 0) {
        tmp /= c;
        n++;
    }
    function<bool(long long, long long, long long, long long)> check = [&](long long aa, long long bb, long long fz, long long cnt) -> bool {
        if (cnt == 0) {
            if (fz == 0)return 1;
            else return 0;
        }
        if (fz % c == 0)return check(aa, bb, fz / c, cnt - 1);
        else {
            if ((fz - quickPow(a, cnt - 1)) % c == 0 && (fz - quickPow(a, cnt - 1) >= 0))
                return check(aa, bb, (fz - quickPow(a, cnt - 1)) / c, cnt - 1);
            else return 0;
        }
    };
    if (tmp != 1) {
        cout << -1 << endl;
    } else {
        if (x - quickPow(a, n) >= 0 && (x - quickPow(a, n)) % b == 0 && check(a, b, (x - quickPow(a, n)) / b, n)) {
            cout << n + 1 << endl;
        } else if (x % b == 0 && check(a, b, x / b, n)) {
            cout << n + 1 << endl;
        } else cout << -1 << endl;
    }
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int t;
    cin >> t;
    while (t--)sol();
    return 0;
}
```

### 9.P3239亚瑟王

题目大意：有n张手牌，每张牌有$p[i]$的概率释放攻击力为$d[i]$，释放后该卡牌不能，如果脸黑，一张手牌都没用出去，那么这一轮依旧结束，求进行r轮之后理论造成伤害的期望。

题目分析：直接分析期望的计算很麻烦，由于每一张卡牌只能释放一次，那么通过计算每一张卡牌在整个游戏中释放出去的概率然后乘以伤害求和即可求出来整个游戏中造成的伤害。对于每张卡牌释放$dp[i][j]$表示第i张牌之前选了j张牌，然后dp一下就行了

```C++
//
// Created by mrx on 2022/7/9.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

template<class T>
T quickPow(T base, ll fact) {
    T ans = 1;
    while (fact) {
        if (fact & 1) ans = ans * base;
        base = base * base;
        fact >>= 1;
    }
    return ans;
}

void sol() {
    int n, r;
    cin >> n >> r;
    vector<double> prob(n + 1, 0);
    vector<vector<double>> dp(n + 1, vector<double>(r + 1, 0));
    vector<int> dmg(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> prob[i] >> dmg[i];
    }
    dp[1][1] = 1 - quickPow(1 - prob[1], r), dp[1][0] = quickPow(1 - prob[1], r);
    for (int i = 2; i <= n; ++i) {
        for (int j = 0; j <= min(i, r); ++j) {
            dp[i][j] += dp[i - 1][j] * quickPow(1 - prob[i], r - j);//如果i不选，那么有r-j轮都没选到他
            dp[i][j] += dp[i - 1][j - 1] * (1 - quickPow((1 - prob[i]), r - j + 1));
        }
    }
    double ans = dp[1][1] * dmg[1];
    for (int i = 2; i <= n; ++i) {
        for (int j = 0; j <= min(i - 1, r); ++j) {
            ans += dp[i - 1][j] * (1 - quickPow(1 - prob[i], r - j)) * dmg[i];
        }
    }
    cout << fixed << setprecision(10) << ans << endl;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int t;
    cin >> t;
    while (t--)sol();
    return 0;
}
```

### 10.P5523珍珠

题目大意：定义与非nand，给定四种操作，从左到右查询，从右到左查询，在左边加入点，在右边加入点。询问多少次查询出1，多少次操作编号为奇数而且查询结果为0，多少次查询编号为偶数查询结果为1，多少次操作编号为1024的倍数查询结果为0。

题目分析：写出nand的真值表，发现其没有结合律，那么数据结构很难进行维护。通过观察可以发现，表达式左右两端只要有0那么nand的输出肯定是1，那么这样就可以把查询化简，比如说1 nand 1 nand 0 nand 1 nand 1 nand 0 nand 1 nand 1 nand 0 nand 1 nand 1就可以把最后一位0点的前面的数字全部忽略，化简为1 nand 1 nand 1。最终的查询结果除了只有一个0的时候要特判断，不然就是一堆1进行nand，一堆1进行nand也有规律，1的个数为奇数的时候其为1，个数为偶数的时候其为0。这样就可以确定这道题的做法了，只要维护每一个点的左右两端最近0的位置即可。在插入的时候如果插入左边那就把左边和左边最近的0之间的数字进行修改，右边同理。这样每一个0最多被遍历到2遍，那么均摊复杂度就是$o(n)$的。

然而读题读歪了过一会在写。

### 11.P3750分手时祝愿

题目大意：给定n个开关，每一个开关按下的时候能让其所有的约数都改变状态当前状态只要小于等于k次的话他回按照最优方案按开关，否则随机按开关，求期望按几次开关。

题目分析：易得每个开关按两次等于没有按，那么每一个开关顶多按一次，设计状态，$dp[i]$为有i个开关不一样的时候把状态按到dp[i-1]要的期望操作次数。那么容易得到$dp[i]=\frac{(n-i)(1+dp[i+1]+dp[i])}{n}+\frac{i}{n}$，然后累加就好了捏。

代码：

```c++

//
// Created by mrx on 2022/7/10.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;
const long long mod = 100003;

ll quickPow(ll base, ll fact) {
    ll ans = 1;
    while (fact) {
        if (fact & 1) ans = ans * base % mod;
        base = base * base % mod;
        fact >>= 1;
    }
    return ans;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    long long n, k;
    cin >> n >> k;
    long long cnt = 0;
    vector<long long> a(n + 1);
    for (long long i = 1; i <= n; ++i)cin >> a[i];
    for (long long i = n; i; --i) {
        if (a[i]) {
            cnt++;
            for (long long j = 1; j * j <= i; ++j) {
                if (i % j == 0) {
                    if (j * j != i) {
                        a[j] ^= 1, a[i / j] ^= 1;
                    } else {
                        a[j] ^= 1;
                    }
                }
            }
        }
    }
    vector<long long> dp(n + 2, 0);
    dp[n + 1] = 0;
    for (long long i = n; i; --i) {
        dp[i] = (n + (n - i) * (dp[i + 1]) % mod) % mod * quickPow(i, mod - 2) % mod;
    }
    long long ans = 0;
    if (k >= cnt) {
        ans = cnt;
    } else {
        for (int i = cnt; i > k; --i)ans = (ans + dp[i]) % mod;
        ans = (ans + k) % mod;
    }
    for (int i = 1; i <= n; ++i)ans = ans * i % mod;
    cout << ans << endl;
    return 0;
}
```

### 12.P5249加特林轮盘赌

大意：每个人每轮有p的概率挂掉，求n个人第k个人存活到最后的概率。

分析：假设$dp[i][j]$为存活i个人时j活到最后的概率，那么有初始条件$dp[1][1]=1$,最终答案：$dp[n][m]$。并且可以非常快得的到状态转移方程：$dp[i][j]=p*dp[i-1][j-1]+(1-p)*dp[i][j-1]$,但是这样就出现了后效性，那么考虑消元，看了眼数据发现搞死消元会t。那么考虑这个数据的性质，发现$\sum_{j=1}^{i} dp[i][j]=1$通过一番在草稿纸上的暴力推演，求第i行的时候i-1行已经求出来了，那么上面的柿子可以化简成$a*dp[i][1]+b=1$的形式。易得$a = \sum_{x=0}^{i-1}(1-p)^x$，$b=\sum_{x=0}^{i-2}(dp[i-1][x]*\sum_{y=0}^{x}(1-p)^y)$,然后对$\sum_{x=0}^{i-1}(1-p)^x$搞个小小的前缀和，就可以非常方便得求出来$dp[i][1]$了。总时间复杂度为$O(n^2)$.

代码：

```c++
//
// Created by mrx on 2022/7/11.
//

#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

long long exgcd(long long a, long long b, long long &x, long long &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    ll d = exgcd(b, a % b, x, y);
    ll t = x;
    x = y;
    y = t - a / b * x;
    return d;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    double p;
    int n, k;
    cin >> p >> n >> k;
    vector<vector<double>> dp(2, vector<double>(n + 1, 0));
    vector<double> p2(n + 1, 0), sum(n + 1, 0);
    sum[0] = 1, p2[0] = 1;
    for (int i = 1; i <= n; ++i) {
        p2[i] = p2[i - 1] * (1 - p);
        sum[i] = sum[i - 1] + p2[i];
    }
    if (p == 0) {
        cout << 0 << endl;
        return 0;
    }
    dp[1][1] = 1;
    for (int i = 2; i <= n; ++i) {
        double a = sum[i - 1];
        double b = 0;
        for (int j = 0; j <= i - 2; ++j) {
            b += p * dp[(i - 1) % 2][i - 1 - j] * sum[j];
        }
        dp[i % 2][1] = (1 - b) / a;
        for (int j = 2; j <= i; ++j) {
            dp[i % 2][j] = dp[(i - 1) % 2][j - 1] * p + dp[i % 2][j - 1] * (1 - p);
        }
    }
    cout << fixed << setprecision(9) << dp[n % 2][k] << endl;
    return 0;
}
```

### 13.Chiitoitsu(nowcoder multi1 I)

题目大意：给34种牌，每种牌有4张，初始摸13张手牌，每轮要进行摸牌和弃牌，问摸牌后能恰好匹配出7对牌的期望。

题目分析：考虑最优的策略，玩家无牌可弃的时候才会弃初始手牌，所以这个题的最优决策是每次取出来的牌如果不能和自己已有的单牌匹配就弃掉，所以考虑概率dp令$dp[i][j]$为进行i轮手牌中有j对匹配的牌，那么初始状态就是初始手牌的对子数，其概率为1，终止状态就是所有轮中手中有7对匹配的牌。考虑状态转移，$dp[i+1][j]=dp[i][j-1]*3\frac{13-2*j+2}{123-i}+dp[i][j]*\frac{123-i-13+2*j}{123-i}$因为最后算的是期望，那么只要把轮数和每轮能获胜的概率乘起来然后求和即可。

代码：

```c++
#include <bits/stdc++.h>

using ll = long long;
const ll mod = 1e9 + 7;

ll quickPow(ll base, ll fact) {
    ll ans = 1;
    while (fact) {
        if (fact & 1) ans = ans * base % mod;
        base = base * base % mod;
        fact >>= 1;
    }
    return ans;
}

ll ans[7] = {0};

void sol(int n) {
    std::vector<std::vector<ll>> dp(125, std::vector<ll>(15, 0));
    //opt,paircnt
    dp[0][n] = 1;
    for (int j = 0; j <= 6; ++j) {
        for (int i = 0; i <= 123; ++i) {
            int need = (13 - 2 * j) * 3;
            int rem = 123 - i;
            if (rem < need)break;
            dp[i + 1][j + 1] += need * quickPow(rem, mod - 2) % mod * dp[i][j] % mod;
            dp[i + 1][j + 1] %= mod;
            dp[i + 1][j] += (rem - need) * quickPow(rem, mod - 2) % mod * dp[i][j] % mod;
            dp[i + 1][j] %= mod;
        }
    }
    for (int i = 0; i <= 123; ++i) {
        ans[n] += i * dp[i][7] % mod;
        ans[n] %= mod;
    }

}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    for (int i = 0; i <= 6; ++i) {
        sol(i);
    }
    int t;
    std::cin >> t;
    for (int i = 1; i <= t; ++i) {
        std::map<std::pair<int, char>, int> mp;
        for (int j = 1; j <= 13; ++j) {
            char c;
            int x;
            std::cin >> x >> c;
            mp[std::make_pair(x, c)]++;
        }
        std::cout << "Case #" << i << ": " << ans[13 - mp.size()] << std::endl;

    }
    return 0;
}
```

### 14.Jee, You See?(CF1670F)

题目大意：给定 4 个整数 $n,l,r,z$ ($1 \le n \le 1000,1 \le l \le r \le 10^{18},1 \le z \le 10^{18}$

求满足一下条件的序列 $a$ 的个数：

1. $a_i$ 为非负整数
2. $l \le a_1 + a_2 + \dots a_n \le r $
3. $a_1 \oplus a_2 \oplus \dots \oplus a_n = z$

其中 $\oplus$ 表示二进制按位异或运算

答案对 $10^9 + 7$ 取模

题目分析：类似于数位dp，设计一下状态，$dp[i][j]$为i-1位满足要求，第i位可以选j个1（包括选0到j个1的所有状态）的n元组种类个数。那么考虑状态转移，那么对于第i-1位，对于i-1位，枚举 k个1，就有状态转移方程：$dp[i-1][j*2+(r>>i-1)\and 1-k]=dp[i][j]*C_j^k$	，在枚举i-1位的时候，考虑第二个约束条件，即对应取k取奇数还是偶数。

代码：

```c++
//
// Created by mrx on 2022/7/19.
//

#include <bits/stdc++.h>

using ll = long long;
const ll mod = 1e9 + 7;

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    ll n, l, r, z;
    std::cin >> n >> l >> r >> z;
    std::vector<std::vector<ll>> C(n + 1, std::vector<ll>(n + 1));
    C[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= i; ++j) {
            if (j == 0)C[i][j] = 1;
            else C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
        }
    }

    auto sol = [&](ll x) {
        std::vector<std::vector<ll>> dp(62, std::vector<ll>(n + 1, 0));
        dp[61][0] = 1;
        for (ll i = 60; i >= 0; --i) {
            for (ll j = 0; j <= n; ++j) {
                ll canChoose = 2 * j + (x >> i & 1);
                for (ll k = (z >> i & 1); k <= n && k <= canChoose; k += 2) {
                    dp[i][std::min(canChoose - k, n)] += dp[i + 1][j] * C[n][k] % mod;
                    dp[i][std::min(canChoose - k, n)] %= mod;
                }
            }
        }
        ll ans = 0;
        for (int i = 0; i <= n; ++i)ans = (ans + dp[0][i]) % mod;
        return ans;
    };
    std::cout << (sol(r) - sol(l - 1) + mod) % mod << std::endl;

    return 0;
}
```

### 15.校内赛 概率论与数理统计

题目描述：

这天空洞大师zzk在教gyx打隔膜，考虑到gyx的手残体质，大师决定教他刮痧流打法。

所谓刮痧流即打一次就跑，具体的,gyx每次攻击可以使选定的目标生命值-1，可以攻击m次。

教程关一共有n个怪物，第i个生命值为$a_i$，都没有攻击力，排成一排等着挨打。

但是由于不会操作,gyx还是只会乱砍，所以每次行动他会随机选一个当前生命值为正数的怪物攻击。

作为概率论大师的柴老师觉得这个过程很有趣，于是想了一道题：经过m次攻击后,gyx能击败的怪物期望数。

称一个怪物被击败，当且仅当某一时刻其生命值=0。

题目分析：

乍一看好像每一次让一个怪物扣血的概率都和场上存活的怪物数量有关系，又注意到n很小，容易想到使用状态压缩。记$dp[s][i]$为攻击了 $i$次，有$s$这个状态的怪物死了的概率。那么最后的答案就是攻击m次之后每个状态的popcount乘以概率乘以其余怪物活着的方案。记$g[s][i]$为砍了$i$次，有$s$这些怪物活着的方案数。那么可以分别得到$dp$和$g$的状态转移方程：

如果第$i+1$刀砍死了一个怪物，那么$dp[s][i]->dp[s|(1<<j)][i+1]$，其概率为${{a[j]-1}\choose {i - sum[s]}}/ popcount(s)$。因为要确保在i+1杀死这个怪物，那么第i刀已经杀了 $a[j]-1$ 刀了。如果没砍死，那么就直接转移到$dp[s][i+1]$

考虑如何计算 $g[s][i]$ ,这个就根背包类似。

代码

```c++
//
// Created by mrx on 2022/10/4.
//
#include <vector>
#include <algorithm>
#include <iostream>
#include <array>
#include <cmath>
#include <iomanip>


int lowbit(int x) {
	return x & -x;
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n, m;
	std::cin >> n >> m;

	std::vector<std::vector<long double>> C(105, std::vector<long double>(105));
	C[0][0] = 1;
	for (int i = 1; i <= 100; ++i) {
		C[i][0] = 1;
		for (int j = 1; j <= 100; ++j) {
			C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
		}
	}

	std::vector<int> a(n);
	for (int i = 0; i < n; ++i)std::cin >> a[i];

	std::vector<int> sum(1 << n);
	for (int s = 0; s < 1 << n; ++s) for (int i = 0; i < n; ++i) if (s >> i & 1)sum[s] += a[i];

	std::vector<std::vector<long double>> g(m + 1, std::vector<long double>(1 << n));
	//噶i刀，存活状态为s的方案数量。
	g[0][0] = 1;
	for (int s = 0; s < 1 << n; ++s) {
		for (int k = 0; k < n; ++k) {
			if ((s >> k) & 1) {
				int s0 = s ^ (1 << k);
				for (int i = 0; i <= m; ++i) {
					for (int j = 0; j <= std::min(a[k] - 1, i); ++j) {
						g[i][s] += g[i - j][s0] * C[i][j];
					}
				}
				break;
			}
		}
	}


	std::vector<std::vector<long double>> dp(m + 1, std::vector<long double>(1 << n));
	//噶i刀，状态为s的挂了的概率
	dp[0][0] = 1;
	for (int s = 0; s < 1 << n; ++s) {
		int cur = __builtin_popcount(s);
		int cnt = n - cur;
		for (int now = sum[s]; now < m; ++now) {
			int rem = ((1 << n) - 1) ^ s;
			for (int j = 0; j < n; ++j) {
				if (!((s >> j) & 1)) {
					if (a[j] - 1 <= now - sum[s])dp[now + 1][s | (1 << j)] += dp[now][s] * C[now - sum[s]][a[j] - 1] / cnt;
				}
			}
			dp[now + 1][s] += dp[now][s] / cnt;
		}
	}

	for (int s = 0; s < 1 << n; ++s) {
		for (int i = 0; i <= m; ++i) {
			if (i < sum[s])continue;
			int rem = ((1 << n) - 1) ^ s;
			dp[i][s] *= g[i - sum[s]][rem];
		}
	}

	long double ans = 0;
	for (int s = 0; s < 1 << n; ++s) {
		if (m < sum[s])continue;
		int cnt = __builtin_popcount(s);
		ans += dp[m][s] * cnt;
	}
	std::cout << std::fixed << std::setprecision(5) << ans << '\n';
	return 0;
}
```

### 16.Damaged Bicycle 2021Harbin

**题意**

给定一个无向图，你要从1号点出发去往n号点，这张图中有k个自行车，分别有$p_i$的概率是好的，步行的速度为$t$,骑车的速度为$r$,求其所消耗时间 期望值，如果到不了，输出-1.

**分析**

对于每个点，下一步的选择肯定是选择接下来状态中期望用时最小的。然后会发现很多点都是没用的，最终有用的点都是有自行车的点和起点终点。然后就能变成k个点，设$dp[s][i]$为s这个的自行车点状态没有去过，停留在$i$点到达$n$期望消耗时间。状态转移就是如果这个地方没自行车，为直接走到终点消耗的时间和去往其他有车点的期望最小值，否则为骑车到终点的期望时间。这个过程可以用dfs来做。

**代码**

```c++
//
// Created by mrx on 2022/10/28.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

#include <iomanip>

using i64 = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int t, r;
	std::cin >> t >> r;
	int n, m;
	std::cin >> n >> m;
	std::vector<std::vector<std::pair<int, int>>> adj(n + 1);
	for (int i = 0; i < m; ++i) {
		int u, v, w;
		std::cin >> u >> v >> w;
		adj[u].emplace_back(v, w);
		adj[v].emplace_back(u, w);
	}

	int k;
	std::cin >> k;
	std::vector<std::vector<std::pair<int, int>>> adj2(k + 2);
	std::vector<int> prob(k + 2);
	std::vector<int> gra_2(k + 2);
	gra_2[0] = 1;
	gra_2[k + 1] = n;
	prob[0] = 100;
	for (int i = 1; i <= k; ++i) {
		std::cin >> gra_2[i] >> prob[i];
	}

	std::vector mp(k + 2, std::vector<int>(k + 2, 0));

	for (int i = 0; i <= k + 1; ++i) {
		std::vector<int> dis(n + 1, 0x3f3f3f3f);
		auto dij = [&](int start) {
			std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<>> q;
			dis[start] = 0;
			q.emplace(0, start);
			while (!q.empty()) {
				auto [dist, u] = q.top();
				q.pop();
				if (dis[u] != dist)continue;
				for (auto [v, w]: adj[u]) {
					if (dis[v] > dis[u] + w) {
						dis[v] = dis[u] + w;
						q.emplace(dis[v], v);
					}
				}
			}
		};

		dij(gra_2[i]);
		for (int j = 0; j <= k + 1; ++j)mp[i][j] = dis[gra_2[j]];
	}

//	for (int i = 0; i <= k + 1; ++i) {
//		for (int j = 0; j <= k + 1; ++j)std::cout << mp[i][j] << ' ';
//		std::cout << '\n';
//	}
	if (mp[0][k + 1] == 0x3f3f3f3f)std::cout << -1 << '\n';
	else {

		std::vector dp(1 << (k + 2), std::vector<double>(k + 2, -1));
		std::function<double(int, int)> dfs = [&](int s, int x) {
			if (dp[s][x] >= 0)return dp[s][x];
			if (!s) {
				return dp[s][x] = 0.01 * (100 - prob[x]) * mp[x][k + 1] / r + 0.01 * prob[x] * mp[x][k + 1] / t;
			}
			double cur = 1.0 * mp[x][k + 1] / t;
			for (int i = 0; i <= k; ++i) {
				if ((s >> i & 1) && mp[x][gra_2[i + 1]] < 0x3f3f3f3f) {
					cur = std::min(cur, 1.0 * mp[x][i + 1] / t + dfs(s ^ 1 << i, i + 1));
				}
			}
			return dp[s][x] = 0.01 * (100 - prob[x]) * mp[x][k + 1] / r + 0.01 * prob[x] * cur;
		};
		double ans = dfs((1 << (k + 1)) - 1, 0);
		std::cout << std::fixed << std::setprecision(6) << ans << '\n';
	}

	return 0;
}
```



### 17.Race to 1 UVA11762

**题目大意**

给定一个整数N，每次从不超过N的素数中等概率随机选一个p 若p|N，则令N /= p, 否则不变，问期望几次能够把 N 变成1

**题目分析**

对于一个数字$x$很容易得到其状态转移，先筛出来所有的质数，然后记忆化搜索即可。

**代码**

```c++
//
// Created by mrx on 2022/10/30.
//


#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <iomanip>
#include <map>

using i64 = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	std::vector<int> prime;
	{
		std::vector<int> vis(1000006);
		for (int i = 2; i <= 1e6; ++i) {
			if (!vis[i])prime.push_back(i);
			for (int j = 0; j < prime.size() && i * prime[j] <= 1e6; ++j) {
				vis[i * prime[j]] = 1;
				if (i % prime[j] == 0)break;
			}
		}
	}

	std::vector<double> dp(1000006);
	std::vector<bool> vis(1000006, false);
	dp[1] = 0;
	vis[1] = true;

	int t;
	std::cin >> t;
	for (int cas = 1; cas <= t; ++cas) {
		int n;
		std::cin >> n;
		std::function<double(int)> dfs = [&](int x) {
			if (vis[x])return dp[x];

			vis[x] = true;

			auto& ans = dp[x];
			ans = 0;
			int useful = 0;
			int cnt = 0;
			for (int i = 0; i < prime.size() && prime[i] <= x; ++i) {
				cnt++;
				if (x % prime[i] == 0) {
					useful++;
					ans += dfs(x / prime[i]);
				}
			}
			ans = (ans + cnt) / useful;
			return ans;

		};
		double ans = dfs(n);
		std::cout << "Case " << cas << ": " << std::fixed << std::setprecision(10) << ans << '\n';
	}
	return 0;
}
```



### 18.2021昆明G

题意：给一个序列，每个数字都有$p_i$的概率被选中，选中后把它插到第一位，并定义贡献为位移多少位。求第$1145^{141919}$次操作时产生贡献的期望。

因为是无限轮，那么答案可以转化为每一个数字所在位置的期望-1乘以其被选中的概率然后求和。

很多题都有这样的思路，现在我们考虑一个元素的位置，那么它和另外的某一个元素之间的关系，如果一个元素在另一个元素之后被选中，那么其他的元素是无关紧要的，那就可以看作是另一个元素对这个元素位置的贡献了。显然如果元素a在元素b前面被选中，其概率为$p_a/(p_a+p_b)$。然后就能求出来所有元素的位置了。这是个很牛逼的trick！

## 多项式

### 1.p3338力

题目描述

给出 $n$ 个数 $q_1,q_2, \dots q_n$，定义

$$F_j~=~\sum_{i = 1}^{j - 1} \frac{q_i \times q_j}{(i - j)^2}~-~\sum_{i = j + 1}^{n} \frac{q_i \times q_j}{(i - j)^2}$$

$$E_i~=~\frac{F_i}{q_i}$$

对 $1 \leq i \leq n$，求 $E_i$ 的值。

输入格式

第一行输入一个整数 $n$。

以下 $n$ 行，每行有一个实数。第 $i+1$ 行的数代表 $q_i$。

输出格式

输出 $n$ 行每行一个实数，第 $i$ 行的数字代表 $E_i$。

当你的输出与标准答案相差不超过 $10^{-2}$ 时即被认为正确。

题目分析

对给定的柿子进行化简$F_j~=~\sum_{i = 1}^{j - 1} \frac{q_i \times q_j}{(i - j)^2}~-~\sum_{i = j + 1}^{n} \frac{q_i \times q_j}{(i - j)^2}$

再反转一下就可以变成两个多项的卷鸡，然后输出答案

代码:

```c++
//
// Created by mrx on 2022/7/13.
//
#include <bits/stdc++.h>

#define ll long long
#define endl '\n'
using namespace std;

inline void FFT(vector<complex<long double>> &a, vector<long long> &inv, long long limit, int type) {
    if (limit == 1)return;
    for (int i = 0; i < limit; ++i) {
        if (i < inv[i])swap(a[i], a[inv[i]]);
    }
    for (long long mid = 1; mid < limit; mid <<= 1) {
        long long r = mid << 1;
        complex<long double> wn(cos(acos(-1) / mid), type * sin(acos(-1) / mid));
        for (long long i = 0; i < limit; i += r) {
            complex<long double> w(1, 0);
            for (long long k = i; k < i + mid; ++k) {
                complex<long double> u = a[k];
                complex<long double> t = w * a[k + mid];
                a[k] = u + t;
                a[k + mid] = u - t;
                w = w * wn;
            }
        }
    }
}

void sol() {
    int n;
    cin >> n;
    long long limit = 1;
    while (limit <= (n << 1))limit <<= 1;
    vector<complex<long double>> F(limit + 10), F2(limit + 10), Q(limit + 10);
    vector<long long> inv(limit + 10);
    for (int i = 0; i < limit; ++i) {
        inv[i] = (inv[i >> 1] >> 1) | ((i & 1) ? limit >> 1 : 0);
    }
    for (int i = 1; i <= n; ++i) {
        long double tmp;
        cin >> tmp;
        F[i].real(tmp);
        F2[n - i].real(tmp);
        Q[i].real((long double) (1.0 / i / i));
    }
    FFT(F, inv, limit, 1);
    FFT(F2, inv, limit, 1);
    FFT(Q, inv, limit, 1);
    for (int i = 0; i < limit; ++i) {
        F[i] = F[i] * Q[i];
        F2[i] = F2[i] * Q[i];
    }
    FFT(F, inv, limit, -1);
    FFT(F2, inv, limit, -1);
    for (int i = 1; i <= n; ++i) {
        long double ans1 = F[i].real() / limit;
        long double ans2 = F2[n - i].real() / limit;
        cout << fixed << setprecision(3) << ans1 - ans2 << endl;
    }
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
#endif
    int n;
    n = 1;
    while (n--)sol();
    return 0;
}
```

### 2.P5488差分和前缀和

题目描述

给定一个长为 $n$ 的序列 $a$，求出其 $k$ 阶差分或前缀和。    
结果的每一项都需要对 $1004535809$ 取模。

输入格式

第一行三个整数 $n,k,t$，若 $t=0$ 表示求前缀和，$t=1$ 表示求差分。  
第二行 $n$ 个整数，表示序列 $a$。

输出格式

输出一行 $n$ 个整数，表示 $a$ 的 $k$ 阶差分或前缀和。

题目分析

求前缀和相当于$f(x)*(1+x+x^2+x^3...x^{n})$,求差分相当于$f(x)*(1-x+x^2-x^3...(-x)^{n})$	k阶前缀和和差分相当原多项式乘以这两个的k次方，通过一点简单的幂级数和函数以及展开知识可以得到其k解差分对应转移多项式，然后就可以$O(nlogn)$算出其k阶前缀和数组和差分。

```c++
//
// Created by mrx on 2022/8/5.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, int b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    int val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

constexpr int mod = 1004535809;
using Z = Modular<mod>;
std::vector<int> rev;
std::vector<Z> roots{0, 1};

void dft(std::vector<Z> &a) {
    int n = a.size();

    if (int(rev.size()) != n) {
        rev.resize(n);
        for (int i = 0; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? n >> 1 : 0);
        }
    }

    for (int i = 0; i < n; ++i) {
        if (rev[i] < i)std::swap(a[i], a[rev[i]]);
    }
    if (int(roots.size() < n)) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
            Z e = power(Z(3), (mod - 1) >> (k + 1));
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[i << 1] = roots[i];
                roots[i << 1 | 1] = roots[i] * e;
            }
            k++;
        }
    }

    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}

void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
}

struct Poly {
    std::vector<Z> a;

    Poly() {}

    Poly(const std::vector<Z> &a) : a(a) {}

    Poly(const std::initializer_list<Z> &a) : a(a) {}

    int size() const {
        return a.size();
    }

    void resize(int n) {
        a.resize(n);
    }

    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }

    Z &operator[](int idx) {
        return a[idx];
    }

    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }

    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }

    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }

    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }

    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }

    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        Z inv = Z(sz).inv();
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i] * inv;
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }

    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < int(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }

    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }

    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }

    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }

    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }

    Poly deriv() const {
        if (a.empty()) {
            return Poly();
        }
        std::vector<Z> res(size() - 1);
        for (int i = 0; i < size() - 1; ++i) {
            res[i] = (i + 1) * a[i + 1];
        }
        return Poly(res);
    }

    Poly integr() const {
        std::vector<Z> res(size() + 1);
        for (int i = 0; i < size(); ++i) {
            res[i + 1] = a[i] / (i + 1);
        }
        return Poly(res);
    }

    Poly inv(int m) const {
        Poly x{a[0].inv()};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{2} - modxk(k) * x)).modxk(k);
        }
        return x.modxk(m);
    }

    Poly log(int m) const {
        return (deriv() * inv(m)).integr().modxk(m);
    }

    Poly exp(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{1} - x.log(k) + modxk(k))).modxk(k);
        }
        return x.modxk(m);
    }

    Poly pow(int k, int m) const {
        int i = 0;
        while (i < size() && a[i].val() == 0) {
            i++;
        }
        if (i == size() || 1LL * i * k >= m) {
            return Poly(std::vector<Z>(m));
        }
        Z v = a[i];
        auto f = divxk(i) * v.inv();
        return (f.log(m - i * k) * k).exp(m - i * k).mulxk(i * k) * power(v, k);
    }

    Poly sqrt(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((mod + 1) / 2);
        }
        return x.modxk(m);
    }

    Poly mulT(Poly b) const {
        if (b.size() == 0) {
            return Poly();
        }
        int n = b.size();
        std::reverse(b.a.begin(), b.a.end());
        return ((*this) * b).divxk(n - 1);
    }

    std::vector<Z> eval(std::vector<Z> x) const {
        if (size() == 0) {
            return std::vector<Z>(x.size(), 0);
        }
        const int n = std::max(int(x.size()), size());
        std::vector<Poly> q(4 * n);
        std::vector<Z> ans(x.size());
        x.resize(n);
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                q[p] = Poly{1, -x[l]};
            } else {
                int m = (l + r) / 2;
                build(2 * p, l, m);
                build(2 * p + 1, m, r);
                q[p] = q[2 * p] * q[2 * p + 1];
            }
        };
        build(1, 0, n);
        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {
            if (r - l == 1) {
                if (l < int(ans.size())) {
                    ans[l] = num[0];
                }
            } else {
                int m = (l + r) / 2;
                work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l));
                work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m));
            }
        };
        work(1, 0, n, mulT(q[1].inv(n)));
        return ans;
    }
};

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    freopen("o.txt", "w", stderr);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int n, opt;
    Z k;
    std::cin >> n;
    char cc = std::cin.get();
    ll cn = 0, flus = 1;
    while (cc < '0' || cc > '9') {
        if (cc == '-') flus = -flus;
        cc = std::cin.get();
    }
    while (cc >= '0' && cc <= '9') {
        cn = (cn * 10 + cc - '0') % (mod), cc = std::cin.get();
    }
    k = cn * flus;

    std::cin >> opt;
    std::vector<Z> a(n);
    for (int i = 0; i < n; ++i)std::cin >> a[i];
    Poly A(a);
    std::vector<Z> B(n);
    B[0] = 1;
    if (opt == 0) {
        for (int i = 1; i < n; ++i)B[i] = B[i - 1] * Z(k + i - 1) * power(Z(i), mod - 2);
    } else {
        for (int i = 1; i < n; ++i)B[i] = Z(-B[i - 1] * Z(k - i + 1) * power(Z(i), mod - 2));
    }
    Poly rhs(B);
    for (int i = 0; i < n; ++i)std::cerr << B[i] << ' ';
    Poly ans = A * rhs;
    for (int i = 0; i < n; ++i) std::cout << ans[i] << ' ';
    return 0;
}
```

### 3.CF755G PolandBall and Many Other Balls

题目描述

有一排 $n$ 个球，定义一个组可以只包含一个球或者包含两个相邻的球。现在一个球只能分到一个组中，求从这些球中取出 1- $k$ 组的方案数。

$n\le 10^9$，$k<2^{15}$。

题目分析

很容易可以推出来一个$O(n*k)$的简单的dp，且状态转移方程是$dp_{i,j}=dp_{i-1,j-1}+dp_{i-1,j}+dp_{i-2,j-1}$将第二维的dp计为生成函数，那么就有$dp_{i}=(1+x)dp_{i-1}+x\cdot dp_{i-2}$这样就可以通过$dp_0,dp_1$和多项式构成的矩阵快速蜜求出来$dp_n$然后输出答案即可。还有一种方法是求出来特征方程，然后直接算出来。

```c++
//
// Created by mrx on 2022/8/5.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, int b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    int val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

constexpr int mod = 998244353;
using Z = Modular<mod>;

std::vector<int> rev;
std::vector<Z> roots{0, 1};

void dft(std::vector<Z> &a) {
    int n = a.size();

    if (int(rev.size()) != n) {
        rev.resize(n);
        for (int i = 0; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? n >> 1 : 0);
        }
    }

    for (int i = 0; i < n; ++i) {
        if (rev[i] < i)std::swap(a[i], a[rev[i]]);
    }
    if (int(roots.size() < n)) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
            Z e = power(Z(3), (mod - 1) >> (k + 1));
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[i << 1] = roots[i];
                roots[i << 1 | 1] = roots[i] * e;
            }
            k++;
        }
    }

    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}

void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
}

struct Poly {
    std::vector<Z> a;

    Poly() {}

    Poly(const std::vector<Z> &a) : a(a) {}

    Poly(const std::initializer_list<Z> &a) : a(a) {}

    int size() const {
        return a.size();
    }

    void resize(int n) {
        a.resize(n);
    }

    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }

    Z &operator[](int idx) {
        return a[idx];
    }

    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }

    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }

    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }

    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }

    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }

    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        Z inv = Z(sz).inv();
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i] * inv;
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }

    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < int(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }

    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }

    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }

    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }

    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }

    Poly deriv() const {
        if (a.empty()) {
            return Poly();
        }
        std::vector<Z> res(size() - 1);
        for (int i = 0; i < size() - 1; ++i) {
            res[i] = (i + 1) * a[i + 1];
        }
        return Poly(res);
    }

    Poly integr() const {
        std::vector<Z> res(size() + 1);
        for (int i = 0; i < size(); ++i) {
            res[i + 1] = a[i] / (i + 1);
        }
        return Poly(res);
    }

    Poly inv(int m) const {
        Poly x{a[0].inv()};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{2} - modxk(k) * x)).modxk(k);
        }
        return x.modxk(m);
    }

    Poly log(int m) const {
        return (deriv() * inv(m)).integr().modxk(m);
    }

    Poly exp(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{1} - x.log(k) + modxk(k))).modxk(k);
        }
        return x.modxk(m);
    }

    Poly pow(int k, int m) const {
        int i = 0;
        while (i < size() && a[i].val() == 0) {
            i++;
        }
        if (i == size() || 1LL * i * k >= m) {
            return Poly(std::vector<Z>(m));
        }
        Z v = a[i];
        auto f = divxk(i) * v.inv();
        return (f.log(m - i * k) * k).exp(m - i * k).mulxk(i * k) * power(v, k);
    }

    Poly sqrt(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((mod + 1) / 2);
        }
        return x.modxk(m);
    }

    Poly mulT(Poly b) const {
        if (b.size() == 0) {
            return Poly();
        }
        int n = b.size();
        std::reverse(b.a.begin(), b.a.end());
        return ((*this) * b).divxk(n - 1);
    }

    std::vector<Z> eval(std::vector<Z> x) const {
        if (size() == 0) {
            return std::vector<Z>(x.size(), 0);
        }
        const int n = std::max(int(x.size()), size());
        std::vector<Poly> q(4 * n);
        std::vector<Z> ans(x.size());
        x.resize(n);
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                q[p] = Poly{1, -x[l]};
            } else {
                int m = (l + r) / 2;
                build(2 * p, l, m);
                build(2 * p + 1, m, r);
                q[p] = q[2 * p] * q[2 * p + 1];
            }
        };
        build(1, 0, n);
        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {
            if (r - l == 1) {
                if (l < int(ans.size())) {
                    ans[l] = num[0];
                }
            } else {
                int m = (l + r) / 2;
                work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l));
                work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m));
            }
        };
        work(1, 0, n, mulT(q[1].inv(n)));
        return ans;
    }
};

int k;

struct matrix {
    std::vector<std::vector<Poly>> mat;
    ll n, m;

    matrix(ll a, ll b) {
        n = a, m = b;
        mat.resize(n);
        for (auto &x: mat)x.resize(m);
    }


    void E() {
        for (ll i = 0; i < std::min(n, m); ++i) {
            mat[i][i] = Poly({1});
        }
    }

    void show() {
        for (auto x: mat) {
            for (auto y: x) {
                for (auto &z: y.a)std::cout << z << ' ';
                std::cout << '*';
            }
            std::cout << std::endl;
        }
    }

    matrix operator*(const matrix &rhs) {
        matrix ans(n, rhs.m);
        if (m != rhs.n) {
            std::cerr << "Matrix not matching!";
        }
        for (ll i = 0; i < n; ++i) {
            for (ll j = 0; j < m; ++j) {
                for (ll k = 0; k < rhs.m; ++k) {
                    ans.mat[i][k] = (ans.mat[i][k] + mat[i][j] * rhs.mat[j][k]).modxk(::k + 1);
                }
            }
        }
        return ans;
    }

    friend matrix operator^(matrix bas, long long x) {
        matrix ans(bas.n, bas.n);
        ans.E();
        while (x) {
            if (x & 1) {
                ans = ans * bas;
            }
            bas = bas * bas;
            x >>= 1;
        }
        return ans;
    }

};

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int n;
    std::cin >> n >> k;
    //dp[i][j]=dp[i-1][j]+d[i-1][j-1]+dp[i-2][j-1]
    //f_n(x)为n个球的生成函数，->f_n(x)=(x+1)f_n-1(x)+xf_n-2(x)
    //->维护矩阵(,,,)
    matrix a(2, 2);
    a.mat[0][0] = Poly{1, 1};
    a.mat[0][1] = Poly{0, 1};
    a.mat[1][0] = Poly{1};
    a.mat[1][1] = Poly{0};
    a = a ^ n;
    Poly a0 = {0};
    Poly a1 = {0, 1};
    Poly ans = a.mat[0][0] * a1 + a.mat[0][1] * a0;
    ans = ans.divxk(2);
    ans.a.resize(k);
    for (int i = 0; i < k; ++i)std::cout << ans[i] << ' ';
    return 0;
}
```

### 4.HDU7057Buying Snacks

**题目大意**

给 n 种零食，每个零食有大小包装之分，有三种购买方案，价钱分别如下：

只购买一个小的，花费一块钱
只独购买一个大的，花费两块钱
$ \forall i>1 $，可以和 第$i-1$种零食捆绑购买，可以便宜一块钱
她有m元钱，问她的不同购买方案数分别是多少

**题目分析**

可以考虑出来状态转移方程，$dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+dp[i-1][j-2]+dp[i-2][j-1]+2dp[i-2][j-2]+dp[i-2][j-3]$

转化为生成函数,$f_i=(1+x+x^2)f_{i-1}+(x+2x+x^3)f_i-2$,然后列出特征方程，$Z^2=(1+X+X^2)Z+(X+2X^2+X^3)$求解出来得到$z_1=x^2+2x+1,z_2=-x$通过已知条件$f_0=1,f_1=1+x+x^2$进行待定系数法解方程，得到通项公式：$f_n=\frac{(x^2+2x+1)^{n+1}+(-1)^nx^{n+1}}{x^2+3x+1}$

```c++
//
// Created by mrx on 2022/8/6.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, int b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    int val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

constexpr int mod = 998244353;
using Z = Modular<mod>;

std::vector<int> rev;
std::vector<Z> roots{0, 1};

void dft(std::vector<Z> &a) {
    int n = a.size();

    if (int(rev.size()) != n) {
        rev.resize(n);
        for (int i = 0; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? n >> 1 : 0);
        }
    }

    for (int i = 0; i < n; ++i) {
        if (rev[i] < i)std::swap(a[i], a[rev[i]]);
    }
    if (int(roots.size() < n)) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
            Z e = power(Z(3), (mod - 1) >> (k + 1));
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[i << 1] = roots[i];
                roots[i << 1 | 1] = roots[i] * e;
            }
            k++;
        }
    }

    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}

void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
}

struct Poly {
    std::vector<Z> a;

    Poly() {}

    Poly(const std::vector<Z> &a) : a(a) {}

    Poly(const std::initializer_list<Z> &a) : a(a) {}

    int size() const {
        return a.size();
    }

    void resize(int n) {
        a.resize(n);
    }

    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }

    Z &operator[](int idx) {
        return a[idx];
    }

    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }

    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }

    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }

    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }

    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }

    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        Z inv = Z(sz).inv();
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i] * inv;
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }

    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < int(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }

    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }

    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }

    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }

    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }

    Poly deriv() const {
        if (a.empty()) {
            return Poly();
        }
        std::vector<Z> res(size() - 1);
        for (int i = 0; i < size() - 1; ++i) {
            res[i] = (i + 1) * a[i + 1];
        }
        return Poly(res);
    }

    Poly integr() const {
        std::vector<Z> res(size() + 1);
        for (int i = 0; i < size(); ++i) {
            res[i + 1] = a[i] / (i + 1);
        }
        return Poly(res);
    }

    Poly inv(int m) const {
        Poly x{a[0].inv()};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{2} - modxk(k) * x)).modxk(k);
        }
        return x.modxk(m);
    }

    Poly log(int m) const {
        return (deriv() * inv(m)).integr().modxk(m);
    }

    Poly exp(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{1} - x.log(k) + modxk(k))).modxk(k);
        }
        return x.modxk(m);
    }

    Poly pow(int k, int m) const {
        int i = 0;
        while (i < size() && a[i].val() == 0) {
            i++;
        }
        if (i == size() || 1LL * i * k >= m) {
            return Poly(std::vector<Z>(m));
        }
        Z v = a[i];
        auto f = divxk(i) * v.inv();
        return (f.log(m - i * k) * k).exp(m - i * k).mulxk(i * k) * power(v, k);
    }

    Poly sqrt(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((mod + 1) / 2);
        }
        return x.modxk(m);
    }

    Poly mulT(Poly b) const {
        if (b.size() == 0) {
            return Poly();
        }
        int n = b.size();
        std::reverse(b.a.begin(), b.a.end());
        return ((*this) * b).divxk(n - 1);
    }

    std::vector<Z> eval(std::vector<Z> x) const {
        if (size() == 0) {
            return std::vector<Z>(x.size(), 0);
        }
        const int n = std::max(int(x.size()), size());
        std::vector<Poly> q(4 * n);
        std::vector<Z> ans(x.size());
        x.resize(n);
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                q[p] = Poly{1, -x[l]};
            } else {
                int m = (l + r) / 2;
                build(2 * p, l, m);
                build(2 * p + 1, m, r);
                q[p] = q[2 * p] * q[2 * p + 1];
            }
        };
        build(1, 0, n);
        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {
            if (r - l == 1) {
                if (l < int(ans.size())) {
                    ans[l] = num[0];
                }
            } else {
                int m = (l + r) / 2;
                work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l));
                work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m));
            }
        };
        work(1, 0, n, mulT(q[1].inv(n)));
        return ans;
    }
};

void sol() {
    int n, k;
    std::cin >> n >> k;
    Poly inv = Poly{1, 3, 1}.inv(k + 1);
    Poly z1 = Poly{1, 2, 1}.pow(n + 1, k + 1);
    if (k >= n + 1) {
        if (n & 1) {
            z1[n + 1]--;
        } else {
            z1[n + 1]++;
        }
    }
    z1 *= inv;
    for (int i = 1; i <= k; ++i)std::cout << z1[i] << ' ';
    std::cout << '\n';
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int testcase;
    std::cin >> testcase;
    while (testcase--)sol();
    return 0;
}
```

### 5.CF623E Transforming Sequence

对于一个整数序列 $\{a_1, a_2, \ldots, a_n\}$，我们定义它的变换为 $\{b_1, b_2, \ldots, b_n\}$，其中 $b_i = a_1 | a_2 | \ldots | a_i$，其中 $|$ 表示二进制按位或运算。

现在求有多少个长为 $n$ 的序列 $a$，满足 $1\leq a_i \leq 2^k - 1$，使得它的变换 $b$ 是**严格单调递增**的，对 $10^9+7$ 取模。

$1\leq n \leq 10^{18}$，$1\leq k \leq 3 \times 10^4$。

设$dp[i][j]$为前i个数字中有j个二进制位有1。

易得状态转移方程:$dp[i][j]=\sum dp[i-1][k]C_j^k2^k$然后讨论下如何加倍和加一，然后就能进行倍增fft了。

```c++
//
// Created by mrx on 2022/8/4.
//
#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, ll b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<typename T>
T power(T a, ll b, ll mod) {
    T ans = 1;
    for (; b; a = 1ll * a * a % mod, b >>= 1) {
        if (b & 1)ans = 1ll * ans * a % mod;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    ll val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

const ll mod1 = 998244353;
const ll mod2 = 1004535809;
const ll mod3 = 469762049;
const ll mod = 1e9 + 7;

struct Z {
    Modular<mod1> A;
    Modular<mod2> B;
    Modular<mod3> C;

    Z() {}

    Z(int x) : A(x), B(x), C(x) {}

    Z operator*(const Z &rhs) {
        Z ans(*this);
        ans.A *= rhs.A;
        ans.B *= rhs.B;
        ans.C *= rhs.C;
        return ans;
    }

    Z operator+(const Z &rhs) {
        Z ans(*this);
        ans.A += rhs.A;
        ans.B += rhs.B;
        ans.C += rhs.C;
        return ans;
    }

    Z operator-(const Z &rhs) {
        Z ans(*this);
        ans.A -= rhs.A;
        ans.B -= rhs.B;
        ans.C -= rhs.C;
        return ans;
    }

    Z operator/(const Z &rhs) {
        Z ans(*this);
        ans.A /= rhs.A;
        ans.B /= rhs.B;
        ans.C /= rhs.C;
        return ans;
    }

    Z &operator/=(const Z &rhs) {
        A /= rhs.A;
        B /= rhs.B;
        C /= rhs.C;
        return *this;
    }

    Z &operator*=(const Z &rhs) {
        A *= rhs.A;
        B *= rhs.B;
        C *= rhs.C;
        return *this;
    }

    Z &operator+=(const Z &rhs) {
        A += rhs.A;
        B += rhs.B;
        C += rhs.C;
        return *this;
    }

    Z &operator-=(const Z &rhs) {
        A -= rhs.A;
        B -= rhs.B;
        C -= rhs.C;
        return *this;
    }

    Z inv() const {
        Z ans;
        ans.A = A.inv();
        ans.B = B.inv();
        ans.C = C.inv();
        return ans;
    }
};

Z gete(int k) {
    Z ans;
    ans.A = power(Modular<998244353>(3), (998244352) >> (k + 1));
    ans.B = power(Modular<1004535809>(3), (1004535808) >> (k + 1));
    ans.C = power(Modular<469762049>(3), (469762048) >> (k + 1));
    return ans;
}

long long getint(const Z &z) {
    ll mod_1_2 = 1ll * mod1 * mod2;
    int inv1 = power(mod1, mod2 - 2, mod2), inv2 = power(mod_1_2 % mod3, mod3 - 2, mod3);
    ll x = 1ll * (z.B.val() - z.A.val() + mod2) % mod2 * inv1 % mod2 * mod1 + z.A.val();
    return (1ll * (z.C.val() - x % mod3 + mod3) % mod3 * inv2 % mod3 * (mod_1_2 % mod) % mod + x) % mod;
}

std::vector<int> rev;
std::vector<Z> roots{0, 1};

void dft(std::vector<Z> &a) {
    int n = a.size();

    if (int(rev.size()) != n) {
        rev.resize(n);
        for (int i = 0; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? n >> 1 : 0);
        }
    }

    for (int i = 0; i < n; ++i) {
        if (rev[i] < i)std::swap(a[i], a[rev[i]]);
    }
    if (int(roots.size() < n)) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
//            Z e = power(Z(3), (mod - 1) >> (k + 1));
            Z e = gete(k);
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[i << 1] = roots[i];
                roots[i << 1 | 1] = roots[i] * e;
            }
            k++;
        }
    }

    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}

void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
}

struct Poly {
    std::vector<Z> a;

    Poly() {}

    Poly(const std::vector<Z> &a) : a(a) {}

    Poly(const std::initializer_list<Z> &a) : a(a) {}

    int size() const {
        return a.size();
    }

    void resize(int n) {
        a.resize(n);
    }

    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }

    Z &operator[](int idx) {
        return a[idx];
    }

    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }

    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }

    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }

    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }

    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }

    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        Z inv = Z(sz).inv();
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i] * inv;
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }

    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < int(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }

    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }

    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }

    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }

    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }


};

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    ll n;
    int k;
    std::cin >> n >> k;

    std::vector<Modular<mod>> fact(k + 2), inv(k + 2);
    fact[0] = inv[0] = 1;
    for (int i = 1; i <= k + 1; ++i) {
        fact[i] = fact[i - 1] * i;
        inv[i] = fact[i].inv();
    }
    if (n > k)std::cout << 0 << '\n';
    else {
        Poly tmp;
        Poly ans;
        tmp.resize(k + 1), ans.resize(k + 1);
        std::function<void(ll, int)> quick_pow = [&](ll n, int k) {
            if (n == 1) {
                ans[0] = 0;
                for (int i = 1; i < k; i++) ans[i] = Z(inv[i].val());
                return;
            }
            quick_pow(n >> 1, k);
            tmp[0] = 0;
            for (int i = 1; i < k; i++) {
                tmp[i] = Z(1ll * getint(ans[i]) * power(2, 1ll * (n >> 1) * i % (mod - 1), mod) % mod);
//                std::cout << (n >> 1) * i << ' ' << power(2, 1ll * (n >> 1) * i % (mod - 1), mod) << '\n';
            }
//            for (int i = 0; i < k; ++i)std::cerr << getint(ans[i]) << '#' << getint(tmp[i]) << '*';
//            std::cerr << '\n';
            ans = ans * tmp;
            ans.modxk(k);
            if (n & 1) {
                tmp[0] = 0;
                for (int i = 1; i < k; i++) ans[i] = Z(1ll * getint(ans[i]) * power(2, i, mod) % mod);
                for (int i = 1; i < k; i++) tmp[i] = Z(inv[i].val());
//                for (int i = 0; i < k; ++i)std::cerr << getint(ans[i]) << '&' << getint(tmp[i]) << '%';
//                std::cerr << '\n';
                ans = ans * tmp;
                ans.modxk(k);
            }
            for (int i = 1; i <= k; ++i)ans[i] = Z(getint(ans[i]) % mod);
            return;
        };
        quick_pow(n, k + 1);
        Modular<mod> res = 0;
        for (int i = 1; i <= k; ++i)res += getint(ans[i]) * fact[k] * inv[k - i];
//        for (int i = 1; i <= k; ++i)std::cerr << getint(ans[i]) << ' ';
        std::cout << res << '\n';
    }
    return 0;
}

```

### 6.HDU4609 3-idiots

题意：给n根木棒，随机挑选三根不一样的木棍问能组成三角形的概率是多少。

题目分析：直接构造生成函数，然后进行卷积，再减掉重复的和选相同的情况就能得到两根不同的木棍所能满足的长度，但是这样之后还是不好算，那么考虑容斥，合法的方案就是所有的方案减去不合法的，对于两根木棍组成的长度，可以通过后缀和算出来不合法的情况，然后就结束了。

```c++
//
// Created by mrx on 2022/8/26.
//
#include <bits/stdc++.h>

using ll = long long;
using Z = std::complex<double>;
const double pi = std::acos(-1);
std::vector<int> rev;
std::vector<Z> roots{(0, 1), (0, 1)};

void dft(std::vector<Z> &a) {
    int n = a.size();

    if (int(rev.size()) != n) {
        rev.resize(n);
        for (int i = 0; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? n >> 1 : 0);
        }
    }

    for (int i = 0; i < n; ++i) {
        if (rev[i] < i)std::swap(a[i], a[rev[i]]);
    }
    if (int(roots.size() < n)) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
            Z e(cos(acos(-1) / (1 << k)), sin(acos(-1) / (1 << k)));
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[i << 1] = roots[i];
                roots[i << 1 | 1] = roots[i] * e;
            }
            k++;
        }
    }

    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}

void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
}

struct Poly {
    std::vector<Z> a;

    Poly() {}

    Poly(const std::vector<Z> &a) : a(a) {}

    Poly(const std::initializer_list<Z> &a) : a(a) {}

    int size() const {
        return a.size();
    }

    void resize(int n) {
        a.resize(n);
    }

    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }

    Z &operator[](int idx) {
        return a[idx];
    }

    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }

    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }

    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }

    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }

    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }

    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i];
            a.a[i] /= sz;
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }

    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < int(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }

    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }

    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }

    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }

    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }

};

void solve() {
    int n;
    std::cin >> n;
    std::vector<int> a(n);
    int mx = 0;
    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
        mx = std::max(mx, a[i]);
    }

    std::vector<int> cnt(mx + 1), sum(mx + 1);
    for (int i = 0; i < n; ++i)cnt[a[i]]++;
    sum[0] = cnt[0];
    for (int i = 1; i <= mx; ++i)sum[i] = sum[i - 1] + cnt[i];
    int sz = 1;
    while (sz < mx * 2 - 1) {
        sz *= 2;
    }
    std::vector<Z> num;
    num.resize(mx + 1);
    for (int i = 0; i <= mx; ++i) num[i].real(cnt[i]);
    num.resize(sz);
    dft(num);
    for (int i = 0; i < sz; ++i)num[i] = num[i] * num[i];
    for (int i = 0; i < sz; ++i)num[i] /= sz;
    idft(num);

    ll tot = 1ll * n * (n - 1) * (n - 2) / 6, legal = tot;

    for (int i = 2; i <= mx; ++i) {
        ll cur = ll(num[i].real() + 0.5);
        if (i % 2 == 0) cur -= cnt[i / 2];
        cur /= 2;
        legal -= cur * (n - sum[i - 1]);
    }

    std::cout << std::fixed << std::setprecision(7) << (double) legal / tot << std::endl;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int t = 1;
    std::cin >> t;
    while (t--)solve();
    return 0;
}
```

### 7.HDU6397Character Encoding

题意：给定m个值域在（0,n）的数字，问有多少种方案使得和为k。

一眼：$[x^k](1+x+x^2+x^3+...+x^n)^m$但是tmd太慢了，那么考虑生成函数，其收敛形式为$\frac{1}{1-x}$那么其为$(1-x)^{-m}$那么广义二项式定理直接轻松秒杀。

```c++
//
// Created by mrx on 2022/8/27.
//
#include <bits/stdc++.h>

using ll = long long;


template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, int b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    int val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

constexpr int mod = 998244353;
using Z = Modular<mod>;

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
#endif
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    std::vector<Z> fact(1e6 + 10), inv(1e6 + 10);
    fact[0] = inv[0] = 1;
    for (int i = 1; i <= 1e6; ++i) {
        fact[i] = fact[i - 1] * i;
        inv[i] = fact[i].inv();
    }
    auto C = [&](ll i, ll j) {
        if (j < i)return Z(0);
        return fact[j] * inv[i] * inv[j - i];
    };

    int t;
    std::cin >> t;
    while (t--) {
        ll n, m, k;
        std::cin >> n >> m >> k;
        Z tot = C(m - 1, m + k - 1);
        for (int i = 1; i * n <= k; ++i) {
            if (i & 1)tot -= C(i, m) * C(m - 1, m + k - 1 - i * n);
            else tot += C(i, m) * C(m - 1, m + k - 1 - i * n);
        }
        std::cout << tot << '\n';
    }
    return 0;
}
```

### 8.HDU7199 Find the Number of Paths

题意：给n+k个城市，i有n+k-i种方式到i+1，对于小于n的城市每个i到i-x都有$a_x$种方式，从k+1分别到k+1，k+2，k+3，….k+n的走过k条路的方案。

题目分析：

每个点重新标号，那么i到i-1有i条路。i到i+x有$a_x $种方式，然后考虑$dp[j][i]$为在从n-1到第i个城市 刚好经过j条路的方案数。$dp[i+1][j]=dp[i][j+1]*(j+1)+\sum dp_{x=0}^j[i][j-x]*a[x]$记$f_i(x)=\sum _{j=0}^{n+k+1}dp[i][j]x^j$

 $f_{i+1}(x)=f'_i(x)+A(x)*f_i(x)$那么构造$g(x)=e^{\int A(x)dx}=e^{\sum_{i=0}^{k} \frac{A[i]x^{i+1}}{i+1}}$,$p_i(x)=f(x)*g(x)$又因为$p(x)'=f'(x)g(x)+f(x)g'(x)=f'(x)g(x)+A(x)*g(x)*f(x)$那么$p_{i+1}(x)=g(x)f_{i+1}(x)=p'_{i+1}(x)$所以$p_k(x)=p_0^{(k)}(x)$同时，k阶导数可以on算，所以就把一个非常恶心的地推式简化了。

```c++
//
// Created by mrx on 2022/8/27.
//

#include <bits/stdc++.h>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = b / a;
        b -= t * a;
        std::swap(a, b);
        u -= t * v;
        std::swap(u, v);
    }
    assert(b == 1);
    return u;
}

template<typename T>
T power(T a, int b) {
    T ans = 1;
    for (; b; a *= a, b >>= 1) {
        if (b & 1)ans *= a;
    }
    return ans;
}

template<int Mod>
class Modular {
public:
    using Type = int;

    template<typename U>
    static Type norm(U &x) {
        Type v;
        if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % Mod);
        if (v < 0) v += Mod;
        return v;
    }

    constexpr Modular() : value() {}

    int val() const { return value; }

    Modular inv() const {
        return Modular(inverse(value, Mod));
    }

    template<typename U>
    Modular(const U &x) {
        value = norm(x);
    }

    const Type &operator()() const {
        return value;
    }

    template<typename U>
    explicit operator U() const {
        return static_cast<U>(value);
    }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= Mod) value -= Mod;
        return *this;
    }

    Modular &operator-=(
            const Modular &other) {
        if ((value -= other.value) < 0) value += Mod;
        return *this;
    }

    template<typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template<typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }

    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template<class ISTREAM_TYPE>
    friend ISTREAM_TYPE &operator>>(ISTREAM_TYPE &is, Modular &rhs) {
        ll v;
        is >> v;
        rhs = Modular(v);
        return is;
    }

    template<class OSTREAM_TYPE>
    friend OSTREAM_TYPE &operator<<(OSTREAM_TYPE &os, const Modular &rhs) {
        return os << rhs.val();
    }

    Modular &operator*=(const Modular &rhs) {
        value = ll(value) * rhs.value % Mod;
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, Mod)); }

    friend const Type &abs(const Modular &x) { return x.value; }

    friend bool operator==(const Modular &lhs, const Modular &rhs) { return lhs.x == rhs.x; }

    friend bool operator<(const Modular &lhs, const Modular &rhs) { return lhs.x < rhs.x; }


    bool operator==(const Modular &rhs) { return *this == rhs.value; }

    template<typename U>
    bool operator==(U rhs) { return *this == Modular(rhs); }

    template<typename U>
    friend bool operator==(U lhs, const Modular &rhs) { return Modular(lhs) == rhs; }

    bool operator!=(const Modular &rhs) { return *this != rhs; }

    template<typename U>
    bool operator!=(U rhs) { return *this != rhs; }

    template<typename U>
    friend bool operator!=(U lhs, const Modular &rhs) { return lhs != rhs; }

    bool operator<(const Modular &rhs) { return this->value < rhs.value; }

    Modular operator+(const Modular &rhs) { return Modular(*this) += rhs; }

    template<typename U>
    Modular operator+(U rhs) { return Modular(*this) += rhs; }

    template<typename U>
    friend Modular operator+(U lhs, const Modular &rhs) { return Modular(lhs) += rhs; }

    Modular operator-(const Modular &rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    Modular operator-(U rhs) { return Modular(*this) -= rhs; }

    template<typename U>
    friend Modular operator-(U lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }

    Modular operator*(const Modular &rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    Modular operator*(U rhs) { return Modular(*this) *= rhs; }

    template<typename U>
    friend Modular operator*(U lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }

    Modular operator/(const Modular &rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    Modular operator/(U rhs) { return Modular(*this) /= rhs; }

    template<typename U>
    friend Modular operator/(U lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }

private:
    Type value;
};

constexpr int mod = 998244353;
using Z = Modular<mod>;

std::vector<int> rev;
std::vector<Z> roots{0, 1};

void dft(std::vector<Z> &a) {
    int n = a.size();

    if (int(rev.size()) != n) {
        rev.resize(n);
        for (int i = 0; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? n >> 1 : 0);
        }
    }

    for (int i = 0; i < n; ++i) {
        if (rev[i] < i)std::swap(a[i], a[rev[i]]);
    }
    if (int(roots.size() < n)) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
            Z e = power(Z(3), (mod - 1) >> (k + 1));
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[i << 1] = roots[i];
                roots[i << 1 | 1] = roots[i] * e;
            }
            k++;
        }
    }

    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}

void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
}

struct Poly {
    std::vector<Z> a;

    Poly() {}

    Poly(const std::vector<Z> &a) : a(a) {}

    Poly(const std::initializer_list<Z> &a) : a(a) {}

    int size() const {
        return a.size();
    }

    void resize(int n) {
        a.resize(n);
    }

    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }

    Z &operator[](int idx) {
        return a[idx];
    }

    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }

    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }

    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }

    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }

    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }

    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        Z inv = Z(sz).inv();
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i] * inv;
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }

    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < int(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }

    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }

    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }

    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }

    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }

    Poly deriv() const {
        if (a.empty()) {
            return Poly();
        }
        std::vector<Z> res(size() - 1);
        for (int i = 0; i < size() - 1; ++i) {
            res[i] = (i + 1) * a[i + 1];
        }
        return Poly(res);
    }

    Poly integr() const {
        std::vector<Z> res(size() + 1);
        for (int i = 0; i < size(); ++i) {
            res[i + 1] = a[i] / (i + 1);
        }
        return Poly(res);
    }

    Poly inv(int m) const {
        Poly x{a[0].inv()};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{2} - modxk(k) * x)).modxk(k);
        }
        return x.modxk(m);
    }

    Poly log(int m) const {
        return (deriv() * inv(m)).integr().modxk(m);
    }

    Poly exp(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{1} - x.log(k) + modxk(k))).modxk(k);
        }
        return x.modxk(m);
    }

    Poly pow(int k, int m) const {
        int i = 0;
        while (i < size() && a[i].val() == 0) {
            i++;
        }
        if (i == size() || 1LL * i * k >= m) {
            return Poly(std::vector<Z>(m));
        }
        Z v = a[i];
        auto f = divxk(i) * v.inv();
        return (f.log(m - i * k) * k).exp(m - i * k).mulxk(i * k) * power(v, k);
    }

    Poly sqrt(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((mod + 1) / 2);
        }
        return x.modxk(m);
    }

    Poly mulT(Poly b) const {
        if (b.size() == 0) {
            return Poly();
        }
        int n = b.size();
        std::reverse(b.a.begin(), b.a.end());
        return ((*this) * b).divxk(n - 1);
    }

    std::vector<Z> eval(std::vector<Z> x) const {
        if (size() == 0) {
            return std::vector<Z>(x.size(), 0);
        }
        const int n = std::max(int(x.size()), size());
        std::vector<Poly> q(4 * n);
        std::vector<Z> ans(x.size());
        x.resize(n);
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                q[p] = Poly{1, -x[l]};
            } else {
                int m = (l + r) / 2;
                build(2 * p, l, m);
                build(2 * p + 1, m, r);
                q[p] = q[2 * p] * q[2 * p + 1];
            }
        };
        build(1, 0, n);
        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {
            if (r - l == 1) {
                if (l < int(ans.size())) {
                    ans[l] = num[0];
                }
            } else {
                int m = (l + r) / 2;
                work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l));
                work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m));
            }
        };
        work(1, 0, n, mulT(q[1].inv(n)));
        return ans;
    }
};


void solve() {

}

int main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    std::vector<Z> fact(4e5 + 10), inv(4e5 + 10);
    fact[0] = inv[0] = 1;
    for (int i = 1; i <= 4e5; ++i) {
        fact[i] = fact[i - 1] * i;
        inv[i] = fact[i].inv();
    }

    int t;
    std::cin >> t;
    while (t--) {
        int n, k;
        std::cin >> n >> k;
        std::vector<Z> a(n);
        for (int i = 1; i < n; ++i)std::cin >> a[i];
        Poly a_integer = Poly(a).integr();
        Poly g = a_integer.exp(k + 1);
        Poly h = g.inv(n);
        g = g.mulxk(n - 1);
        for (int i = k; i < n + k; ++i)g[i - k] = g[i] * fact[i] * inv[i - k];
        g = g.modxk(n);
        g *= h;
        for (int i = n - 1; i >= 0; --i)std::cout << g[i] << " \n"[i == 0];
    }
    return 0;
}
```





## 线性递推

### [1. Hardcore String Couting] (https://qoj.ac/contest/1356/problem/7187)

求长度为m的字符串只有最后n位为s，其他子串均不为s的方案数。

记答案为$ g(x) $, 没有任何子串为s的方案数为$ h(x) $, 那么有:


根据容斥可得

$ g(n) = h(n - m) -\sum\limits_{p \in border}g(n - m + |p|) $

以及

$ 26 * h(n - 1) - h(n) = s(n)$

那么考虑消去h

$ 26 \cdot g(n - 1) = 26 \cdot h(n - m - 1) - 26 \cdot \sum\limits_{p \in border}g(n - m + |p| - 1) $

与

$ g(n) = h(n - m) -\sum\limits_{p \in border}g(n - m + |p|) $

相减得:

$ 26 \cdot g(n-1) - g(n) = 26 \cdot h(n-m-1) - h(n-m)  - 26 \cdot  \sum\limits_{p \in border}g(n - m + |p| - 1) + \sum\limits_{p \in border}g(n - m + |p|)$

$ 26 \cdot g(n-1) - g(n) = g(n - m)  - 26 * \sum\limits_{p \in border}g(n - m + |p| - 1) + \sum\limits_{p \in border}g(n - m + |p|)$

那么

$ g(n) = 26 \cdot g(n - 1) - g(n - m) - \sum\limits_{p \in border}g(n - m + |p|) + 26 \cdot \sum\limits_{p \in border}g(n - m + |p| - 1)$

那么就可以进行常系数齐次线性递推

### [2.Long Grid Covering](https://codeforces.com/gym/103098/problem/L)

简单发现递推式的系数为{1,2,5,2,2,4,2,2,4,2,2,4,2,2,4.....}

化简成封闭形式 : 

$2x + 2x^2 + 4x^3 + x^3 F(x) =  F(x) $

$2x + 2x^2 + 4x^3 = (1 - x^3) F(x) $

$G(x) = \frac{2x + 2x^2 + 4x^3}{1 - x^3} - x + x^3$
$G(x) = \frac{1x + 2x^2 + 5x^3 + x^4 - x^6}{1 - x^3}$

化成递推式得到: $DP(x) = \frac{1} {1 - G(x)}$

$DP(x) = \frac{1} {\frac{1 - 1x - 2x^2 - 6x^3 - x^4 + x^6}{1 - x^3}}$

$DP(x) = \frac{1 - x^3} {1 - 1x - 2x^2 - 6x^3 - x^4 + x^6}$

那么其为P为{1,0,0,-1,0,0,0}，Q为{1,-1,-2,-6,-1,0,1}的线性递推，可以通过暴力卷积做出

```cpp

#include <bits/stdc++.h>

using i64 = long long;

constexpr int mod = 1e9 + 7;


using Poly  = std::vector<int>;

Poly operator*(const Poly a, const Poly b) {
    int n = a.size(), m = b.size();
    Poly c(n + m - 1, 0);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            c[i + j] = (c[i + j] + (1ll * a[i] * b[j]) % mod) % mod;
        }
    }
    return c;
}


int linearRecurrence(Poly p, Poly q, i64 n) {
    int m = q.size() - 1;
    while (n > 0) {
        auto newq = q;
        for (int i = 1; i <= m; i += 2) {
            newq[i] = mod - newq[i];
        }
		// 可以替换成为暴力卷积，复杂度变为 O(m^2 log(n))
        auto newp = p * newq;
        newq = q * newq;
        for (int i = 0; i < m; i++) {
            p[i] = newp[i * 2 + n % 2];
        }
        for (int i = 0; i <= m; i++) {
            q[i] = newq[i * 2];
        }
        n /= 2;
    }
    return p[0];
}


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);


	std::vector<int> y{1, 0, 0, mod - 1, 0, 0};
	std::vector<int> x{1, mod - 1, mod - 2, mod - 6, mod - 1, 0, 1};

    int t;
    std::cin >> t;
    while (t--) {
        i64 n;
        std::cin >> n;
        std::cout << linearRecurrence(y, x, n) << "\n";
    }

    return 0;
}

```




# 数据结构

## 字符串

## 01trie

### atc308G Minimum Xor Pair Query

**题意**

给一个可重集合,支持插入和删除,要求查询可重集合中任意两个元素的异或最小值

**分析**

使用01trie,如果一个节点下面的分支有两个以上的数字,那么这个节点的二进制贡献肯定是0,那么按照这个思想递归/dp就可以算出来全局的异或最小值了,然后插入和删除的时候都只会改变一条链上的dp值,可以做到log插入删除,$O(1)$查询

**代码**

```c++
#include <iostream>
#include <vector>
#include <map>
#include <numeric>
#include <algorithm>
#include <queue>
#include <array>
#include <bitset>
#include <string>

using i64 = long long;

int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};

struct trie {
    std::vector<std::array<int, 2>> nxt;
    std::vector<int> end, times;
    std::vector<int> dp;

    trie() {
        nxt.reserve(1000000);
        end.reserve(1000000);
        times.reserve(1000000);
        dp.reserve(1000000);
        dp.push_back(0);
        nxt.push_back(std::array<int, 2>{});
        end.push_back(0);
        times.push_back(0);
    }

    int NEW() {
        end.push_back(0);
        nxt.push_back(std::array<int, 2>{});
        times.push_back(0);
        dp.push_back(0);
        return end.size() - 1;
    }

    void update(int rt, int dep) {
        if (nxt[rt][0] == 0 && nxt[rt][1] == 0) {
            dp[rt] = 0;
        } else if (nxt[rt][0] == 0) {
            dp[rt] = dp[nxt[rt][1]] ^ (times[nxt[rt][1]] == 1 ? 1 << dep : 0);
        } else if (nxt[rt][1] == 0) {
            dp[rt] = dp[nxt[rt][0]];
        } else {
            if (times[nxt[rt][0]] == 1 && times[nxt[rt][1]] == 1) {
                dp[rt] = dp[nxt[rt][0]] ^ dp[nxt[rt][1]] ^ (1 << dep);
            } else {
                int res = 0x7fffffff;
                if (times[nxt[rt][0]] >= 2) {
                    res = std::min(res, dp[nxt[rt][0]]);
                } 
                if (times[nxt[rt][1]] >= 2){
                    res = std::min(res, dp[nxt[rt][1]]);
                }
                dp[rt] = res;
            }
        }
    }

    void insert(int rt, int idx, const std::string &s) {
        if (idx == s.length()) {
            times[rt]++;
            dp[rt] = 0;
            return;
        }
        int c = s[idx] - '0';
        if (nxt[rt][c] == 0) {
            nxt[rt][c] = NEW();
        }
        times[rt] -= times[nxt[rt][c]];
        insert(nxt[rt][c], idx + 1, s);
        update(rt, 30 - idx);
        times[rt] += times[nxt[rt][c]];
    }

    void erase(int rt, int idx, const std::string &s) {
        if (idx == s.length()) {
            times[rt]--;
            return;
        }

        int c = s[idx] - '0';
        if (nxt[rt][c] != 0) {
            times[rt] -= times[nxt[rt][c]];
            erase(nxt[rt][c], idx + 1, s);
            if (times[nxt[rt][c]] == 0) {
                nxt[rt][c] = 0;
            }
            update(rt, 30 - idx);
            times[rt] += times[nxt[rt][c]];
        }
    }

    int query(int rt){
        return dp[rt];
    }
};


void solve() {
    int q;
    std::cin >> q;

    trie T;
    while (q--) {
        int op;
        std::cin >> op;
        if (op == 1) {
            int x;
            std::cin >> x;
            std::bitset<31> bs(x);
            std::string s = bs.to_string();
            T.insert(0, 0, s);
        } else if (op == 2) {
            int x;
            std::cin >> x;
            std::bitset<31> bs(x);
            std::string s = bs.to_string();
            T.erase(0, 0, s);
        } else {
            std::cout << T.query(0) << "\n";
        }
    }
} 

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    solve();

    return 0;
}

```





# 计算几何

## 二维几何

### 鸡脚排序

#### 1.P2924 Largest Fence G

**题目描述**

Farmer John的农场里有N（5<=N<=250）个篱笆桩，每个都有独一无二的坐标(xi,yi)（1<=xi,yi<=1000）。他想选择尽量多的篱笆桩来构建他的围栏。这个围栏要美观，所以必须是凸多边形的。那他最多能选多少个呢？

所有的篱笆桩中不存在三点共线。

**题目分析**

根据凸包的性质可以知道，凸包的所有边拉出来都是按照极角序有单调性的，那么枚举所有的起点，进行一下对于所有可能边的dp就行了

**代码**

```c++
//
// Created by mrx on 2022/11/7.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>

using i64 = long long;
constexpr double eps = 1e-6;

int sgn(double x) {
	return x < -eps ? -1 : x > eps;
}

int sgn(i64 x) {
	return x < 0 ? -1 : x > 0;
}

template<typename T>
struct Point {
	T x, y;

	template<class Y>
	Point(const Point<Y>& cp):x(cp.x), y(cp.y) {}

	Point() : x(0), y(0) {}

	Point(T _x, T _y) : x(_x), y(_y) {}

	friend std::istream& operator >>(std::istream& is, Point& rhs) { return is >> rhs.x >> rhs.y; }

	friend std::ostream& operator <<(std::ostream& os, const Point& rhs) { return os << '(' << rhs.x << ',' << rhs.y << ')'; }

	Point operator -(const Point& rhs) const { return {x - rhs.x, y - rhs.y}; }

	Point& operator -=(const Point& rhs) { return (*this) = (*this) - rhs; }

	Point operator +(const Point& rhs) const { return {x + rhs.x, y + rhs.y}; }

	Point& operator +=(const Point& rhs) { return (*this) = (*this) + rhs; }

	template<class Y>
	Point<double> operator *(const Y& rhs) const { return {x * rhs, y * rhs}; }

	template<class Y>
	Point<double> operator /(const Y& rhs) { return {x / rhs, y / rhs}; }

	friend double abs(const Point& lhs) { return std::sqrt(lhs.x * lhs.x + lhs.y * lhs.y); }

	friend i64 abs2(const Point& lhs) { return (lhs.x * lhs.x + lhs.y * lhs.y); }

	friend T cross(const Point& lhs, const Point& rhs) { return lhs.x * rhs.y - lhs.y * rhs.x; }

	friend T dot(const Point& lhs, const Point& rhs) { return lhs.x * rhs.x + lhs.y * rhs.y; }

	friend double angle(const Point& rhs) { return atan2(rhs.x, rhs.y); }

	Point rotate90() const { return {y, x}; }

	Point<double> rotate(double deg) { return {x * cos(deg) - y * sin(deg), x * sin(deg) + y * cos(deg)}; }

	bool operator <(const Point& rhs) const { return sgn(x - rhs.x) == 0 ? sgn(y - rhs.y) < 0 : sgn(x - rhs.x) < 0; }

	bool operator ==(const Point& rhs) const { return sgn(x - rhs.x) == 0 && sgn(y - rhs.y) == 0; }

	bool up() const { return sgn(y) == 0 ? sgn(x) >= 0 : sgn(y) > 0; }
};

using Pl = Point<i64>;

std::vector<Pl> ConvexHull(std::vector<Pl> points) {
	int n = points.size();
	std::sort(points.begin(), points.end());
	for (auto x: points)std::cout << x << '\n';
	std::deque<Pl> dq;

	for (auto& point: points) {
		while (dq.size() > 1 && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], point - dq[dq.size() - 2])) < 0)dq.pop_back();
		dq.push_back(point);
	}
	for (auto x: dq)std::cerr << x << '\n';

	int k = int(dq.size());
	for (int i = n - 1; i >= 0; i--) {
		while (dq.size() > k && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], points[i] - dq[dq.size() - 2])) < 0)dq.pop_back();
		dq.push_back(points[i]);
	}

	std::vector<Pl> ans(dq.begin(), dq.end());
	return ans;
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n;
	std::cin >> n;
	std::vector<Pl> points(n);
	for (int i = 0; i < n; ++i)std::cin >> points[i];

	std::vector<std::pair<int, int>> e;
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			if (i == j)continue;
			e.emplace_back(i, j);
		}
	}

	std::sort(e.begin(), e.end(), [&](auto x, auto y) {
		Pl v1 = points[x.first] - points[x.second];
		Pl v2 = points[y.first] - points[y.second];
		return v1.up() ^ v2.up() ? v1.up() > v2.up() : cross(v1, v2) < 0;
	});
//	for (auto x: e)std::cout << points[x.first] - points[x.second] << '\n';

	int ans = 0;

	for (int i = 0; i < n; ++i) {

		std::vector<int> dp(n, -0x3f3f3f3f);
		dp[i] = 0;
		for (auto [l, r]: e) {
			dp[r] = std::max(dp[r], dp[l] + 1);
//			std::cerr << l << ' ' << r << ' ' << dp[r] << '\n';
		}
//		std::cerr << "!!!!" << dp[i] << '\n';
		ans = std::max(ans, dp[i]);
	}

	std::cout << ans << '\n';

	return 0;
}
```



### 点线

#### 1.2018CCPC Guilin L Tow Ants

**题意**

给一条白线和一条黑线，求无限大的平面区域中白线能被看到的范围

**题解**

分类讨论即可

**代码**

```c++
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>
#include <set>
#include <iomanip>
#include <cassert>

using i64 = long long;

constexpr double eps = 1e-6;

template<typename T>
int sgn(T x) {
	return x < -eps ? -1 : x > eps;
}

int sgn(i64 x) {
	return x < 0 ? -1 : x > 0;
}

template<typename T>
struct Point {
	T x, y;

	template<class Y>
	Point(const Point<Y>& cp):x(cp.x), y(cp.y) {}

	Point() : x(0), y(0) {}

	Point(T _x, T _y) : x(_x), y(_y) {}

	friend std::istream& operator >>(std::istream& is, Point& rhs) { return is >> rhs.x >> rhs.y; }

	friend std::ostream& operator <<(std::ostream& os, const Point& rhs) { return os << '(' << rhs.x << ',' << rhs.y << ')'; }

	Point operator -(const Point& rhs) const { return {x - rhs.x, y - rhs.y}; }

	Point& operator -=(const Point& rhs) { return (*this) = (*this) - rhs; }

	Point operator +(const Point& rhs) const { return {x + rhs.x, y + rhs.y}; }

	Point& operator +=(const Point& rhs) { return (*this) = (*this) + rhs; }

	template<class Y>
	Point<double> operator *(const Y& rhs) const { return {x * rhs, y * rhs}; }

	template<class Y>
	Point<double> operator /(const Y& rhs) { return {x / rhs, y / rhs}; }

	friend double abs(const Point& lhs) { return std::sqrt(lhs.x * lhs.x + lhs.y * lhs.y); }

	friend i64 abs2(const Point& lhs) { return (lhs.x * lhs.x + lhs.y * lhs.y); }

	friend T cross(const Point& lhs, const Point& rhs) { return lhs.x * rhs.y - lhs.y * rhs.x; }

	friend T dot(const Point& lhs, const Point& rhs) { return lhs.x * rhs.x + lhs.y * rhs.y; }

	friend double angle(const Point& rhs) { return atan2(rhs.x, rhs.y); }

	Point rotate90() const { return {y, x}; }

	Point<double> rotate(double deg) { return {x * cos(deg) - y * sin(deg), x * sin(deg) + y * cos(deg)}; }

	bool operator <(const Point& rhs) const { return sgn(x - rhs.x) == 0 ? sgn(y - rhs.y) < 0 : sgn(x - rhs.x) < 0; }

	bool operator ==(const Point& rhs) const { return sgn(x - rhs.x) == 0 && sgn(y - rhs.y) == 0; }

	bool up() const { return sgn(y) == 0 ? sgn(x) >= 0 : sgn(y) > 0; }
};

using Pl = Point<i64>;
using Pd = Point<double>;

template<class T>
struct Line {
	Point<T> a, b;

	Line(Point<T> a, Point<T> b) : a(a), b(b) {}

	Line() {}

	Point<T> vec() const {
		return b - a;
	}
};

using P = Point<int>;
using L = Line<int>;

int toLeft(const P& p, const L& l) {
	return sgn(cross(p - l.a, l.vec()));
}

bool onLine(const P& p, const L& l) {
	return cross(p - l.a, l.vec()) == 0 && dot(p - l.a, p - l.b) <= 0;
}

Point<double> db(P x) {
	return Point<double>(x.x, x.y);
}

Point<double> intersection(const L& l1, const L& l2) {
	Line<double> p1, p2;
	p1.a = db(l1.a);
	p1.b = db(l1.b);
	p2.a = db(l2.a);
	p2.b = db(l2.b);
	return p1.a + p1.vec() * (cross(p2.a - p1.a, p2.vec()) / cross(p1.vec(), p2.vec()));
}

bool work(L w, L b) {
	L r1(w.a, b.a);
	L r2(w.b, b.b);

	if (cross(r1.vec(), r2.vec()) == 0) {
		std::cout << "inf\n";
		return true;
	}

	if (toLeft(r1.a, r2) * toLeft(r1.b, r2) < 0 && toLeft(r2.a, r1) * toLeft(r2.b, r1) < 0) {
		return false;
	}

	auto inter = intersection(r1, r2);

	if (std::abs(inter.x - w.a.x) <= std::abs(inter.x - b.a.x)) {
		std::cout << std::abs(cross(inter - db(w.a), inter - db(w.b))) / 2 << "\n";
	} else {
		std::cout << "inf\n";
	}
	return true;
}

void solve() {
	L w, b;
	std::cin >> w.a >> w.b >> b.a >> b.b;

	if (cross(w.vec(), b.vec()) == 0 && cross(w.vec(), b.a - w.a) == 0) {
		std::cout << "0\n";
		return;
	}

	if (toLeft(w.a, b) * toLeft(w.b, b) < 0 && toLeft(b.a, w) * toLeft(b.b, w) < 0) {
		std::cout << "0\n";
		return;
	}

	if (std::set{w.a, w.b, b.a, b.b}.size() == 3) {
		std::cout << "inf\n";
		return;
	}

	if (onLine(b.a, w) || onLine(b.b, w)) {
		std::cout << "inf\n";
		return;
	}

	if (onLine(w.a, b) || onLine(w.b, b)) {
		std::cout << "0\n";
		return;
	}

	if (toLeft(b.a, w) * toLeft(b.b, w) < 0) {
		std::cout << "0\n";
		return;
	}

	if (toLeft(w.a, b) * toLeft(w.b, b) < 0) {
		std::cout << "inf\n";
		return;
	}

	if (!work(w, b)) {
		std::swap(w.a, w.b);
		assert(work(w, b));
	}
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	int t;
	std::cin >> t;

	std::cout << std::fixed << std::setprecision(12);
	for (int i = 1; i <= t; ++i) {
		std::cout << "Case " << i << ": ";
		solve();
	}

	return 0;
}
```



### 凸包

#### 1.UVA10652 Board Wrapping

**题目描述**

有 $n$ 个矩形木条，你需要用一个面积尽可能小的凸多边形把它们围起来，并计算出木条占整个包装面积的百分比。

**题目分析**

通过旋转公式求出来所有矩形的顶点，然后通过这个求出来凸包，这个凸包就是围起来的最小多边形。直接算两个的面积就行。

**代码**

```c++
//
// Created by mrx on 2022/10/30.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>
#include <iomanip>

using i64 = long long;

constexpr double eps = 1e-6;

template<typename T>
int sgn(T x) {
	return std::abs(x) < eps ? 0 : x < 0 ? -1 : 1;
}

template<typename T>
struct Point {
	T x, y;

	Point(T x, T y) : x(x), y(y) {}

	template<class Y>
	Point(const Point<Y>& cp):x(cp.x), y(cp.y) {}

	Point() : x(0), y(0) {}

	friend std::istream& operator >>(std::istream& is, Point& rhs) {
		return is >> rhs.x >> rhs.y;
	}

	friend std::ostream& operator <<(std::ostream& os, const Point& rhs) {
		return os << rhs.x << ' ' << rhs.y;
	}

	Point& operator +=(const Point& rhs) {
		x += rhs.x;
		y += rhs.y;
		return *this;
	}

	Point operator +(const Point& rhs) const {
		Point ans(*this);
		return ans += rhs;
	}

	Point& operator -=(const Point& rhs) {
		x -= rhs.x;
		y -= rhs.y;
		return *this;
	}

	Point operator -(const Point& rhs) const {
		Point ans(*this);
		return ans -= rhs;
	}

	template<class Y>
	Point<Y> operator *(const Y& rhs) const {
		return Point<Y>(x * rhs, y * rhs);
	}

	template<class Y>
	Point<Y> operator /(const Y& rhs) {
		return Point<Y>(x / rhs, y / rhs);
	}

	Point rotate90() const {
		return {y, x};
	}

	Point<double> rotate(double deg) {
		return {x * cos(deg) - y * sin(deg), x * sin(deg) + y * cos(deg)};
	}

	friend double abs(const Point& lhs) {
		return std::sqrt(lhs.x * lhs.x + lhs.y * lhs.y);
	}

	friend T cross(const Point& lhs, const Point& rhs) {
		return lhs.x * rhs.y - lhs.y * rhs.x;
	}

	friend T dot(const Point& lhs, const Point& rhs) {
		return lhs.x * rhs.x + lhs.y * rhs.y;
	}

	bool operator <(const Point& rhs) const {
		return x == rhs.x ? y < rhs.y : x < rhs.x;
	}

	friend double angle(const Point& rhs) {
		return atan2(rhs.x, rhs.y);
	}

	bool operator ==(const Point& rhs) const {
		return std::abs(x - rhs.x) <= eps && std::abs(y - rhs.y) <= eps;
	}
};

template<typename T>
Point<long double> Rotate(Point<T> a, double deg) { return {a.x * cos(deg) - a.y * sin(deg), a.x * sin(deg) + a.y * cos(deg)}; }

using Pl = Point<i64>;
using Pd = Point<double>;

template<typename T>
struct Line {
	Point<T> a, v;

	Line(const Point<T>& a, const Point<T>& b) : a(a), v(b - a) {}

	template<class Y>
	Line(const Point<Y>& cp) : a(cp.a), v(cp.v) {}

	Pd point(double t) {
		return a + v * t;
	}

	friend Point<long double> intersection(const Line<T> lhs, const Line<T> rhs) {
		long double t = (long double) cross(rhs.a - lhs.a, rhs.v) / cross(lhs.v, rhs.v);
		return lhs.v * t + Point<double>(lhs.a);
	}

	double dis(const Point<T>& rhs) {
		return std::abs(cross(rhs - a, v)) / v.abs();
	}

	Line rotate(double deg) {
		Line<long double> ans(*this);
		ans.v = Rotate(v, deg);
		return ans;
	}
};

using Pd = Point<double>;
using Ld = Line<double>;

bool isCross(Pd a, Pd b, Pd i, Pd j) {
	return sgn(cross(i - a, j - i)) * sgn(cross(i - b, j - i)) == -1 && sgn(cross(b - i, a - b)) * sgn(cross(b - j, a - b)) == -1;
}

bool onSeg(Pd a, Pd i, Pd j) {
	return sgn(cross(i - a, j - a)) == 0 && sgn(dot(a - i, a - j)) < 0;
}

int dx[] = {1, 1, -1, -1};
int dy[] = {1, -1, 1, -1};

std::vector<Pd> ConvexHull(std::vector<Pd> points) {
	int n = points.size();
	std::sort(points.begin(), points.end());
	std::deque<Pd> dq;

	for (auto& point: points) {
		while (dq.size() > 1 && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], point - dq[dq.size() - 2])) <= 0)dq.pop_back();
		dq.push_back(point);
	}

	int k = int(dq.size());
	for (int i = n - 1; i >= 0; i--) {
		while (dq.size() > k && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], points[i] - dq[dq.size() - 2])) <= 0)dq.pop_back();
		dq.push_back(points[i]);
	}

	std::vector<Pd> ans(dq.begin(), dq.end());
	return ans;
}

void sol() {
	int n;
	std::cin >> n;

	std::vector<Pd> points;
	double fz = 0;
	for (int i = 0; i < n; ++i) {
		double x, y, w, h, phi;
		std::cin >> x >> y >> w >> h >> phi;
		fz += w * h;
		Pd cent(x, y);
		for (int j = 0; j < 4; ++j) {
			Pd vertex = cent + Pd(w / 2 * dx[j], h / 2 * dy[j]).rotate(-phi / 180 * acos(-1));
			points.push_back(vertex);
		}
	}

//	for (auto x: points)std::cout << x << '\n';
	std::vector<Pd> convexHull = ConvexHull(points);
	int m = convexHull.size();
//	for (auto x: convexHull)std::cout << x << '\n';
	double fm = 0;
	for (int i = 0; i < m; ++i) {
		fm -= cross(convexHull[i] - convexHull[(i + m - 1) % m], convexHull[i] - Pd(0, 0)) / 2;
	}
//	std::cerr << fz << ' ' << fm << '\n';
//	std::cerr << fz / fm << '\n';
	double ans = fz / fm * 100;
	std::cout << std::fixed << std::setprecision(1)<<ans<<" %\n";
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);
	int t;
	std::cin >> t;
	while (t--) {
		sol();
	}
	return 0;
}
```



#### 2.UVA11168 Airport

**题目描述**

平面上有$n$个点，求一条直线，使得这$n$个点都在这条直线上或同侧，且每个点到该直线的距离之和尽量小。

**题目分析**

在一条直线同侧或者在这条直线上，显然这条直线不能穿过凸包，随便一想，都感觉最优秀的直线肯定是在这个凸包上的。那么直接暴力求出来每个点到这条直线的距离就行了。有一种非常牛逼的方式来计算这$n$个点到一条直线的距离。对于每一个点，它到$Ax + By + C = 0$这条直线的距离是$\frac{\abs{Ax_0+ By_0+C}}{\sqrt{A^2 + B^2}}$，通过分析这个公式怎么得到的， 可以发现，如果所有点都在直线的同一侧，那么计算每个点距离的时候这个公式中绝对值内的部分都是同号的，这样就可以把$x,y$都求和，直接$O(1)$计算这$n$个点到一条直线的距离了。最后一点就是如何把两点式变成一般柿，这个初中数学一下就行了。

**代码**

```c++
//
// Created by mrx on 2022/10/31.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>
#include <iomanip>

using i64 = long long;


constexpr double eps = 1e-6;

template<typename T>
int sgn(T x) {
	return std::abs(x) < eps ? 0 : x < 0 ? -1 : 1;
}

template<typename T>
struct Point {
	T x, y;

	Point(T x, T y) : x(x), y(y) {}

	template<class Y>
	Point(const Point<Y>& cp):x(cp.x), y(cp.y) {}

	Point() : x(0), y(0) {}

	friend std::istream& operator >>(std::istream& is, Point& rhs) {
		return is >> rhs.x >> rhs.y;
	}

	friend std::ostream& operator <<(std::ostream& os, const Point& rhs) {
		return os << rhs.x << ' ' << rhs.y;
	}

	Point& operator +=(const Point& rhs) {
		x += rhs.x;
		y += rhs.y;
		return *this;
	}

	Point operator +(const Point& rhs) const {
		Point ans(*this);
		return ans += rhs;
	}

	Point& operator -=(const Point& rhs) {
		x -= rhs.x;
		y -= rhs.y;
		return *this;
	}

	Point operator -(const Point& rhs) const {
		Point ans(*this);
		return ans -= rhs;
	}

	template<class Y>
	Point<Y> operator *(const Y& rhs) const {
		return Point<Y>(x * rhs, y * rhs);
	}

	template<class Y>
	Point<Y> operator /(const Y& rhs) {
		return Point<Y>(x / rhs, y / rhs);
	}

	Point rotate90() const {
		return {y, x};
	}

	Point<double> rotate(double deg) {
		return {x * cos(deg) - y * sin(deg), x * sin(deg) + y * cos(deg)};
	}

	friend double abs(const Point& lhs) {
		return std::sqrt(lhs.x * lhs.x + lhs.y * lhs.y);
	}

	friend T cross(const Point& lhs, const Point& rhs) {
		return lhs.x * rhs.y - lhs.y * rhs.x;
	}

	friend T dot(const Point& lhs, const Point& rhs) {
		return lhs.x * rhs.x + lhs.y * rhs.y;
	}

	bool operator <(const Point& rhs) const {
		return x == rhs.x ? y < rhs.y : x < rhs.x;
	}

	friend double angle(const Point& rhs) {
		return atan2(rhs.x, rhs.y);
	}

	bool operator ==(const Point& rhs) const {
		return std::abs(x - rhs.x) <= eps && std::abs(y - rhs.y) <= eps;
	}
};

template<typename T>
Point<long double> Rotate(Point<T> a, double deg) { return {a.x * cos(deg) - a.y * sin(deg), a.x * sin(deg) + a.y * cos(deg)}; }

using Pl = Point<i64>;
using Pd = Point<double>;

template<typename T>
struct Line {
	Point<T> a, v;

	Line(const Point<T>& a, const Point<T>& b) : a(a), v(b - a) {}

	template<class Y>
	Line(const Point<Y>& cp) : a(cp.a), v(cp.v) {}

	Pd point(double t) {
		return a + v * t;
	}

	friend Point<long double> intersection(const Line<T> lhs, const Line<T> rhs) {
		long double t = (long double) cross(rhs.a - lhs.a, rhs.v) / cross(lhs.v, rhs.v);
		return lhs.v * t + Point<double>(lhs.a);
	}

	double dis(const Point<T>& rhs) {
		return std::abs(cross(rhs - a, v)) / v.abs();
	}

	Line rotate(double deg) {
		Line<long double> ans(*this);
		ans.v = Rotate(v, deg);
		return ans;
	}
};

using Ll = Line<i64>;
using Ld = Line<double>;

bool isCross(Pd a, Pd b, Pd i, Pd j) {
	return sgn(cross(i - a, j - i)) * sgn(cross(i - b, j - i)) == -1 && sgn(cross(b - i, a - b)) * sgn(cross(b - j, a - b)) == -1;
}

bool onSeg(Pd a, Pd i, Pd j) {
	return sgn(cross(i - a, j - a)) == 0 && sgn(dot(a - i, a - j)) < 0;
}

std::vector<Pl> ConvexHull(std::vector<Pl> points) {
	int n = points.size();
	std::sort(points.begin(), points.end());
	std::deque<Pl> dq;

	for (auto& point: points) {
		while (dq.size() > 1 && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], point - dq[dq.size() - 2])) <= 0)dq.pop_back();
		dq.push_back(point);
	}

	int k = int(dq.size());
	for (int i = n - 1; i >= 0; i--) {
		while (dq.size() > k && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], points[i] - dq[dq.size() - 2])) <= 0)dq.pop_back();
		dq.push_back(points[i]);
	}

	std::vector<Pl> ans(dq.begin(), dq.end());
	return ans;
}

std::array<i64, 3> getNorm(Ll l) {
	return {l.v.y, -l.v.x, -l.a.x * l.v.y + l.v.x * l.a.y};
}

void sol() {
	int n;
	std::cin >> n;
	std::vector<Pl> points(n);
	for (int i = 0; i < n; ++i)std::cin >> points[i];
	i64 sumX = 0, sumY = 0;
	for (int i = 0; i < n; ++i) {
		sumX += points[i].x;
		sumY += points[i].y;
	}

	if (n > 1) {
		std::vector<Pl> hull = ConvexHull(points);
//	for (auto x: hull)std::cerr << x << '\n';

		double ans = 2e18;
		int m = hull.size();
		for (int i = 1; i < m; ++i) {
//		std::cerr << hull[i - 1] << ' ' << hull[i] << '\n';
			Ll line(hull[i - 1], hull[i]);
			auto coefficient = getNorm(line);
			double fm = abs(Pl(coefficient[0], coefficient[1]));
//		for (auto x: coefficient)std::cerr << x << ' ';
//		std::cerr << '\n';
			i64 fz = std::abs(coefficient[0] * sumX + coefficient[1] * sumY + n * coefficient[2]);
			ans = std::min(ans, fz / fm);
		}

		std::cout << std::fixed << std::setprecision(3) << ans / n << '\n';
	} else std::cout << "0.000\n";
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);
	int t;
	std::cin >> t;
	for (int cas = 1; cas <= t; ++cas) {
		std::cout << "Case #" << cas << ": ";
		sol();
	}
	return 0;
}
```

#### 3.P3829信用卡凸包

**题目描述**

给若干个信用卡，信用卡的四个角都是圆角，用一根线给所有信用卡围起来要的最小长度

**题目分析**

因为给定的信用卡圆角半径都是相同的，那么整个图形最后圆转过的角度肯定是$360^o$其只要强制把圆角切除，然后求凸包，最后再加上一个圆角的周长即可。

**代码**

```c++
//
// Created by mrx on 2022/11/7.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <array>
#include <map>
#include <iomanip>

using i64 = long long;
constexpr double eps = 1e-9;

template<typename T>
int sgn(T x) {
	return x < -eps ? -1 : x > eps;
}

//int sgn(i64 x) {
//	return x < 0 ? -1 : x > 0;
//}

template<typename T>
struct Point {
	T x, y;

	template<class Y>
	Point(const Point<Y>& cp):x(cp.x), y(cp.y) {}

	Point() : x(0), y(0) {}

	Point(T _x, T _y) : x(_x), y(_y) {}

	friend std::istream& operator >>(std::istream& is, Point& rhs) { return is >> rhs.x >> rhs.y; }

	friend std::ostream& operator <<(std::ostream& os, const Point& rhs) { return os << '(' << rhs.x << ',' << rhs.y << ')'; }

	Point operator -(const Point& rhs) const { return {x - rhs.x, y - rhs.y}; }

	Point& operator -=(const Point& rhs) { return (*this) = (*this) - rhs; }

	Point operator +(const Point& rhs) const { return {x + rhs.x, y + rhs.y}; }

	Point& operator +=(const Point& rhs) { return (*this) = (*this) + rhs; }

	template<class Y>
	Point<double> operator *(const Y& rhs) const { return {x * rhs, y * rhs}; }

	template<class Y>
	Point<double> operator /(const Y& rhs) { return {x / rhs, y / rhs}; }

	friend double abs(const Point& lhs) { return std::sqrt(lhs.x * lhs.x + lhs.y * lhs.y); }

	friend i64 abs2(const Point& lhs) { return (lhs.x * lhs.x + lhs.y * lhs.y); }

	friend T cross(const Point& lhs, const Point& rhs) { return lhs.x * rhs.y - lhs.y * rhs.x; }

	friend T dot(const Point& lhs, const Point& rhs) { return lhs.x * rhs.x + lhs.y * rhs.y; }

	friend double angle(const Point& rhs) { return atan2(rhs.x, rhs.y); }

	Point rotate90() const { return {y, x}; }

	Point<long double> rotate(double deg) { return {x * cos(deg) - y * sin(deg), x * sin(deg) + y * cos(deg)}; }

	bool operator <(const Point& rhs) const { return sgn(x - rhs.x) == 0 ? sgn(y - rhs.y) < 0 : sgn(x - rhs.x) < 0; }

	bool operator ==(const Point& rhs) const { return sgn(x - rhs.x) == 0 && sgn(y - rhs.y) == 0; }

	bool up() const { return sgn(y) == 0 ? sgn(x) >= 0 : sgn(y) > 0; }
};

using Pl = Point<i64>;
using Pd = Point<long double>;

template<typename T>
struct Line {
	Point<T> a, v;

	Line(const Point<T>& a, const Point<T>& b) : a(a), v(b - a) {}

	template<class Y>
	Line(const Point<Y>& cp) : a(cp.a), v(cp.v) {}

	Pd point(double t) {
		return a + v * t;
	}

	friend Point<long double> intersection(const Line<T> lhs, const Line<T> rhs) {
		long double t = (long double) cross(rhs.a - lhs.a, rhs.v) / cross(lhs.v, rhs.v);
		return lhs.v * t + Point<double>(lhs.a);
	}

	double dis(const Point<T>& rhs) {
		return std::abs(cross(rhs - a, v)) / v.abs();
	}

	Line rotate(double deg) {
		Line<long double> ans(*this);
		ans.v = Rotate(v, deg);
		return ans;
	}
};


bool isCross(Pd a, Pd b, Pd i, Pd j) {
	return sgn(cross(i - a, j - i)) * sgn(cross(i - b, j - i)) == -1 && sgn(cross(b - i, a - b)) * sgn(cross(b - j, a - b)) == -1;
}

bool onSeg(Pd a, Pd i, Pd j) {
	return sgn(cross(i - a, j - a)) == 0 && sgn(dot(a - i, a - j)) < 0;
}

std::vector<Pd> ConvexHull(std::vector<Pd> points) {
	std::sort(points.begin(), points.end());
	points.erase(std::unique(points.begin(), points.end()), points.end());

	int n = points.size();
	std::deque<Pd> dq;

	for (auto& point: points) {
		while (dq.size() > 1 && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], point - dq[dq.size() - 2])) <= 0)dq.pop_back();
		dq.push_back(point);
	}

	int k = int(dq.size());
	for (int i = n - 1; i >= 0; i--) {
		while (dq.size() > k && sgn(cross(dq[dq.size() - 1] - dq[dq.size() - 2], points[i] - dq[dq.size() - 2])) <= 0)dq.pop_back();
		dq.push_back(points[i]);
	}

	std::vector<Pd> ans(dq.begin(), dq.end());
	return ans;
}

int dx[] = {1, 1, -1, -1};
int dy[] = {1, -1, 1, -1};

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n;
	std::cin >> n;
	long double a, b, r;
	std::cin >> b >> a >> r;
	a /= 2, b /= 2;
	a -= r, b -= r;

	std::vector<Pd> points;
	for (int i = 0; i < n; ++i) {
		long double x, y, theta;
		std::cin >> x >> y >> theta;
		Pd center(x, y);
		for (int j = 0; j < 4; ++j) {
			Pd dxy = {a * dx[j], b * dy[j]};
			points.push_back(center + dxy.rotate(theta));
		}
	}

	auto rem = ConvexHull(points);
	long double ans = 0;
	for (int i = 1; i < rem.size(); ++i) {
		ans += abs(rem[i] - rem[i - 1]);
	}

	ans += 2 * r * acos(-1);

	std::cout << std::fixed << std::setprecision(2) << ans << '\n';
	return 0;
}
```





### 半平面交

#### 1.2018wf Panda Preserve

**题意**

给一个多边形在每个顶点画半径为r的圆，求覆盖整个多边形的最小半径。

**分析**

一开始看到很容易去想到二分+圆并，蛋感觉不好写，然后灵机一动把问题转化为：记多边形内的点，这个点到所有的顶点中距离的最小值为w(p),求对于所有p的max(w(p))。那么很容易想到，这个多边形可以被划分为若干个区域，每个区域中的任意一个点p到一个顶点q的距离为 w(p)。那么模拟一下题目发现，如果某个点到的最近点是顶点e，那么这个点肯定在e到与所有点的垂直平分线划分出来的靠e这侧的半平面的半平面交中。

那么对于每个顶点$E$去算其对于其他顶点的垂直平分线的半平面交，这个复杂度是 $O(n^2log (n)) $，算出半平面交之求解这个既半平面交也在多边形里的点到这个顶点$E$的最大距离。随便画个图可以发现其可能为半平面交的顶点和半平面交的边与多边形的边的交点到这个顶点$E$的距离。

学术上，这些垂直平分线构成的图叫Voronoi图，这个图的边数量是$O(n)$的所以枚举v图和多边形边的交点是$O(n^2)$的，所以总的时间复杂度是$O(n^2log(n))$的。

notice：判断点在多边形内的时候如果采用从p出发的一条直线经过几条边的话一定要注意这条“直线” 要足够长，本人因为这个wa了半年。

 ```c++
 #include <vector>
 #include <algorithm>
 #include <iostream>
 #include <array>
 #include <numeric>
 #include <cmath>
 #include <functional>
 #include <queue>
 #include <complex>
 #include <iomanip>
 #include <cassert>
 
 using ll = long long;
 using T = double;
 constexpr double eps = 1e-5;
 
 using Point = std::complex<T>;
 #define x real
 #define y imag
 
 T dot(const Point& a, const Point& b) {
 	return (std::conj(a) * b).x();
 }
 
 T cross(const Point& a, const Point& b) {
 	return (std::conj(a) * b).y();
 }
 
 struct Line {
 	Point a;
 	Point b;
 
 	Line(const Point& a, const Point& b) : a(a), b(b) {}
 };
 
 Point rotate(const Point& a) {
 	return Point(-a.y(), a.x());
 }
 
 
 Point Norm(const Point& a) {
 	auto tmp = a / abs(a);
 	tmp *= 10000;
 	return tmp;
 }
 
 int sgn(const Point& a) {
 	return a.y() > 0 || (a.y() == 0 && a.x() > 0) ? 1 : -1;
 }
 
 bool onLeft(const Point& a, const Line& l) {
 	return cross(l.b - l.a, a - l.a) > 0;
 }
 
 Point intersection(const Line& l1, const Line& l2) {
 	return l1.a + (l1.b - l1.a) * (cross(l2.b - l2.a, l1.a - l2.a) / cross(l2.b - l2.a, l1.a - l1.b));
 }
 
 using polygen = std::vector<Point>;
 
 polygen hp(std::vector<Line>& lines) {
 	std::sort(lines.begin(), lines.end(), [&](auto l1, auto l2) {
 		auto d1 = l1.b - l1.a;
 		auto d2 = l2.b - l2.a;
 
 		if (sgn(d1) != sgn(d2)) {
 			return sgn(d1) == 1;
 		}
 
 		return cross(d1, d2) > 0;
 	});
 
 	std::deque<Line> ls;
 	std::deque<Point> ps;
 	for (auto l: lines) {
 		if (ls.empty()) {
 			ls.push_back(l);
 			continue;
 		}
 
 		while (!ps.empty() && !onLeft(ps.back(), l)) {
 			ps.pop_back();
 			ls.pop_back();
 		}
 
 		while (!ps.empty() && !onLeft(ps[0], l)) {
 			ps.pop_front();
 			ls.pop_front();
 		}
 
 		if (cross(l.b - l.a, ls.back().b - ls.back().a) == 0) {
 			if (dot(l.b - l.a, ls.back().b - ls.back().a) > 0) {
 				if (!onLeft(ls.back().a, l)) {
 					assert(ls.size() == 1);
 					ls[0] = l;
 				}
 				continue;
 			}
 			return {};
 		}
 
 		ps.push_back(intersection(ls.back(), l));
 		ls.push_back(l);
 	}
 
 	while (!ps.empty() && !onLeft(ps.back(), ls[0])) {
 		ps.pop_back();
 		ls.pop_back();
 	}
 	if (ls.size() <= 2) {
 		return {};
 	}
 	ps.push_back(intersection(ls[0], ls.back()));
 
 	return {ps.begin(), ps.end()};
 }
 
 
 template<typename T>
 int sign(T rr) {
 	return std::abs(rr) < eps ? 0 : rr < 0 ? -1 : 1;
 }
 
 bool crs(const Line& a, const Line& b) {
 	if (sign(cross(a.a - b.a, b.b - b.a)) * sign(cross(a.b - b.a, b.b - b.a)) >= 0)return false;
 	if (sign(cross(b.a - a.a, a.b - a.a)) * sign(cross(b.b - a.a, a.b - a.a)) >= 0)return false;
 	return true;
 }
 
 int main() {
 	std::ios::sync_with_stdio(false);
 	std::cin.tie(nullptr);
 	std::cout.tie(nullptr);
 
 	int n;
 	//	std::cin >> n;
 	scanf("%d", &n);
 	std::vector<Point> point(n);
 	std::vector<Line> lines_max;
 	lines_max.emplace_back(Point{1e4 + 10, -1e4 - 10}, Point{1e4 + 10, 1e4 + 10});
 	lines_max.emplace_back(Point{1e4 + 10, 1e4 + 10}, Point{-1e4 - 10, 1e4 + 10});
 	lines_max.emplace_back(Point{-1e4 - 10, 1e4 + 10}, Point{-1e4 - 10, -1e4 - 10});
 	lines_max.emplace_back(Point{-1e4 - 10, -1e4 - 10}, Point{1e4 + 10, -1e4 - 10});
 	for (int i = 0; i < n; ++i) {
 		T xx, yy;
 		//		std::cin >> xx >> yy;
 		scanf("%lf%lf", &xx, &yy);
 		point[i] = {xx, yy};
 	}
 	auto on_seg = [&](const Point& P, const Point& a, const Point& b) {
 		return sign(dot((P - a), (P - b))) <= 0 && std::abs(cross(P - a, P - b)) < eps;
 	};
 	auto on_seg_line = [&](const Line& l, const Point& a, const Point& b) -> int {
 		return sign(cross(l.b - l.a, l.a - a)) * sign(cross(l.b - l.a, l.a - b)) < 0 && sign(cross(b - a, a - l.a)) * sign(cross(b - a, a - l.b)) < 0;
 	};
 	auto in = [&](const Point& p) -> bool {
 		for (int i = 0; i < n; ++i) {
 			if (on_seg(p, point[i], point[(i + 1) % n]))return true;
 		}
 		Point dir = {43233.123422346L, 89939.12323486L};
 		int ret = 0;
 		for (int i = 0; i < n; ++i) {
 			ret += on_seg_line(Line(p, p + dir), point[i], point[(i + 1) % n]);
 		}
 		return ret & 1;
 	};
 
 	T ans = -1e18;
 	for (int i = 0; i < n; ++i) {
 		std::vector<Line> lines(lines_max);
 		for (int j = 0; j < n; ++j) {
 			if (i == j)continue;
 			Point mid = (point[i] + point[j]);
 			mid /= 2;
 			Point dir = point[j] - point[i];
 			dir = rotate(dir);
 //			dir = Norm(dir);
 			lines.emplace_back(mid - dir, mid + dir);
 		}
 		auto nearest = hp(lines);
 		int m = nearest.size();
 		for (int j = 0; j < m; ++j) {
 			auto p = nearest[j];
 			if (in(p)) {
 				ans = std::max(ans, abs(p - point[i]));
 			}
 			Line tmp = Line(nearest[(j + 1) % m], nearest[j]);
 			for (int k = 0; k < n; k++) {
 				Line tnp = Line(point[(k + 1) % n], point[k]);
 				if (crs(tmp, tnp)) ans = std::max(ans, abs(intersection(tmp, tnp) - point[i]));
 			}
 		}
 	}
 	printf("%.4lf", ans);
 	return 0;
 }
 
 ```





# 图论

## 联通分量

### 边双

#### 1.2021 ICPC Shenyang H

**题意**

给一个简单联通图，把边变成点，与这个边有同一个顶点的边与新图中这个边对应的点链接。每个边都有一个权值，求最大匹配。

**题目分析**

这个图的点最大匹配就是原图的有公共点的最大边匹配，那么如果图的大小为偶数，那么非常简单，肯定能够全部匹配上。但是如果出现了奇数，那么就要进行删边，那么要怎么删边呢，只要删掉的不是割边就行了。

**代码**

```c++
//
// Created by mrx on 2022/11/4.
//
#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <cmath>
#include <queue>
#include <stack>
#include <iomanip>
#include <array>
#include <map>

using i64 = long long;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n, m;
	std::cin >> n >> m;
	std::vector<std::vector<std::pair<int, int>>> adj(n);

	i64 sum = 0;

	for (int i = 0; i < m; ++i) {
		int u, v, w;
		std::cin >> u >> v >> w;
		sum += w;
		u--, v--;
		adj[u].emplace_back(v, w);
		adj[v].emplace_back(u, w);
	}


	std::stack<int> stk;
	std::vector<int> in_stack(n), siz(n), belong(n), dfn(n), low(n);
	int cnt = 0, scc = 0;
	std::function<void(int, int)> tarjan = [&](int u, int fa) {
		low[u] = dfn[u] = ++cnt;
		stk.push(u);
		for (auto [v, w]: adj[u]) {
			if (v == fa)continue;
			if (!dfn[v]) {
				tarjan(v, u);
				siz[u] += siz[v] + 1;
				low[u] = std::min(low[u], low[v]);
			} else if (!belong[v]) {
				low[u] = std::min(low[u], dfn[v]);
				if (dfn[v] > dfn[u])siz[u]++;
			}
		}
		if (dfn[u] == low[u]) {
			int v;
			scc++;
			do {
				v = stk.top();
				stk.pop();
				belong[v] = scc;
			} while (v != u);
		}
	};

	//如果是奇数的话就有一条边肯定匹配不上，那么就要删除掉。
	if (m & 1) {
		for (int i = 0; i < n; ++i) {
			if (!dfn[i])tarjan(i, i);
		}
		i64 ans = 0;
		for (int u = 0; u < n; ++u) {
			for (auto [v, w]: adj[u]) {
				//如果scc的大小是一个奇数，那么就要进行删边。
				if (belong[u] == belong[v] || (dfn[v] > dfn[u] && (!(siz[v] & 1))))ans = std::max(ans, sum - w);
			}
		}
		sum = ans;
	}

	std::cout << sum << '\n';

	return 0;
}
```





## 矩阵树定理

矩阵树定理一般用于求解$\sum_{T\in Tree}\prod_{e\in T}w_e$，

trick：通过把矩阵里的元素变为${1+w_ex}$的多项式可以求出$\sum_{T\in Tree}\sum_{e\in T}w_e$

### 1.校内赛 高等袋鼠

**题目描述** 

柴老师在上高等代数，今天老师讲到了矩阵树定理：

定义 Kirchhoff 矩阵为度数矩阵减去邻接矩阵，那么生成树个数就是 Kirchhoff 矩阵删掉第 i*i* 行第 i*i* 列后行列式的值...

作为代数学家的柴老师当然会这些啦，所以太过无聊听着听着就进入了梦乡。

在梦里，两幅无向图纠缠在一起，生成树怎么也看不清...

具体的，两幅无向图均为简单连通图，即无重边无自环，两幅图共享了顶点，即两幅图都有 n*n* 个顶点，编号为$ 1,\cdots,n$ 。

柴老师洋洋洒洒从第一幅图中**随机地**选出了一棵生成树，但转头一看，图变成了第二幅图！

也就是说，**此前选出的生成树**中，所有不在第二幅图中的**边**都消失了！

柴老师非常悲伤，想让你帮他算一下，所有可能的情况下他选出的生成树最后剩下的边数的和，答案对 998244353取模。

**题目分析**

trick：通过把矩阵里的元素变为${1+w_ex}$的多项式可以求出$\sum_{T\in Tree}\sum_{e\in T}w_e$

是trick的板子

```c++
//
// Created by mrx on 2022/10/4.
//
#include <vector>
#include <algorithm>
#include <iostream>
#include <array>
#include <functional>
#include <cassert>

using ll = long long;

template<typename T>
T inverse(T a, T b) {
	T u = 0, v = 1;
	while (a != 0) {
		T t = b / a;
		b -= t * a;
		std::swap(a, b);
		u -= t * v;
		std::swap(u, v);
	}
	assert(b == 1);
	return u;
}

template<typename T>
T power(T a, int b) {
	T ans = 1;
	for (; b; a *= a, b >>= 1) {
		if (b & 1)ans *= a;
	}
	return ans;
}

template<int Mod>
class Modular {
public:
	using Type = int;

	template<typename U>
	static Type norm(U& x) {
		Type v;
		if (-Mod <= x && x < Mod) v = static_cast<Type>(x);
		else v = static_cast<Type>(x % Mod);
		if (v < 0) v += Mod;
		return v;
	}

	constexpr Modular() : value() {}

	int val() const { return value; }

	Modular inv() const {
		return Modular(inverse(value, Mod));
	}

	template<typename U>
	Modular(const U& x) {
		value = norm(x);
	}

	const Type& operator ()() const {
		return value;
	}

	template<typename U>
	explicit operator U() const {
		return static_cast<U>(value);
	}

	Modular& operator +=(const Modular& other) {
		if ((value += other.value) >= Mod) value -= Mod;
		return *this;
	}

	Modular& operator -=(
			const Modular& other) {
		if ((value -= other.value) < 0) value += Mod;
		return *this;
	}

	template<typename U>
	Modular& operator +=(const U& other) { return *this += Modular(other); }

	template<typename U>
	Modular& operator -=(const U& other) { return *this -= Modular(other); }

	Modular& operator ++() { return *this += 1; }

	Modular& operator --() { return *this -= 1; }

	Modular operator ++(int) {
		Modular result(*this);
		*this += 1;
		return result;
	}

	Modular operator --(int) {
		Modular result(*this);
		*this -= 1;
		return result;
	}

	Modular operator -() const { return Modular(-value); }

	template<class ISTREAM_TYPE>
	friend ISTREAM_TYPE& operator >>(ISTREAM_TYPE& is, Modular& rhs) {
		ll v;
		is >> v;
		rhs = Modular(v);
		return is;
	}

	template<class OSTREAM_TYPE>
	friend OSTREAM_TYPE& operator <<(OSTREAM_TYPE& os, const Modular& rhs) {
		return os << rhs.val();
	}

	Modular& operator *=(const Modular& rhs) {
		value = ll(value) * rhs.value % Mod;
		return *this;
	}

	Modular& operator /=(const Modular& other) { return *this *= Modular(inverse(other.value, Mod)); }

	friend const Type& abs(const Modular& x) { return x.value; }

	friend bool operator ==(const Modular& lhs, const Modular& rhs) { return lhs.x == rhs.x; }

	friend bool operator <(const Modular& lhs, const Modular& rhs) { return lhs.x < rhs.x; }


	bool operator ==(const Modular& rhs) { return *this == rhs.value; }

	template<typename U>
	bool operator ==(U rhs) { return *this == Modular(rhs); }

	template<typename U>
	friend bool operator ==(U lhs, const Modular& rhs) { return Modular(lhs) == rhs; }

	bool operator !=(const Modular& rhs) { return *this != rhs; }

	template<typename U>
	bool operator !=(U rhs) { return *this != rhs; }

	template<typename U>
	friend bool operator !=(U lhs, const Modular& rhs) { return lhs != rhs; }

	bool operator <(const Modular& rhs) { return this->value < rhs.value; }

	Modular operator +(const Modular& rhs) { return Modular(*this) += rhs; }

	template<typename U>
	Modular operator +(U rhs) { return Modular(*this) += rhs; }

	template<typename U>
	friend Modular operator +(U lhs, const Modular& rhs) { return Modular(lhs) += rhs; }

	Modular operator -(const Modular& rhs) { return Modular(*this) -= rhs; }

	template<typename U>
	Modular operator -(U rhs) { return Modular(*this) -= rhs; }

	template<typename U>
	friend Modular operator -(U lhs, const Modular& rhs) { return Modular(lhs) -= rhs; }

	Modular operator *(const Modular& rhs) { return Modular(*this) *= rhs; }

	template<typename U>
	Modular operator *(U rhs) { return Modular(*this) *= rhs; }

	template<typename U>
	friend Modular operator *(U lhs, const Modular& rhs) { return Modular(lhs) *= rhs; }

	Modular operator /(const Modular& rhs) { return Modular(*this) /= rhs; }

	template<typename U>
	Modular operator /(U rhs) { return Modular(*this) /= rhs; }

	template<typename U>
	friend Modular operator /(U lhs, const Modular& rhs) { return Modular(lhs) /= rhs; }

private:
	Type value;
};

constexpr int mod = 998244353;
using Z = Modular<mod>;

struct node {
	Z x, y;

	node(Z x, Z y) : x(x), y(y) {}

	node() {}

	friend node operator +(const node& u, const node& v) {
		return node(u.x + v.x, u.y + v.y);
	}

	friend node operator -(const node& u, const node& v) {
		return node(u.x - v.x, u.y - v.y);
	}

	friend node operator *(const node& u, const node& v) {
		return node(u.x * v.y + u.y * v.x, u.y * v.y);
	}

	friend node operator /(const node& u, const node& v) {
		Z inv = v.y.inv();
		return node((u.x * v.y - u.y * v.x) * inv * inv, u.y * inv);
	}
};

struct matrix {
	std::vector<std::vector<node>> mat;

	int n, m;

	matrix(int n, int m) : mat(n, std::vector<node>(m, node(0, 0))), n(n), m(m) {}

	std::vector<node>& operator [](int idx) {
		return mat[idx];
	}

	Z gauss(int nn) {
		node res(0, 1);
		for (int i = 0; i < nn; ++i) {
			int nxt = i;
			for (; nxt < nn - 1; ++nxt)if (mat[nxt][i].y)break;
			if (mat[nxt][i].y) {
				std::swap(mat[nxt], mat[i]);
				if (nxt != i)res = res * node(0, -1);
				res = (res * mat[i][i]);
				node inv = node(0, 1) / mat[i][i];
				for (int j = i + 1; j < nn; ++j) {
					node div = mat[j][i] * inv;
					for (int k = i; k < nn; ++k) mat[j][k] = mat[j][k] - (div * mat[i][k]);
				}
			} else return 0;
		}
		return res.x;
	}
};

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	int n;
	std::cin >> n;
	std::vector<std::vector<int>> a(n, std::vector<int>(n));
	std::vector<std::vector<int>> b(n, std::vector<int>(n));
	std::vector<int> deg1(n), deg2(n);
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			char x;
			std::cin >> x;
			a[i][j] = x - '0';
		}
	}

	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			char x;
			std::cin >> x;
			b[i][j] = (x - '0');
		}
	}

	matrix mat(n, n);
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			if (a[i][j] == 1 && i >= j) {
				mat[i][i] = mat[i][i] + node(b[i][j] == 1, 1);
				mat[j][j] = mat[j][j] + node(b[i][j] == 1, 1);
				mat[i][j] = mat[i][j] - node(b[i][j] == 1, 1);
				mat[j][i] = mat[j][i] - node(b[i][j] == 1, 1);
			}
		}
	}
	std::cout << mat.gauss(n - 1) << '\n';

	return 0;
}
```





